[{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/categories/develop/","section":"Categories","summary":"","title":"Develop","type":"categories"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/categories/docker/","section":"Categories","summary":"","title":"Docker","type":"categories"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"Mac","type":"tags"},{"content":"Docker Desktop을 더 이상 사용하지 않거나, 문제가 발생하여 완전히 재설치해야 할 때가 있습니다. 단순히 응용 프로그램 파일만 삭제할 경우, 시스템에 불필요한 설정 파일이나 데이터가 남을 수 있습니다.\n이 가이드에서는 Docker Desktop 애플리케이션을 이용한 가장 간단한 방법과, 관련 파일을 모두 깨끗하게 지우는 수동 제거 방법을 단계별로 명확하게 안내합니다.\n방법 1: Docker Desktop 앱을 이용한 제거 (권장) # 가장 간단하고 안전한 방법으로, Docker가 정상적으로 실행되는 상태에서 사용하는 것을 권장합니다. 이 방법은 애플리케이션뿐만 아니라 관련된 대부분의 시스템 파일까지 자동으로 정리해 줍니다.\n화면 오른쪽 위 메뉴 막대에서 Docker 아이콘(🐳) 을 클릭합니다.\n나타나는 메뉴에서 톱니바퀴 모양의 설정(Settings) 아이콘을 클릭한 뒤, Troubleshoot 탭을 선택합니다. Uninstall 버튼을 클릭합니다.\n제거를 확인하는 창이 나타나면, 다시 한번 Uninstall 버튼을 눌러 제거를 완료합니다.\n방법 2: 터미널을 이용한 수동 완전 제거 # Docker Desktop 앱이 실행되지 않거나, 시스템에 남아있는 모든 관련 파일을 직접 깨끗하게 지우고 싶을 때 사용하는 방법입니다.\n⚠️ 경고: 아래 과정은 되돌릴 수 없으며, 시스템 파일을 직접 삭제하므로 신중하게 진행해야 합니다. 애플리케이션 삭제 # Finder를 열고 응용 프로그램 폴더에서 Docker.app을 찾아 휴지통으로 드래그하여 삭제합니다.\n남은 파일 및 설정 삭제 # 터미널을 열고 아래 명령어들을 한 줄씩 복사하여 실행합니다. 시스템에 남아있는 Docker 관련 설정 파일, 캐시, 데이터 등을 모두 삭제하는 과정입니다. 실행 시 사용자 계정의 비밀번호를 요구할 수 있습니다.\n# Docker 관련 시스템 라이브러리 및 바이너리 삭제 sudo rm -rf /usr/local/lib/docker sudo rm -rf /usr/local/bin/docker sudo rm -rf /usr/local/bin/docker-compose sudo rm -rf /usr/local/bin/docker-machine # 사용자 라이브러리 내의 Docker 관련 파일 삭제 rm -rf ~/.docker rm -rf ~/Library/Application\\ Support/Docker\\ Desktop rm -rf ~/Library/Containers/com.docker.docker rm -rf ~/Library/Caches/com.docker.docker rm -rf ~/Library/Preferences/com.docker.docker.plist (선택 사항) 컨테이너, 이미지, 볼륨 데이터 완전히 비우기 # Docker를 제거하기 전에, 디스크 공간을 차지하는 모든 컨테이너, 이미지, 볼륨을 먼저 삭제하고 싶다면 아래 명령어를 실행할 수 있습니다.\n이 명령어들은 Docker Desktop이 실행 중인 상태에서만 동작합니다. 제거를 시작하기 전에 실행하여 데이터를 정리하는 용도입니다. # 실행 중인 모든 컨테이너를 강제로 중지하고 삭제합니다. docker rm -f $(docker ps -aq) # 다운로드된 모든 Docker 이미지를 강제로 삭제합니다. docker rmi -f $(docker images -q) # 생성된 모든 Docker 볼륨을 삭제합니다. docker volume rm $(docker volume ls -q) 마무리하며 # 이것으로 Mac에서 Docker Desktop을 완전히 제거하는 모든 과정이 완료되었습니다. 대부분의 경우에는 공식 앱의 제거 기능을 사용하는 것으로 충분하지만, 문제가 발생하거나 완벽한 초기화를 원할 때는 수동 제거 방법을 통해 시스템을 깨끗하게 정리할 수 있습니다.\n참조\nDocker 공식 문서 - Uninstall Docker Desktop on Mac: https://docs.docker.com/desktop/uninstall/mac/ ","date":"9 August 2025","externalUrl":null,"permalink":"/posts/develop/docker/remove-docker-desktop-on-mac/","section":"","summary":"","title":"Mac에서 Docker Desktop 깨끗하게 제거하기","type":"posts"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/","section":"MINOSAUR","summary":"","title":"MINOSAUR","type":"page"},{"content":"","date":"9 August 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/categories/home-assistant/","section":"Categories","summary":"","title":"Home Assistant","type":"categories"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/tags/home-assistant/","section":"Tags","summary":"","title":"Home Assistant","type":"tags"},{"content":"Matter는 mDNS나 Bluetooth 같은 저수준 네트워크 프로토콜을 사용해 기기를 발견하고 통신해야 하므로, Home Assistant 컨테이너는 Docker의 가상 네트워크가 아닌 호스트(서버)의 네트워크를 직접 사용해야 합니다.\n이 가이드에서는 기존에 Traefik 리버스 프록시와 연동하여 사용하던 Home Assistant Docker 설정을 network_mode: host 로 변경하고, 이로 인해 발생하는 Traefik 연동 문제를 해결한 뒤, 최종적으로 Matter 서버를 설치하여 연동하는 전체 과정을 단계별로 안내합니다.\nHome Assistant 네트워크 모드 변경 (host 모드 전환) # 가장 먼저, Home Assistant가 Matter 기기들을 올바르게 인식할 수 있도록 docker-compose.yml 파일의 네트워크 설정을 변경합니다.\nhomeassistant/docker-compose.yml 파일을 열고 아래와 같이 수정하십시오.\n# homeassistant/docker-compose.yml version: \u0026#39;3\u0026#39; services: homeassistant: container_name: homeassistant image: \u0026#34;ghcr.io/home-assistant/home-assistant:stable\u0026#34; devices: - /dev/hci0:/dev/hci0 # Bluetooth 장치 volumes: - /home/kimminho/Services/homeassistant/config:/config - /etc/localtime:/etc/localtime:ro - /run/dbus:/run/dbus:ro - /var/run/dbus:/var/run/dbus:ro environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul restart: unless-stopped privileged: true # ------------------ (수정된 부분) ------------------ network_mode: host # 👈 [추가] 호스트 네트워크를 직접 사용하도록 설정 # networks: # 👈 [주석 또는 삭제] network_mode: host와 함께 사용할 수 없음 # - traefik-proxy # labels: # 👈 [주석 또는 삭제] Traefik의 Docker 자동 감지 기능이 더 이상 작동하지 않음 # - \u0026#34;traefik.enable=true\u0026#34; # - \u0026#34;traefik.http.routers.homeassistant.rule=Host(`ha.duckdns.org`)\u0026#34; # - \u0026#34;traefik.http.routers.homeassistant.entrypoints=websecure\u0026#34; # - \u0026#34;traefik.http.routers.homeassistant.tls=true\u0026#34; # - \u0026#34;traefik.http.routers.homeassistant.tls.certresolver=letsencrypt\u0026#34; # - \u0026#34;traefik.http.services.homeassistant.loadbalancer.server.port=8123\u0026#34; # networks: # 👈 [주석 또는 삭제] 서비스에서 사용하지 않으므로 전체 제거 # traefik-proxy: # external: true 핵심 변경 사항은 network_mode: host를 추가하고, 기존의 networks와 labels 설정을 모두 제거(또는 주석 처리)하는 것입니다.\nTraefik 연동 문제 해결 (수동 라우팅 설정) # network_mode: host를 사용하면 Home Assistant 컨테이너는 더 이상 Docker의 가상 네트워크에 속하지 않으므로, Traefik이 레이블을 통해 자동으로 감지할 수 없습니다.\n이 문제를 해결하려면, Traefik에게 Home Assistant의 위치를 파일 기반의 동적 설정(Dynamic Configuration) 을 통해 수동으로 알려줘야 합니다.\nTraefik 동적 설정 파일 생성 # Traefik의 docker-compose.yml 파일이 있는 경로에 dynamic과 같은 폴더를 만들고, 그 안에 아래 내용으로 homeassistant.yml 파일을 생성합니다.\n# traefik/dynamic/homeassistant.yml http: routers: homeassistant: rule: \u0026#34;Host(`ha.duckdns.org`)\u0026#34; entryPoints: - websecure service: homeassistant tls: certResolver: letsencrypt services: homeassistant: loadBalancer: servers: # Home Assistant가 호스트 네트워크의 8123 포트를 사용하므로, # 서버의 실제 내부 IP와 포트를 직접 지정해줍니다. - url: \u0026#34;http://192.168.0.10:8123\u0026#34; # 👈 서버의 실제 내부 IP 주소로 변경 ※ 주의: url 항목에는 Home Assistant가 실행 중인 서버의 내부 IP 주소를 정확히 입력해야 합니다.\nTraefik 설정 파일 수정 (traefik.yml 및 docker-compose.yml) # Traefik이 파일 기반의 동적 설정을 읽도록 traefik.yml 파일에 providers 설정을 추가합니다.\n# traefik/traefik.yml # ... (기존 api, entrypoints, certificatesResolvers 등 설정) ... providers: # Docker 레이블 감지 (기존 설정 유지) docker: exposedByDefault: false # ... # [추가] 파일 시스템 감지 file: # 감시할 디렉토리를 컨테이너 내부 경로로 지정 directory: /etc/traefik/dynamic # 변경 사항을 자동으로 감지할지 여부 watch: true traefik/docker-compose.yml 파일을 수정하여 2.1에서 생성한 dynamic 폴더를 컨테이너에 볼륨으로 연결합니다.\n# traefik/docker-compose.yml services: traefik: # ... (기존 설정) ... volumes: - /var/run/docker.sock:/var/run/docker.sock:ro - ./traefik.yml:/etc/traefik/traefik.yml:ro - ./acme.json:/etc/traefik/acme.json - ./dynamic:/etc/traefik/dynamic # 👈 [추가] dynamic 폴더를 컨테이너에 연결 Matter 서버 설치 # 이제 Home Assistant와 함께 동작할 공식 python-matter-server를 설치합니다. homeassistant/docker-compose.yml 파일을 다시 열고 services 항목에 matter-server를 추가합니다.\n# homeassistant/docker-compose.yml version: \u0026#39;3\u0026#39; services: homeassistant: # ... (1단계에서 수정한 Home Assistant 설정) ... matter-server: # 공식 python-matter-server 이미지 image: ghcr.io/home-assistant-libs/python-matter-server:8 container_name: matter-server restart: unless-stopped # ------------------ (핵심 설정) ------------------ # 호스트 네트워크를 직접 사용하여 mDNS, Bluetooth 등 사용 network_mode: host volumes: # Matter 데이터(Fabric, 기기 정보)를 영속적으로 저장 - ./matter-data:/data # 호스트의 DBus 시스템에 접근 허용 (Bluetooth 등에 필요) - /run/dbus:/run/dbus:ro # 저수준 네트워크 접근을 위한 권한 privileged: true matter-server가 사용할 데이터 폴더를 생성합니다.\n# homeassistant 폴더 내에서 실행 mkdir matter-data 방화벽 설정 및 서비스 재시작 # Matter 서버가 사용하는 5580번 포트를 방화벽에서 허용해 줍니다.\nsudo ufw allow 5580 sudo ufw reload # 또는 disable 후 enable 지금까지 수정한 모든 설정을 적용하기 위해, traefik과 homeassistant 각 디렉토리에서 아래 명령어를 실행하여 컨테이너를 다시 시작합니다.\ndocker-compose up -d --force-recreate 설정이 완료되면 IP주소:5580에서 서버 동작을 확인할 수 있습니다.\nHome Assistant에 Matter 연동 # 모든 서비스가 정상적으로 실행되면, Home Assistant 웹 UI에 접속합니다.\n[설정] \u0026gt; **[기기 및 서비스]**로 이동합니다.\n아래와 같이 발견된 구성요소에 Matter가 자동으로 표시됩니다. [구성하기] 버튼을 누르면 잠시 후 Matter 서버가 Home Assistant에 성공적으로 추가됩니다.\n마무리하며 # 축하합니다! 이제 여러분의 Home Assistant는 Matter 기기를 추가하고 제어할 모든 준비를 마쳤습니다. 비록 네트워크 모드 변경으로 인해 Traefik 설정을 수동으로 변경해야 하는 과정이 있었지만, 이를 통해 Matter의 강력한 기능을 Docker 환경에서도 안정적으로 활용할 수 있는 기반을 마련했습니다.\n참조\nHome Assistant - Matter Integration: https://www.home-assistant.io/integrations/matter/ Traefik - File Provider: https://doc.traefik.io/traefik/providers/file/ Python Matter Server - GitHub: https://github.com/home-assistant-libs/python-matter-server ","date":"8 August 2025","externalUrl":null,"permalink":"/posts/hosting/ha/home-assistant-add-matter-server/","section":"","summary":"","title":"Home Assistant Docker 컨테이너에 Matter 적용하기","type":"posts"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/tags/matter/","section":"Tags","summary":"","title":"Matter","type":"tags"},{"content":"","date":"26 July 2025","externalUrl":null,"permalink":"/tags/uuid/","section":"Tags","summary":"","title":"Uuid","type":"tags"},{"content":"분산 시스템 환경이나 데이터베이스를 다루다 보면, \u0026lsquo;충돌 없는 고유한 ID\u0026rsquo;의 필요성을 절감하게 됩니다. UUID는 바로 이 문제를 해결하기 위해 탄생한 표준 식별자입니다. 오늘은 UUID의 핵심 개념과 주요 활용처, 그리고 각 운영체제에서 UUID를 손쉽게 생성하는 방법을 명확하게 안내해 드리고자 합니다.\nUUID란 무엇인가? # UUID(Universally Unique Identifier) 는 전 세계적으로 거의 중복되지 않는 고유한 식별자를 생성하기 위한 표준 규약입니다.\n핵심은 중앙 관리 시스템 없이도 누구나, 어디서든 ID를 생성할 수 있으면서도, 그 ID가 다른 사람이 만든 ID와 겹칠 확률이 사실상 \u0026lsquo;0\u0026rsquo;에 가깝다는 점입니다. 일반적으로 123e4567-e89b-12d3-a456-426614174000와 같이 32개의 16진수 문자와 4개의 하이픈으로 구성된 128비트 값입니다.\nUUID를 사용하는 이유 # 고유성 보장: 여러 컴퓨터와 데이터베이스가 분산된 환경에서 각자 ID를 만들어도 서로 충돌할 걱정이 없습니다. 이는 데이터 병합이나 시스템 통합 시 발생할 수 있는 문제를 원천적으로 방지합니다.\n보안성: 1, 2, 3...처럼 순서대로 증가하는 ID는 다음 생성될 ID를 쉽게 예측할 수 있어 보안에 취약합니다. 반면 UUID는 무작위 문자열처럼 보여 예측이 불가능하므로, 외부에 노출되는 리소스 ID 등에 사용하기 안전합니다.\n독립적인 생성: ID를 생성하기 위해 중앙 서버에 \u0026ldquo;다음 번호를 주세요\u0026quot;라고 요청할 필요가 없습니다. 각 시스템이 네트워크 연결 없이도 자체적으로 고유한 ID를 생성할 수 있어 시스템의 독립성과 확장성을 높입니다.\nUUID의 주요 활용처 # UUID는 데이터를 고유하게 식별해야 하는 거의 모든 곳에서 활용될 수 있습니다.\n데이터베이스 기본 키 (Primary Key) # 여러 데이터베이스 서버를 사용하는 분산 시스템에서 각 서버가 고유한 ID를 가진 데이터를 생성할 때 사용합니다. 나중에 이 데이터들을 하나로 합쳐도 ID 충돌이 발생하지 않습니다.\n트랜잭션 및 로그 ID # 수많은 요청과 이벤트가 발생하는 대규모 시스템에서 각 처리 과정을 추적하기 위한 고유한 ID로 사용되어, 문제 발생 시 원인 분석을 용이하게 합니다.\n파일 및 리소스 식별자 # 사용자가 업로드하는 파일의 이름을 UUID로 변경하여 저장하면, 같은 이름의 파일이 업로드되어도 겹치지 않고 안전하게 보관할 수 있습니다.\n세션 및 인증 토큰 # 웹사이트나 앱에서 각 사용자의 로그인 상태를 유지하기 위한 세션 ID나 API 인증 토큰으로 사용됩니다. 추측이 불가능하여 보안성을 높입니다.\n운영체제별 UUID 생성 방법 # 각 운영체제에 내장된 도구를 사용하여 터미널에서 매우 간단하게 UUID를 생성할 수 있습니다.\nmacOS # Mac에서는 uuidgen이라는 기본 내장 명령어를 사용합니다.\n터미널 앱을 엽니다.\n아래 명령어를 입력하고 Enter 키를 누릅니다.\nuuidgen E0B3B5E0-A5A1-4A59-99B3-1B5B3AD3F3B8 와 같은 UUID가 즉시 생성됩니다. 결과를 바로 클립보드에 복사하려면 pbcopy와 함께 사용하십시오.\nuuidgen | pbcopy Ubuntu / Linux # Ubuntu를 포함한 대부분의 Linux 배포판에서도 uuidgen 명령어를 사용합니다.\n터미널을 엽니다.\n아래 명령어를 입력합니다.\nuuidgen xclip과 같은 도구가 설치되어 있다면, 아래 명령어로 결과를 클립보드에 복사할 수 있습니다.\n# xclip이 설치되어 있어야 합니다. uuidgen | xclip -selection clipboard Windows # 윈도우에서는 PowerShell을 사용하는 것이 가장 편리합니다.\nPowerShell을 엽니다. (시작 메뉴에서 PowerShell 검색)\n아래 명령어를 입력합니다.\n[guid]::NewGuid() 이 명령어는 Guid 객체 형태로 결과를 출력합니다.\n만약 순수한 UUID 문자열만 클립보드에 복사하고 싶다면, 아래의 명령어를 사용하세요.\n[guid]::NewGuid().ToString() | Set-Clipboard 이 명령을 실행하면 화면에 아무런 출력이 없지만, UUID가 클립보드에 복사되어 바로 붙여넣기(Ctrl + V)할 수 있습니다.\n참조\nRFC 4122: A Universally Unique IDentifier (UUID) URN Namespace - https://www.rfc-editor.org/rfc/rfc4122 ","date":"26 July 2025","externalUrl":null,"permalink":"/posts/develop/uuid-what-is-it/","section":"","summary":"","title":"UUID 완전 정복: 개념부터 생성 방법까지","type":"posts"},{"content":"","date":"26 July 2025","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"현대 소프트웨어 개발에서 성능과 안정성, 그리고 생산성은 매우 중요한 가치입니다. 오늘은 이 세 가지를 모두 만족시키기 위해 2009년 구글(Google)이 개발한 프로그래밍 언어, Go에 대해 소개하고 개발 환경을 구성하는 방법까지 안내해 드리고자 합니다.\nGo 언어는 C++이나 Java와 같은 기존 언어들의 복잡성은 줄이면서, 높은 성능과 안정적인 동시성 처리를 목표로 만들어졌습니다. 단순하고 명확한 문법을 가지고 있어 배우기 쉽고, 컴파일 방식 언어라 실행 속도가 매우 빠릅니다.\nGo 언어의 핵심 장점 # Go 언어는 다음과 같은 명확한 장점 덕분에 서버, 클라우드, DevOps 등 다양한 분야에서 빠르게 채택되고 있습니다.\n뛰어난 동시성(Concurrency) 지원 # 고루틴(Goroutine) 이라는 매우 가벼운 경량 스레드를 통해 수천, 수만 개의 작업을 동시에 처리하는 데 탁월한 성능을 보입니다. 이는 현대 멀티코어 프로세서 환경의 성능을 최대한으로 활용할 수 있게 해주는 강력한 기능입니다.\n빠른 컴파일과 실행 속도 # 코드를 기계어로 직접 변환하는 컴파일 언어이므로 실행 속도가 매우 빠릅니다. 또한, 컴파일 속도 자체도 다른 컴파일 언어에 비해 월등히 빨라, 코드를 수정한 후 결과를 확인하는 과정이 신속하여 개발 생산성이 높습니다.\n단순하고 명확한 문법 # 언어 사양에 포함된 키워드가 25개뿐일 정도로 문법이 매우 간결합니다. 이는 코드의 가독성을 높여 다른 개발자가 작성한 코드를 쉽게 이해하고 유지보수할 수 있게 하는 큰 장점으로 작용합니다.\n강력한 표준 라이브러리 및 도구 # 웹 서버, 암호화, 입출력(I/O) 등 네트워킹과 관련된 강력한 기능들이 표준 라이브러리에 내장되어 있어 외부 라이브러리에 대한 의존도가 낮습니다. 또한, go fmt(코드 서식 자동 정리), go test(테스팅) 등 개발 효율을 높이는 필수 도구를 기본으로 제공합니다.\nGo 언어 개발 환경 구성하기 # Go 언어 개발 환경 구성은 아래의 세 단계만으로 간단하게 완료할 수 있습니다.\nGo 공식 배포판 설치 # 공식 Go 웹사이트에 접속하여 자신의 운영체제(Windows, macOS, Linux)에 맞는 설치 파일을 다운로드하여 설치합니다. 대부분의 경우 설치 프로그램이 시스템 환경 변수까지 자동으로 설정해 주므로 추가 작업이 필요 없습니다.\n#mac brew install go 설치 확인 # 설치가 완료되면, 터미널(Windows에서는 PowerShell 또는 명령 프롬프트)을 열고 아래 명령어를 입력하여 버전 정보가 정상적으로 출력되는지 확인합니다.\ngo version go version go1.22.5 windows/amd64와 같은 결과가 나타나면 성공적으로 설치된 것입니다.\n코드 에디터 및 확장 프로그램 설치 (VS Code 추천) # **Visual Studio Code (VS Code)**를 코드 에디터로 사용하는 것을 가장 추천합니다.\nVS Code를 설치한 후 실행하고, 왼쪽의 확장 프로그램(Extensions) 탭으로 이동합니다.\n검색창에 Go 를 검색하여 Go team at Google이 제작한 공식 Go 확장 프로그램을 설치합니다.\n확장 프로그램 설치 후, .go 확장자를 가진 파일을 처음 열면 VS Code 오른쪽 하단에 관련 도구들을 설치하라는 알림이 나타납니다. [Install All] 버튼을 클릭하여 gopls(언어 서버), dlv(디버거) 등 필수 도구들을 모두 설치합니다.\n이 세 단계를 모두 마쳤다면, 여러분의 컴퓨터에서 Go 언어로 프로그램을 개발할 모든 준비가 완료된 것입니다.\n마무리하며 # 이제 현대적인 애플리케이션 개발에 매우 적합한 Go 언어의 개발 환경을 갖추게 되었습니다. Go의 단순함과 강력함을 직접 경험해 보며, 여러분의 아이디어를 빠르고 효율적으로 구현해 보시길 바랍니다.\n참조\nGo 언어 공식 웹사이트: https://go.dev/ Visual Studio Code용 Go 확장 프로그램: https://marketplace.visualstudio.com/items?itemName=golang.go ","date":"26 July 2025","externalUrl":null,"permalink":"/posts/develop/go-what-is-it/","section":"","summary":"","title":"Go 언어 시작하기: 개념부터 개발 환경 구성까지","type":"posts"},{"content":"","date":"26 July 2025","externalUrl":null,"permalink":"/tags/gemini/","section":"Tags","summary":"","title":"Gemini","type":"tags"},{"content":"인공지능 기술을 자신의 서비스에 접목하고 싶지만, 복잡한 AI 모델을 직접 개발하는 것은 큰 부담이 될 수 있습니다. 오늘은 구글의 가장 강력한 AI 모델인 \u0026lsquo;제미나이(Gemini)\u0026rsquo; 의 능력을 누구나 쉽게 활용할 수 있도록 돕는 프로그래밍 도구, 제미나이 API에 대해 소개해 드리고자 합니다.\n제미나이 API란? # 구글 제미나이(Gemini) API는 개발자들이 구글의 최첨단 인공지능 모델을 자신의 애플리케이션이나 서비스에 쉽게 연동할 수 있도록 만든 프로그래밍 인터페이스(API) 입니다.\n간단히 말해, 복잡한 AI 모델을 직접 만들거나 운영할 필요 없이, 이 API를 \u0026lsquo;호출\u0026rsquo;하는 것만으로 제미나이의 뛰어난 능력을 빌려 쓸 수 있게 해주는 \u0026lsquo;연결 다리\u0026rsquo; 역할을 합니다.\n주요 특징 # 멀티모달(Multimodal) 지원: 제미나이의 가장 큰 특징으로, 텍스트뿐만 아니라 이미지, 오디오, 비디오까지 한 번에 이해하고 처리할 수 있습니다. 예를 들어, 이미지와 텍스트를 함께 API에 보내 \u0026ldquo;이 사진에 어울리는 광고 문구를 만들어 줘\u0026quot;와 같은 복합적인 요청이 가능합니다.\n다양한 모델 제공: 가볍고 빠른 \u0026lsquo;제미나이 1.5 플래시(Gemini 1.5 Flash)\u0026rsquo; 부터 균형 잡힌 성능의 \u0026lsquo;제미나이 1.5 프로(Gemini 1.5 Pro)\u0026rsquo; 까지 다양한 모델을 제공하여, 사용 목적과 비용에 맞게 최적의 모델을 선택할 수 있습니다.\n쉬운 접근성: 개발자들은 Google AI Studio를 통해 간단한 API 키 발급만으로 빠르게 기능을 테스트해 볼 수 있으며, 더 큰 규모의 서비스는 Google Cloud의 Vertex AI 플랫폼을 통해 안정적으로 운영할 수 있습니다.\n무엇을 만들 수 있나요? # 지능형 챗봇 및 고객센터: 사람처럼 자연스럽게 대화하며 사용자의 질문에 답변하는 챗봇\n콘텐츠 자동 생성: 블로그 글, 마케팅 이메일, 소스 코드, 소설 등 다양한 종류의 텍스트 생성\n요약 및 분석: 긴 문서나 회의록을 핵심만 요약하거나, 이미지 속 객체를 분석하고 설명하는 기능 구현\n창의적인 도구: 사용자가 업로드한 이미지나 영상을 기반으로 새로운 스토리를 만들거나, 교육 자료를 생성하는 창의적인 앱 개발\n요금 정책: 무료와 유료 플랜 # 제미나이 API는 개인적인 학습과 테스트를 위한 넉넉한 무료 사용량과, 실제 서비스에 적용하기 위한 합리적인 종량제 요금을 제공합니다.\n무료 사용량 (Free Tier) # Google AI Studio를 통해 발급받은 API 키는 별도의 비용 없이 사용할 수 있는 무료 등급이 적용됩니다. 아래는 주요 Gemini API 모델별 무료 티어(Free Tier) 사용량 한도의 정리입니다.(2025년 7월 기준)\n모델 분당 요청(RPM) 분당 토큰(TPM) 일일 요청(RPD) 비고 Gemini 2.5 Pro 5 250,000 100 Google AI Studio 무료, 컨텍스트 윈도 1M Gemini 2.5 Flash 10 250,000 250 빠른 답변용, Flash-Lite 대비 낮은 한도 Gemini 2.5 Flash-Lite 15 250,000 1,000 초경량 LLM, 높은 일일 사용량 Gemini 2.0 Flash 15 1,000,000 200 Gemini 2.0 Flash-Lite 30 1,000,000 200 분당 요청수(RPM): 1분에 처리할 수 있는 최대 API 요청 건수 분당 토큰수(TPM): 1분에 입력할 수 있는 최대 토큰(단어 등) 수 일일 요청수(RPD): 1일 동안 API로 보낼 수 있는 총 요청 건수 Google AI Studio는 무료로 사용 가능, 별도 API 호출 비용 없음 RPM (Requests Per Minute): 1분 동안 보낼 수 있는 최대 요청 횟수입니다. 이 무료 등급은 개인 프로젝트, 학습, 기능 테스트 용도로는 충분하지만, 사용자가 많은 서비스에 적용하기에는 제한적일 수 있습니다.\n유료 요금 (Pay-as-you-go) # 무료 사용량 한도를 초과하거나 더 높은 처리량이 필요한 경우, Google Cloud 프로젝트에 결제를 설정하여 사용한 만큼 비용을 지불하는 종량제(Pay-as-you-go)로 전환할 수 있습니다. 요금은 주로 백만 토큰(1M tokens) 단위로 책정됩니다.\nGemini API 주요 가격표 (2025년 7월 기준)\n모델 입력 (1M 토큰당, USD) 출력 (1M 토큰당, USD) 컨텍스트 캐싱 (1M 토큰/시간) 비고 Gemini 2.5 Pro $1.25 (≤200K) / $2.50 (\u0026gt;200K) $10.00 (≤200K) / $15.00 (\u0026gt;200K) $0.31 (≤200K) / $0.625 (\u0026gt;200K) / $4.50(스토리지) 장문 프롬프트 가격 상승 Gemini 2.5 Flash $0.15 $0.60 (일반) / $3.50(Thinking 포함) $0.0375 Gemini 2.0 Flash $0.10 $0.40 $0.025 Gemini 2.0 Flash-Lite $0.075 $0.30 - 이미지 출력 - $30/1M 토큰 (약 $0.039/장) - 최대 1024x1024px Grounding(Google Search) 무료(1,500 RPD) 이후 $35/1K 요청 - 토큰(Token): 모델이 텍스트를 처리하는 기본 단위로, 대략 영어 단어 하나가 1~2 토큰에 해당합니다. (한글은 더 많은 토큰을 사용합니다.) 더 자세한 최신 정보는 **Gemini API 공식 가격 정책 페이지 **를 참고하시는 것이 가장 정확합니다.\n제미나이 API 시작하기 # 아래의 간단한 3단계만으로 제미나이 API를 직접 사용해 볼 수 있습니다.\n1단계: API 키 발급받기 # Google AI Studio 웹사이트에 접속하여 구글 계정으로 로그인합니다.\n왼쪽 메뉴에서 **[Get API key]**를 클릭합니다.\n[Create API key] 버튼을 눌러 새로운 API 키를 생성합니다.\n생성된 API 키 문자열을 복사하여 안전한 곳에 보관합니다. 이 키는 코드에서 제미나이를 호출할 때 사용됩니다.\n2단계: Python 라이브러리 설치 # 터미널을 열고 아래 명령어를 실행하여 Python용 Google AI 라이브러리를 설치합니다.\npip install -q -U google-generativeai 3단계: Python 코드로 API 호출하기 # 이제 Python 스크립트 파일을 만들어 아래 코드를 작성합니다.\nimport os import google.generativeai as genai # 1. API 키 설정 # ※ 주의: 실제 코드에 API 키를 직접 넣는 것은 보안상 위험합니다. # 아래 코드는 예시이며, 실제로는 환경 변수 등을 사용하는 것이 안전합니다. genai.configure(api_key=\u0026#34;YOUR_API_KEY\u0026#34;) # 👈 여기에 1단계에서 복사한 API 키를 붙여넣으세요. # 2. 모델 초기화 # \u0026#39;gemini-1.5-flash\u0026#39;는 가볍고 빠른 모델입니다. model = genai.GenerativeModel(\u0026#39;gemini-1.5-flash\u0026#39;) # 3. 프롬프트(질문)를 보내고 응답 받기 prompt = \u0026#34;Go 언어의 장점 3가지만 알려줘\u0026#34; response = model.generate_content(prompt) # 4. 결과 출력 print(response.text) 이 스크립트를 실행하면, 제미나이 API가 prompt의 내용을 이해하고 생성한 답변이 터미널에 출력됩니다.\n이것이 제미나이 API를 사용하는 가장 기본적인 흐름입니다.\n마무리하며 # 제미나이 API는 개발자들이 복잡한 인프라 구축 없이도 최첨단 AI 기술을 손쉽게 활용할 수 있도록 지원하는 강력한 도구입니다. 이 가이드를 시작으로 여러분의 창의적인 아이디어를 제미나이와 함께 현실로 만들어 보시길 바랍니다.\n참조\nGoogle AI Studio: https://aistudio.google.com/ Gemini API 공식 가격 정책: https://ai.google.dev/pricing Gemini API Python SDK 문서: https://ai.google.dev/docs/gemini_api_overview?hl=ko\u0026amp;lang=python ","date":"26 July 2025","externalUrl":null,"permalink":"/posts/develop/gemini-api-what-is-it/","section":"","summary":"","title":"Google 제미나이(Gemini) API 사용하기","type":"posts"},{"content":"","date":"25 July 2025","externalUrl":null,"permalink":"/tags/homebrew/","section":"Tags","summary":"","title":"Homebrew","type":"tags"},{"content":"","date":"25 July 2025","externalUrl":null,"permalink":"/categories/mac/","section":"Categories","summary":"","title":"Mac","type":"categories"},{"content":"macOS에서 개발 환경을 구축하다 보면 터미널에서 사용하는 다양한 도구들을 설치해야 할 때가 많습니다. Homebrew는 바로 이럴 때 필요한 macOS용 패키지 매니저(Package Manager) 입니다. App Store가 그래픽 앱을 위한 상점이라면, Homebrew는 개발 도구나 커맨드라인 프로그램들을 위한 App Store라고 생각하면 가장 쉽습니다.\n이 글에서는 Homebrew의 설치부터 핵심 사용법까지, Mac 사용자라면 반드시 알아야 할 내용들을 명확하게 설명합니다.\nHomebrew 설치하기 # Homebrew 설치는 매우 간단합니다. 터미널을 열고 아래의 명령어를 그대로 복사하여 붙여넣은 뒤 실행하면, 설치 스크립트가 알아서 모든 과정을 진행합니다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 설치 과정에서 사용자의 비밀번호를 요구하거나, Xcode Command Line Tools 설치가 필요하다는 메시지가 나타날 수 있습니다. 화면의 안내에 따라 진행하면 설치가 완료됩니다.\n핵심 명령어 5가지 # 아래 다섯 가지 명령어만 알고 있으면 Homebrew를 사용하는 데 전혀 문제가 없습니다.\nbrew install [패키지이름] # 가장 기본적이고 많이 사용하는 명령어로, 필요한 프로그램을 간단히 설치할 수 있습니다.\nbrew install wget brew update # 새로운 프로그램을 설치하기 전에 이 명령어를 실행하면, Homebrew 자체와 관리하는 패키지들의 목록이 최신 버전으로 갱신됩니다.\n이 명령어는 이미 설치된 프로그램들을 업그레이드하는 것이 아니라, Homebrew의 패키지 데이터베이스를 업데이트하는 역할을 합니다. brew upgrade [패키지이름] # 설치된 프로그램을 최신 버전으로 업그레이드합니다. 특정 프로그램만 업그레이드하려면 패키지 이름을 명시하고, 모든 프로그램을 한 번에 업그레이드하려면 패키지 이름을 생략합니다.\nbrew upgrade node (node.js만 업그레이드)\nbrew upgrade (Homebrew로 설치한 모든 프로그램 업그레이드)\nbrew uninstall [패키지이름] # 설치된 프로그램을 제거합니다.\nbrew uninstall wget brew list\nHomebrew로 설치한 모든 프로그램의 목록을 확인합니다. 내가 어떤 프로그램들을 설치했는지 한눈에 볼 수 있습니다.\nFormula와 Cask: 꼭 알아야 할 차이점 # Homebrew는 두 가지 종류의 패키지를 관리하며, 이 차이를 아는 것은 매우 중요합니다.\nFormula 🍺 # 커맨드라인 도구를 설치할 때 사용합니다. 주로 터미널 기반으로 동작하는 wget, node, tree, python과 같은 개발용 소프트웨어들이 해당됩니다.\nbrew install [formula-이름] Cask 📦 # 그래픽 인터페이스(GUI)가 있는 일반적인 Mac 애플리케이션을 설치할 때 사용합니다. Google Chrome, Visual Studio Code, Slack, Firefox 등 우리가 흔히 사용하는 앱들을 설치할 수 있습니다.\nbrew install --cask [cask-이름] --cask 옵션의 유무에 따라 설치 대상이 완전히 달라지므로, GUI 앱을 설치할 때는 반드시 --cask 옵션을 붙여야 합니다.\n# 커맨드라인 도구 \u0026#39;tree\u0026#39; 설치 brew install tree # GUI 앱 \u0026#39;Visual Studio Code\u0026#39; 설치 brew install --cask visual-studio-code Homebrew 설치 경로는 어디일까요? # Homebrew는 시스템을 오염시키지 않도록, 설치하는 모든 파일들을 별도의 경로에 체계적으로 관리합니다. Mac의 아키텍처에 따라 설치 경로가 다릅니다.\nApple Silicon (M1/M2/M3 등) Mac: /opt/homebrew\nIntel Mac: /usr/local\n사용자는 이 경로를 직접 기억하거나 관리할 필요가 없습니다. Homebrew가 설치 과정에서 환경 설정을 통해, 터미널 어디에서든 설치된 프로그램을 바로 사용할 수 있도록 자동으로 경로를 연결(symlink)해주기 때문입니다.\n이처럼 Homebrew를 사용하면 복잡한 설치 과정 없이 필요한 도구들을 깔끔하게 관리할 수 있습니다.\n","date":"25 July 2025","externalUrl":null,"permalink":"/posts/mac/homebrew-basic/","section":"","summary":"","title":"Mac 개발 환경의 필수품, Homebrew 알아보기","type":"posts"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/tags/oracle-cloud/","section":"Tags","summary":"","title":"Oracle Cloud","type":"tags"},{"content":"","date":"23 July 2025","externalUrl":null,"permalink":"/categories/server/","section":"Categories","summary":"","title":"Server","type":"categories"},{"content":"지난 가이드를 통해 오라클 클라우드(OCI) 무료 티어 계정 생성을 완료하셨다면, 이제 그 계정을 활용하여 실제 가상 서버를 구축할 차례입니다.\n이 가이드에서는 OCI의 \u0026lsquo;Always Free\u0026rsquo; 자원을 활용하여 24시간 운영 가능한 VM(Virtual Machine) 인스턴스를 생성하는 전체 과정을 단계별로 상세히 알아보겠습니다.\nOCI 콘솔 접속 및 인스턴스 생성 준비 # 먼저, 모든 클라우드 자원을 관리하는 OCI 콘솔에 로그인하여 VM 인스턴스 생성 페이지로 이동합니다.\n오라클 클라우드 콘솔에 로그인합니다.\n화면 왼쪽 상단의 햄버거 메뉴(☰) 를 클릭합니다.\n메뉴에서 [Compute] \u0026gt; [Instances] 항목을 차례로 선택합니다.\nInstances 페이지가 나타나면, [Create instance] 버튼을 클릭하여 생성을 시작합니다.\nVM 인스턴스 구성 # 이제 생성할 VM 인스턴스의 세부 사항을 설정합니다. 무료 티어 자원을 최대한 활용하기 위해 \u0026ldquo;Always Free Eligible\u0026rdquo; 표시가 붙은 옵션을 선택하는 것이 이 과정의 핵심입니다.\n기본 정보 입력 # Name: 인스턴스를 식별할 고유한 이름을 입력합니다. (예: my-ubuntu-server)\nCompartment: 자원을 논리적으로 그룹화하는 구획입니다. 처음에는 기본값(root)을 그대로 사용해도 무방합니다.\nPlacement (Availability Domain): 인스턴스가 위치할 데이터센터 내의 독립된 구역입니다. 특별한 요구사항이 없다면 기본 제안 값을 사용합니다.\n이미지 및 구성(형태) 선택 # 서버의 운영체제(Image)와 하드웨어 사양(Shape)을 결정하는 가장 중요한 단계입니다.\nImage (이미지): [Change image] 버튼을 클릭합니다.\nImage source는 Oracle Images를 선택합니다.\nOS 목록에서 \u0026ldquo;Always Free Eligible\u0026rdquo; 태그가 붙은 이미지를 선택합니다. Ubuntu 최신 LTS 버전은 사용자 커뮤니티가 활발하고 관련 자료가 풍부하여 처음 시작하는 분들께 강력히 추천합니다.\n이미지 선택 후 [Select image] 버튼을 클릭합니다.\nShape (형태): [Change shape] 버튼을 클릭합니다.\nInstance type은 Virtual Machine으로 선택합니다.\nShape series에서 \u0026ldquo;Always Free Eligible\u0026rdquo; 옵션을 선택합니다.\nAmpere A1.Flex 형태를 적극 활용하십시오.\n무료 티어에서 제공하는 VM.Standard.A1.Flex (ARM 기반) 형태는 CPU 코어(최대 4 OCPU)와 메모리(최대 24GB)를 계정의 무료 한도 내에서 유연하게 조합할 수 있는 매우 효율적인 옵션입니다. 예를 들어, OCPU 1개와 메모리 6GB를 할당한 단일 인스턴스를 무료로 생성할 수 있습니다. 대부분의 최신 소프트웨어를 지원하며, 개인 프로젝트나 개발 서버로 사용하기에 충분한 성능을 제공합니다.\n네트워킹 설정 # 서버가 외부 인터넷과 통신하고 사용자가 서버에 접속하기 위한 네트워크 환경을 구성합니다.\nPrimary network (주 네트워크): Create new virtual cloud network (VCN) 을 선택하여 새로운 가상 네트워크를 생성합니다. VCN은 다른 사용자와 격리된 나만의 안전한 네트워크 공간입니다.\nSubnet (서브넷): Create new public subnet 을 선택합니다. Public Subnet은 인스턴스가 외부 인터넷과 직접 통신할 수 있도록 하는 필수 요소입니다.\nPublic IP address (공인 IP 주소): Assign a public IPv4 address 옵션을 반드시 선택해야 합니다. 이 옵션을 선택해야만 인터넷을 통해 서버에 접속할 수 있는 고유한 공인 IP 주소가 할당됩니다.\nSSH 키 추가 # 서버에 안전하게 접속하기 위한 SSH 키를 설정합니다. 비밀번호 방식보다 훨씬 안전합니다.\nGenerate a key pair for me: OCI가 키를 생성해주고, 사용자는 개인키 파일을 다운로드하여 보관합니다. 간편하지만 개인키 파일 관리에 각별한 주의가 필요합니다.\nUpload public key files (.pub): (권장) 사용자의 PC에서 직접 생성한 SSH 키 쌍 중, 공개키(.pub 파일) 만 업로드하는 방식입니다. 개인키가 PC 밖으로 나가지 않아 더 안전합니다.\nPaste public keys: 공개키 파일의 내용을 복사하여 직접 붙여넣는 방식입니다.\nSSH 키 생성 방법에 대한 자세한 내용은 아래 글을 참고하시면 도움이 될 것입니다. SSH Key 알아보기 22 July 2025\u0026middot;636 words\u0026middot;3 mins 부트 볼륨 및 생성 # Boot volume (부트 볼륨): 운영체제가 설치될 디스크 설정입니다. 무료 티어는 계정당 총 200GB의 블록 볼륨을 제공하며, 기본 설정(약 50GB)은 이 한도 내에 포함되므로 그대로 사용해도 충분합니다. 모든 설정 검토 후, 페이지 하단의 [Create] 버튼을 클릭합니다.\n생성된 VM 인스턴스 확인 및 접속 # 인스턴스 상태가 Provisioning(준비 중) 에서 녹색의 Running(실행 중) 으로 바뀌면 서버 생성이 완료된 것입니다.\n생성된 인스턴스의 상세 정보 페이지로 이동합니다.\nInstance access 섹션에서 Public IP address (공인 IP 주소) 를 복사합니다.\n로컬 PC의 터미널 또는 SSH 클라이언트를 사용하여 아래 형식으로 접속 명령어를 실행합니다.\nssh -i [개인키_파일_경로] [사용자이름]@[서버_공인_IP_주소] ssh -i ~/.ssh/my_oci_key ubuntu@123.123.123.123 [개인키_파일_경로]: 2단계에서 준비한 SSH 개인키 파일의 위치 (예: ~/.ssh/id_ed25519)\n[사용자이름]: 선택한 OS의 기본 사용자 이름입니다.\nOracle Linux: opc Ubuntu: ubuntu [서버_공인_IP_주소]: 위에서 복사한 IP 주소\n처음 접속 시 나타나는 호스트 진위 여부 확인 질문에는 yes를 입력하면 됩니다.\n마무리하며 # 이제 여러분은 24시간 가동되는 안정적인 개인 클라우드 서버를 소유하게 되었습니다. 이 서버는 다음과 같은 무한한 가능성을 지닌 여러분만의 실험실이 될 수 있습니다.\n웹 서버 구축: Nginx, Apache를 설치하여 개인 웹사이트나 기술 블로그 운영 개발 환경: Python, Node.js, Java 등 다양한 언어 및 데이터베이스 환경 구성 애플리케이션 호스팅: 직접 만든 토이 프로젝트나 소규모 애플리케이션의 백엔드 서버로 활용 학습 및 실험: 리눅스 명령어, 서버 관리, 네트워크 등 다양한 IT 기술을 직접 체험하고 학습하는 공간 ","date":"23 July 2025","externalUrl":null,"permalink":"/posts/hosting/oracle/create-instance-in-oracle/","section":"","summary":"","title":"오라클 클라우드(OCI) VM 인스턴스 생성하기","type":"posts"},{"content":"","date":"22 July 2025","externalUrl":null,"permalink":"/tags/ssh/","section":"Tags","summary":"","title":"Ssh","type":"tags"},{"content":"여러 대의 원격 서버를 관리하다 보면, 각 서버의 주소, 사용자 이름, 포트 번호, 그리고 사용하는 SSH 키가 달라 접속할 때마다 긴 명령어를 반복적으로 입력해야 하는 번거로움이 있습니다.\n오늘은 이러한 불편함을 해결하고 SSH 접속 관리를 획기적으로 개선해 주는 SSH config 파일 설정 및 활용법에 대해 상세히 알아보고자 합니다. 이 가이드를 통해 ssh my-server와 같은 간단한 별명만으로 어떤 서버든 신속하고 정확하게 접속하는 방법을 익히실 수 있습니다.\nSSH config 파일이란? # SSH config 파일은 각 원격 서버에 접속하는 데 필요한 정보들(서버 주소, 사용자 이름, 포트, SSH 키 경로 등)을 미리 정의해두는 사용자별 SSH 클라이언트 설정 파일입니다. 이 파일을 사용하면 길고 복잡한 접속 명령어를 기억하기 쉬운 별명(Alias) 으로 대체하여 생산성을 크게 높일 수 있습니다.\nconfig 파일의 위치 # config 파일은 보통 SSH 키가 저장되는 사용자의 홈 디렉토리 내 .ssh 폴더에 위치합니다.\nmacOS/Linux: ~/.ssh/config\nWindows: C:\\Users\\사용자이름\\.ssh\\config\n만약 .ssh 폴더 내에 config 파일이 없다면, 직접 파일을 생성하여 사용할 수 있습니다.\n기본 구조와 주요 설정 옵션 # config 파일은 하나 이상의 Host 블록으로 구성됩니다. 각 Host 블록은 특정 서버 접속을 위한 설정 묶음이며, 다음과 같은 기본 구조를 가집니다.\nHost [접속 시 사용할 별명] HostName [서버의 실제 주소] User [접속할 사용자 이름] [기타 필요한 옵션] 아래는 config 파일에서 가장 자주 사용되는 핵심 옵션들입니다.\n옵션 설명 Host 접속 시 사용할 고유한 별명을 지정합니다. (필수) HostName 접속할 서버의 실제 IP 주소 또는 도메인 이름을 지정합니다. User 해당 서버에 접속할 사용자 이름을 지정합니다. Port SSH 접속 포트 번호를 지정합니다. (기본값은 22) IdentityFile 해당 서버 접속에 사용할 개인키(Private Key)의 절대 경로를 지정합니다. 사용 예시 # ~/.ssh/config 파일에 아래와 같이 두 개의 서버 정보를 설정했다고 가정해 보겠습니다.\n# 개인 개발 서버 (주석은 \u0026#39;#\u0026#39;으로 시작합니다) Host dev-server HostName 192.168.1.100 User ubuntu Port 2222 IdentityFile ~/.ssh/id_ed25519_dev # 회사 GitLab 서버 Host gitlab HostName gitlab.mycompany.com User git IdentityFile ~/.ssh/id_rsa_work 이제 터미널에서 아래와 같이 간단한 명령어로 각 서버에 접속할 수 있습니다.\n# dev-server 별명으로 개인 개발 서버에 접속 ssh dev-server # 위 명령어는 내부적으로 아래의 긴 명령어를 실행한 것과 동일합니다. # ssh -p 2222 -i ~/.ssh/id_ed25519_dev ubuntu@192.168.1.100 # gitlab 별명으로 회사 GitLab 서버에 접속 ssh gitlab # 위 명령어는 내부적으로 아래의 명령어를 실행한 것과 동일합니다. # ssh -i ~/.ssh/id_rsa_work git@gitlab.mycompany.com 알아두면 유용한 추가 옵션 # 기본 옵션 외에도 SSH 접속 환경을 더욱 세밀하게 제어할 수 있는 유용한 옵션들이 있습니다.\n옵션 설명 ServerAliveInterval 지정된 시간(초)마다 서버에 신호를 보내 세션을 유지합니다. 방화벽 등에 의해 연결이 끊기는 것을 방지합니다. (예: ServerAliveInterval 60) ServerAliveCountMax ServerAliveInterval 신호에 서버가 응답하지 않을 경우, 접속이 끊어지기 전까지 재시도할 횟수를 지정합니다. (예: ServerAliveCountMax 3) ConnectTimeout 서버 접속 시도 시, 응답을 기다리는 최대 시간(초)을 설정합니다. ForwardAgent 로컬 SSH Agent에 등록된 키를 원격 서버에서도 연속하여 사용할 수 있게 합니다. (예: 내 PC -\u0026gt; A서버 -\u0026gt; B서버로 키 전달) StrictHostKeyChecking 처음 접속하는 서버의 호스트 키를 ~/.ssh/known_hosts 파일에 자동으로 추가할지 여부를 결정합니다. no로 설정하면 확인 질문 없이 추가됩니다. 공식 매뉴얼(Manual) 확인 방법 # config 파일에 사용할 수 있는 모든 옵션과 정확한 설명은 공식 매뉴얼을 통해 확인할 수 있습니다.\n터미널에서 직접 확인 # 터미널에서 man ssh_config 명령어를 실행하면, config 파일에 대한 가장 정확하고 상세한 매뉴얼을 볼 수 있습니다. (탐색: 화살표 키, 검색: /검색어, 종료: q)\n온라인 매뉴얼 페이지 # 웹 브라우저를 통해 공식 매뉴얼 페이지를 확인할 수도 있습니다.\nOpenBSD Manual (가장 공식적): https://man.openbsd.org/ssh_config Linux Man Page: https://man7.org/linux/man-pages/man5/ssh_config.5.html ","date":"22 July 2025","externalUrl":null,"permalink":"/posts/develop/ssh-config-for-easy-connect/","section":"","summary":"","title":"SSH Config 설정으로 원격 서버에 쉽게 접속하기","type":"posts"},{"content":"서버에 접속할 때마다 비밀번호를 입력하는 방식은 편리하지만, 보안에 취약할 수 있습니다. 오늘은 비밀번호 없이도 훨씬 안전하고 편리하게 서버에 접속할 수 있게 해주는 SSH Key에 대해, 그 원리부터 생성 방법까지 알아보고자 합니다.\nSSH Key는 공개키 암호화 방식을 기반으로 동작하는 한 쌍의 암호화 키입니다. \u0026lsquo;자물쇠\u0026rsquo; 역할을 하는 공개키(Public Key) 와, 오직 그 자물쇠만 열 수 있는 \u0026lsquo;열쇠\u0026rsquo;인 개인키(Private Key) 로 구성되어, 안전한 통신을 보장하는 핵심적인 보안 도구입니다.\n작동 원리 # SSH Key의 작동 방식은 자물쇠와 열쇠의 비유로 쉽게 이해할 수 있습니다.\n키 쌍 생성: 사용자는 먼저 자신의 컴퓨터(클라이언트)에서 개인키(열쇠) 와 공개키(자물쇠) 한 쌍을 생성합니다.\n공개키(자물쇠) 등록: 접속하려는 원격 서버에 나의 공개키(자물쇠)를 미리 복사하여 등록해 둡니다. (~/.ssh/authorized_keys 파일에 추가하는 방식)\n접속 시도: 내 컴퓨터에서 원격 서버로 SSH 접속을 시도합니다.\n인증 과정:\n서버는 접속을 시도한 사용자를 확인하기 위해, 미리 등록된 공개키(자물쇠) 로 암호화한 임의의 메시지(챌린지)를 사용자 컴퓨터로 보냅니다.\n이 암호화된 메시지는 오직 쌍을 이루는 개인키(열쇠) 로만 해독할 수 있습니다.\n내 컴퓨터가 개인키를 사용해 메시지를 성공적으로 해독하여 응답하면, 서버는 \u0026lsquo;올바른 열쇠를 가진 신뢰할 수 있는 사용자\u0026rsquo;로 판단하고 비밀번호 입력 없이 접속을 허용합니다.\n이 모든 과정에서 실제 비밀번호나 개인키 자체가 네트워크를 통해 전송되지 않으므로, 중간에 통신을 가로채도 정보가 유출될 위험이 없습니다.\nSSH Key를 사용하는 이유 # 비밀번호 인증 방식에 비해 SSH Key는 다음과 같은 명확한 장점을 가집니다.\n강력한 보안: 비밀번호는 유추가 가능하거나 무차별 대입 공격(Brute-force attack) 에 취약할 수 있습니다. 반면, SSH Key는 매우 복잡한 암호문으로 이루어져 있어 현대 컴퓨터 기술로 사실상 해독이 불가능에 가깝습니다.\n높은 편의성: 키를 한 번 등록해 두면, 이후 서버에 접속할 때마다 번거롭게 비밀번호를 입력할 필요 없이 즉시 로그인할 수 있습니다.\n안전한 자동화: 자동화된 배포 스크립트(CI/CD)나 백업 작업 시, 코드나 설정 파일에 민감한 비밀번호를 노출하지 않고도 안전하게 서버에 접속하여 명령을 수행할 수 있습니다.\nSSH Key 생성하기 # SSH Key는 대부분의 운영체제(macOS, Linux, Windows)에 내장된 ssh-keygen이라는 간단한 명령어로 생성할 수 있습니다.\n키 생성 알고리즘 선택 # 명령어 실행에 앞서, 어떤 암호화 알고리즘을 사용할지 결정하는 것이 좋습니다.\nEd25519 (가장 추천): 현재 가장 안전하고 성능이 뛰어난 방식으로 평가받습니다. 기존의 RSA 방식보다 키 길이가 짧으면서도 더 강력한 보안을 제공합니다. 대부분의 최신 시스템에서 지원합니다.\nRSA: 가장 오랫동안 사용되어 호환성이 매우 뛰어납니다. Ed25519를 지원하지 않는 오래된 시스템에 접속해야 할 경우에 유용하며, 보안을 위해 키 길이는 최소 2048비트, 권장 4096비트를 사용해야 합니다.\n특별한 이유가 없다면 Ed25519 알고리즘을 사용하는 것이 가장 좋은 선택입니다.\n키 생성 명령어 실행 # 터미널을 열고, 원하는 알고리즘에 맞춰 아래 명령어 중 하나를 실행합니다.\nEd25519 키 생성 (권장)\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; RSA 키 생성 (호환성 필요시)\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; -t (type): ed25519 또는 rsa와 같이 키의 암호화 알고리즘을 지정합니다.\n-b (bits): RSA 키의 길이를 비트 단위로 지정합니다. (Ed25519는 불필요)\n-C (comment): 키를 식별하기 위한 설명을 추가합니다. 보통 관리의 편의를 위해 이메일 주소를 사용합니다.\n생성 과정 안내 # 명령어를 실행하면 터미널에서 몇 가지 정보를 순서대로 입력하도록 요청합니다.\n키 저장 위치 지정\n\u0026gt; Enter file in which to save the key (/Users/your-username/.ssh/id_ed25519): 생성된 키 파일을 저장할 위치를 묻습니다. 특별한 경우가 아니라면 기본 경로 사용을 권장하므로, 그냥 Enter 키를 누르십시오. 기본 경로는 보통 사용자 홈 디렉토리 아래의 숨겨진 .ssh 폴더입니다.\n비밀구문(Passphrase) 설정\n\u0026gt; Enter passphrase (empty for no passphrase): \u0026gt; Enter same passphrase again: 생성된 개인키 파일 자체를 암호화할 추가 비밀번호(비밀구문)를 설정하는 단계입니다. 만약 개인키 파일(id_ed25519)이 외부에 유출되더라도, 이 비밀구문을 모르면 키를 사용할 수 없게 만들어 보안을 한층 더 강화합니다. 비밀구문을 사용하지 않으려면 아무것도 입력하지 않고 Enter 키를 두 번 누르면 됩니다.\n생성 완료\n모든 과정이 끝나면 키 생성이 완료되었다는 메시지와 함께 아래와 같이 공개키의 \u0026lsquo;지문(fingerprint)\u0026lsquo;이 표시됩니다.\nYour identification has been saved in /Users/your-username/.ssh/id_ed25519 Your public key has been saved in /Users/your-username/.ssh/id_ed25519.pub ... 이제 지정된 경로(~/.ssh/)에 아래와 같이 두 개의 파일이 생성된 것을 확인할 수 있습니다.\nid_ed25519: 개인키 (Private Key). 나의 열쇠에 해당하며, 절대 외부에 노출하거나 타인에게 전달해서는 안 됩니다.\nid_ed25519.pub: 공개키 (Public Key). 나의 자물쇠에 해당하며, 원격 서버 등 다른 곳에 복사하여 등록하는 용도로 사용됩니다. .pub 확장자로 쉽게 구분할 수 있습니다.\n이제 생성된 공개키(id_ed25519.pub)의 내용을 복사하여 접속하고자 하는 서버에 등록하면, 비밀번호 없는 안전한 SSH 접속을 이용할 수 있습니다.\n","date":"22 July 2025","externalUrl":null,"permalink":"/posts/develop/what-is-ssh-key/","section":"","summary":"","title":"SSH Key 알아보기","type":"posts"},{"content":"","date":"21 July 2025","externalUrl":null,"permalink":"/categories/self-hosting/","section":"Categories","summary":"","title":"Self Hosting","type":"categories"},{"content":"","date":"21 July 2025","externalUrl":null,"permalink":"/tags/transmission/","section":"Tags","summary":"","title":"Transmission","type":"tags"},{"content":"Docker를 이용해 Transmission과 같은 개인 서버를 구축하고 외부 네트워크에서 접속하여 사용하는 것은 매우 편리한 경험입니다. 하지만 별도의 보안 설정을 하지 않으면, 나의 서버에 누구나 접속할 수 있는 상태가 되어 잠재적인 위험에 노출될 수 있습니다.\n오늘은 이러한 위험을 방지하기 위해, 가장 기본적이면서도 필수적인 보안 조치인 ID/Password 인증 기능을 활성화하는 방법을 안내해 드리고자 합니다. linuxserver/transmission Docker 이미지를 사용하고 계신다면, 아주 간단한 설정 변경만으로 서버의 보안을 크게 강화할 수 있습니다.\n인증 기능, 왜 필요한가요? # Transmission 웹 인터페이스에 인증 기능을 설정하는 것은 내 서버의 \u0026lsquo;문\u0026rsquo;에 \u0026lsquo;자물쇠\u0026rsquo;를 채우는 것과 같습니다. 인증 기능이 없다면, 서버의 IP 주소와 포트 번호를 아는 사람은 누구나 접속하여 아래와 같은 작업을 할 수 있습니다.\n내가 다운로드하는 파일 목록 확인\n진행 중인 토렌트 임의로 중지 또는 삭제\n악의적인 파일을 서버에 추가\n이러한 무단 접근을 막고 오직 허가된 사용자만 접속할 수 있도록 하는 것이 바로 ID/Password 인증의 핵심 목적입니다.\ndocker-compose.yml 환경 변수로 인증 활성화하기 # linuxserver/transmission 이미지는 사용자의 편의를 위해, 복잡한 설정 파일을 직접 수정하지 않고도 docker-compose.yml 파일에 환경 변수(Environment Variables) 를 추가하는 것만으로 손쉽게 인증 기능을 켤 수 있도록 지원합니다.\ndocker-compose.yml 파일에 USER 및 PASS 환경 변수 추가\nTransmission 컨테이너를 실행하는 데 사용하는 docker-compose.yml 파일을 텍스트 편집기로 엽니다. services \u0026gt; transmission \u0026gt; environment 섹션에 아래와 같이 USER와 PASS 변수를 추가하고, 원하시는 ID와 Password를 입력합니다.\n# ~/docker/transmission/docker-compose.yml services: transmission: image: linuxserver/transmission:latest container_name: transmission # ... (기타 다른 설정들) ... environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul - USER=my_secure_user # 👈 여기에 원하는 사용자 아이디를 설정하십시오. - PASS=MyComplexPassword123! # 👈 여기에 강력한 비밀번호를 설정하십시오. # ... (volumes, ports, labels 등 나머지 설정) ... restart: unless-stopped 컨테이너 재시작\n수정한 docker-compose.yml 파일을 저장한 후, 아래 명령어를 실행하여 변경사항을 적용합니다. 컨테이너가 새로운 환경 변수 값을 읽어 다시 시작됩니다.\ndocker-compose up -d 설정 적용 원리 # USER와 PASS 환경 변수를 추가하고 컨테이너를 실행하면, linuxserver/transmission 이미지의 시작 스크립트는 내부적으로 Transmission의 핵심 설정 파일인 settings.json의 다음 항목들을 자동으로 변경합니다.\nrpc-authentication-required: true (인증 사용 활성화)\nrpc-username: USER 환경 변수에 입력한 값\nrpc-password: PASS 환경 변수에 입력한 값 (암호화되어 저장됨)\n이처럼 복잡한 내부 동작을 신경 쓸 필요 없이, 사용자는 단지 환경 변수 두 줄을 추가하는 것만으로 인증 기능을 활성화할 수 있습니다.\n이제 Transmission 웹 인터페이스에 접속하면 사용자 아이디와 비밀번호를 묻는 로그인 창이 나타날 것입니다. 설정하신 ID와 Password를 입력해야만 정상적으로 접근할 수 있습니다. 이 간단한 조치만으로도 여러분의 서버는 한층 더 안전해졌습니다.\n참조\nLinuxServer.io Transmission 이미지 공식 문서: https://docs.linuxserver.io/images/docker-transmission ","date":"21 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/transmission-auth-for-security/","section":"","summary":"","title":"내 Transmission 서버를 안전하게, ID/Password 인증 활성화하기","type":"posts"},{"content":"클라우드 기술은 이제 IT 전문가에게 선택이 아닌 필수가 되었습니다. 하지만 개인 프로젝트나 신기술 학습을 위해 클라우드 서비스를 이용하고자 할 때, 예상치 못한 비용 발생에 대한 부담이 따르는 것이 사실입니다.\n오늘은 이러한 비용 부담 없이 클라우드 환경을 마음껏 활용할 수 있는 오라클 클라우드(OCI)의 무료 티어(Free Tier) 계정을 생성하는 방법을 단계별로 상세히 안내해 드리고자 합니다. 이 가이드는 낯선 용어와 절차에서 발생할 수 있는 시행착오를 줄이고, 여러분이 온전히 기술을 탐색하는 데 집중할 수 있도록 돕기 위해 작성되었습니다.\n오라클 클라우드 무료 티어의 장점 # 많은 클라우드 서비스 중 OCI 무료 티어를 추천하는 이유는 \u0026lsquo;Always Free\u0026rsquo;라는 이름으로 제공되는 자원의 범위가 상당히 실용적이기 때문입니다.\n핵심 컴퓨팅 자원: 기본적인 가상 서버(VM 인스턴스) 2개를 평생 무료로 사용할 수 있습니다.\n넉넉한 스토리지: 상당한 용량의 블록 스토리지, 오브젝트 스토리지가 무료로 제공됩니다.\n네트워킹 서비스: 로드 밸런서와 같은 필수 네트워킹 기능까지 무료 범위에 포함됩니다.\n이 정도의 자원이면 개인 블로그 운영, 소규모 웹 애플리케이션의 개발과 배포, 데이터베이스 연동 테스트 및 리눅스 서버 학습용으로 활용하기에 충분합니다. 비용 걱정 없이 아이디어를 실험할 수 있는 강력한 개인 디지털 실험실을 마련하는 것과 같습니다.\n오라클 클라우드 무료 티어 계정 생성 절차 # 이제 본격적으로 계정 생성을 시작하겠습니다. 아래 단계를 순서대로 따라오시면 막힘없이 완료하실 수 있습니다.\n1단계: 무료 티어 페이지 접속 및 기본 정보 입력 # 먼저, 오라클 클라우드 무료 티어 공식 페이지로 이동합니다.\n접속 링크: https://www.oracle.com/cloud/free/ 페이지 중앙의 [Start for Free] 버튼을 클릭합니다.\n계정 기본 정보를 입력하는 양식이 나타나면, 아래 내용을 영문으로 정확히 입력합니다.\nCountry/Territory: South Korea\nFirst Name (이름): 예: Gildong\nLast Name (성): 예: Hong\nEmail: 계정으로 사용할 유효한 이메일 주소\n입력 완료 후 [Verify my email] 버튼을 클릭합니다. 잠시 후 입력한 이메일 주소로 인증 메일이 발송됩니다.\n2단계: 이메일 인증 # 메일함을 확인하여 오라클에서 발송한 인증 메일을 엽니다. (스팸 메일함도 확인해 보시기 바랍니다.)\n메일 본문에 있는 [Verify email] 버튼을 클릭하여 인증을 완료합니다. 이 버튼을 클릭하면 계정의 상세 정보를 설정하는 다음 페이지로 이동합니다.\n💡 팁: 인증 오류 발생 시 대처법\n간혹 여러 기기에서 인증을 시도하거나 짧은 시간 내에 반복적으로 시도할 경우, \u0026ldquo;제한이 발생했다(Activity limited)\u0026ldquo;는 메시지가 나타날 수 있습니다. 이는 보안을 위한 일시적인 조치이므로 당황하지 마시고, 5~10분 정도 기다린 후 다시 시도하면 대부분 정상적으로 진행됩니다.\n3단계: 계정 상세 정보 설정 # 이메일 인증을 통과하면, 계정의 핵심 정보를 설정하는 단계입니다.\nPassword (비밀번호): 오라클 클라우드에 로그인할 때 사용할 비밀번호를 설정합니다. 보안을 위해 대소문자, 숫자, 특수문자를 조합하여 강력한 비밀번호를 만드는 것을 권장합니다.\nCloud Account Name (클라우드 계정 이름): 클라우드 환경 전체를 식별하는 고유한 이름인 테넌시(Tenancy) 이름을 설정합니다. 시스템이 제안하는 이름을 그대로 사용하거나, 기억하기 쉬운 이름으로 직접 변경할 수 있습니다. 이 이름은 로그인 시 필요하므로 잘 기록해 두어야 합니다.\nHome Region (홈 리전): 클라우드 자원이 물리적으로 위치할 데이터센터 지역을 선택합니다.\n홈 리전은 계정 생성 후 절대 변경할 수 없으므로 신중하게 선택해야 합니다. 국내 사용자의 경우, 네트워크 지연 시간(Latency)을 최소화하기 위해 아래 두 리전 중 하나를 선택하는 것이 가장 좋습니다.\nSouth Korea Central (Seoul) South Korea North (Chuncheon) 4단계: 주소 및 결제 수단 등록 # Address (주소 정보): 주소 정보를 영문으로 입력합니다. 이 단계에서 입력하는 주소, 우편번호는 다음에 등록할 신용/체크카드에 청구지로 등록된 정보와 정확히 일치해야 합니다. 정보가 일치하지 않으면 카드 인증 단계에서 오류가 발생할 수 있습니다. 네이버 영문주소 변환기 등을 활용하여 정확한 정보를 입력하십시오. Payment Verification (결제 수단 등록): 신원 확인 및 유료 서비스 전환을 대비하여 결제 수단을 등록합니다.\n[Add payment verification method] 버튼을 클릭하고, 해외 결제가 가능한 카드(VISA, Mastercard 등) 정보를 입력합니다.\n무료 티어는 사용자가 명시적으로 유료로 업그레이드하지 않는 한 절대 비용이 청구되지 않습니다. 카드 등록은 사용자 인증을 위한 절차이며, 유효성 확인을 위해 소액(약 1달러)이 결제되었다가 즉시 취소될 수 있습니다.\n5단계: 계정 생성 완료 및 최초 로그인 # 이용 약관 동의 체크박스에 표시한 후, [Start my free trial] 버튼을 클릭합니다.\n\u0026ldquo;Your account is being created\u0026rdquo; 메시지와 함께 잠시 기다리면 계정 생성이 완료됩니다.\n이제 오라클 클라우드 로그인 페이지로 이동하여 첫 로그인을 진행합니다.\n로그인 페이지: https://www.oracle.com/kr/cloud/sign-in.html 로그인 창에 3단계에서 설정했던 Cloud Account Name (테넌시 이름) 을 입력하고 [Next]를 클릭합니다.\n다음 화면에서 가입 시 사용했던 이메일 주소와 비밀번호를 입력하여 최종적으로 로그인합니다.\n로그인에 성공하면 오라클 클라우드의 관리 콘솔(대시보드)이 나타납니다. 이곳이 앞으로 여러분의 모든 클라우드 자원을 관리하고 생성할 작업 공간입니다.\n마무리하며 # 이것으로 오라클 클라우드 무료 티어 계정 생성을 위한 모든 절차가 완료되었습니다. 처음에는 다소 복잡하게 느껴질 수 있지만, 이 가이드를 통해 성공적으로 여러분만의 클라우드 환경을 마련하셨기를 바랍니다.\n이제 여러분은 비용 걱정 없이 다양한 클라우드 서비스를 실험하고 경험을 쌓을 수 있는 멋진 놀이터를 얻으셨습니다. 이 무료 계정을 발판 삼아 클라우드의 무한한 가능성을 탐험하며 여러분의 아이디어를 마음껏 현실로 만들어 보시길 진심으로 응원합니다.\n참조\nOracle Cloud Free Tier 공식 페이지: https://www.oracle.com/cloud/free/ Oracle Cloud 로그인 페이지: https://www.oracle.com/kr/cloud/sign-in.html ","date":"19 July 2025","externalUrl":null,"permalink":"/posts/hosting/oracle/oracle-cloud-freetier-account/","section":"","summary":"","title":"오라클 클라우드(OCI) 무료 티어(Free Tier) 계정 생성 완벽 가이드","type":"posts"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/traefik/","section":"Tags","summary":"","title":"Traefik","type":"tags"},{"content":"서버를 직접 운영하다 보면 애플리케이션 개발 외에도 신경 쓸 일이 참 많습니다. 특히 서비스가 추가될 때마다 Nginx 같은 리버스 프록시 설정 파일을 수동으로 고치고, 잊을 만하면 다가오는 SSL 인증서를 갱신하는 작업은 꽤 번거로운 일입니다. 이런 번거로움을 멋지게 해결해 줄 현대적인 도구가 있습니다. 바로 클라우드 네이티브 엣지 라우터, Traefik(트래픽) 입니다. 이 글에서는 Docker 환경에서 Traefik을 설치하고, Let\u0026rsquo;s Encrypt를 연동하여 수동 작업 없이도 HTTPS를 완전 자동화하는 과정을 처음부터 끝까지 안내해 드리겠습니다. 더 이상 설정 파일과 씨름하지 않고, 오직 개발에만 집중할 수 있는 환경을 함께 만들어 보겠습니다.\nTraefik, 무엇이 다른가요? # Traefik은 마이크로서비스 환경을 위해 태어난 리버스 프록시 및 로드 밸런서입니다. 기존 Nginx나 HAProxy와 가장 큰 차이점은 설정 파일을 직접 수정하고 재시작할 필요가 없다는 점입니다.\n자동 서비스 탐색 (Automatic Service Discovery): Docker나 Kubernetes 같은 환경에서 컨테이너가 새로 생기거나 사라지는 것을 Traefik이 스스로 감지하여 라우팅 규칙을 실시간으로 업데이트합니다.\n동적 설정 (Dynamic Configuration): 각 서비스(컨테이너)에 붙어있는 **레이블(Label)**만으로 라우팅 규칙, 사용할 도메인, 미들웨어 적용까지 모든 것을 정의할 수 있습니다.\nTLS 인증서 완전 자동화: Let\u0026rsquo;s Encrypt와 완벽하게 연동되어, 필요한 도메인의 HTTPS 인증서를 자동으로 발급받고, 만료일이 다가오면 스스로 갱신까지 해줍니다.\n구분 Traefik Nginx / HAProxy (전통적 방식) 설정 방식 동적 (Dynamic): API, 컨테이너 레이블 기반 정적 (Static): 설정 파일 (.conf) 기반 변경 적용 자동, 실시간 (재시작 불필요) 수동 수정 후 재시작/리로드 필요 주요 환경 마이크로서비스, 컨테이너 환경에 최적화 범용적이나, 정적 인프라 환경에 더 적합 TLS 관리 완전 자동화 (Let\u0026rsquo;s Encrypt 연동) 수동 설정 및 스크립트를 통한 갱신 관리 준비사항 확인하기 # 공인 도메인: localhost가 아닌, 실제 소유하고 있는 도메인(예: mydomain.com)이 필요합니다.\nDNS 설정: 위 도메인의 서브도메인(예: whoami.mydomain.com)이 Traefik을 실행하는 서버의 공인 IP 주소를 가리키도록 DNS 레코드(A 또는 CNAME)를 설정해야 합니다.\n방화벽: 서버의 80번(HTTP) 포트와 443번(HTTPS) 포트가 외부에서 접근 가능하도록 방화벽이 열려 있어야 합니다.\nUbuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins DuckDNS로 나만의 무료 도메인 만들기 6 July 2025\u0026middot;464 words\u0026middot;3 mins Traefik 설치하기 # 먼저 Docker 환경에서 Traefik을 설치하고, 간단한 웹 서비스를 HTTP로 연결하는 기본 과정을 진행하겠습니다.\n디렉토리 및 파일 생성 # Traefik 관련 파일들을 관리할 작업 디렉토리와 설정 파일들을 미리 생성합니다.\n# 작업 디렉토리 생성 및 이동 mkdir traefik cd traefik # Traefik의 기본 설정을 담을 파일 생성 touch traefik.yml # Docker Compose 실행을 위한 파일 생성 touch docker-compose.yml Traefik 정적 설정 작성 (traefik.yml) # traefik.yml 파일은 Traefik이 시작될 때 단 한 번만 읽는 정적 설정 파일입니다. 여기에 Traefik의 기본 동작 방식을 정의합니다.\n# traefik.yml # API 및 대시보드 활성화 # 개발 환경에서는 insecure: true로 간단히 열 수 있습니다. api: insecure: true dashboard: true # Traefik이 외부 요청을 받아들일 통로(엔트리포인트)를 정의합니다. entryPoints: web: address: \u0026#34;:80\u0026#34; # HTTP 요청을 위한 80번 포트 websecure: address: \u0026#34;:443\u0026#34; # HTTPS 요청을 위한 443번 포트 # 어떤 환경의 설정을 동적으로 읽어올지 정의합니다. providers: docker: exposedByDefault: false # ※보안상 매우 중요한 설정입니다. network: traefik-proxy # Traefik이 연결될 Docker 네트워크를 지정합니다. 💡 exposedByDefault: false\n이 설정을 false로 두면, traefik.enable=true 라는 레이블이 명시적으로 붙은 컨테이너만 Traefik이 관리하게 됩니다. 실수로 원치 않는 서비스가 외부에 노출되는 것을 막아주는 중요한 보안 설정입니다.\nDocker Compose 파일 작성 (docker-compose.yml) # 이제 Traefik 컨테이너와, 라우팅을 테스트할 whoami라는 간단한 웹 서비스 컨테이너를 정의합니다.\n# docker-compose.yml version: \u0026#39;3.8\u0026#39; services: # 1. Traefik 서비스 정의 traefik: image: \u0026#34;traefik:v3.0\u0026#34; container_name: \u0026#34;traefik\u0026#34; command: - \u0026#34;--configFile=/etc/traefik/traefik.yml\u0026#34; # 시작 시 읽을 정적 설정 파일 지정 ports: - \u0026#34;80:80\u0026#34; # HTTP - \u0026#34;443:443\u0026#34; # HTTPS - \u0026#34;8080:8080\u0026#34; # Traefik 대시보드 접속 포트 volumes: # Docker 소켓을 읽기 전용으로 마운트하여 컨테이너의 생성/삭제를 감지 (핵심!) - \u0026#34;/var/run/docker.sock:/var/run/docker.sock:ro\u0026#34; # 위에서 작성한 설정 파일을 컨테이너 내부로 마운트 - \u0026#34;./traefik.yml:/etc/traefik/traefik.yml:ro\u0026#34; networks: - traefik-proxy restart: unless-stopped # 2. 라우팅 테스트를 위한 whoami 서비스 whoami: image: \u0026#34;traefik/whoami\u0026#34; container_name: \u0026#34;whoami\u0026#34; networks: - traefik-proxy # --- Traefik 동적 설정 (레이블) --- labels: # 이 컨테이너를 Traefik이 관리하도록 활성화 - \u0026#34;traefik.enable=true\u0026#34; # \u0026#39;whoami\u0026#39; 라우터 정의 및 규칙 설정: \u0026#39;whoami.localhost\u0026#39; 호스트로 오는 요청을 처리 - \u0026#34;traefik.http.routers.whoami.rule=Host(`whoami.localhost`)\u0026#34; # 이 라우터가 사용할 엔트리포인트(통로)는 \u0026#39;web\u0026#39;(80 포트)으로 지정 - \u0026#34;traefik.http.routers.whoami.entrypoints=web\u0026#34; # 이 서비스가 실제로 응답하는 포트는 80번이라고 Traefik에 알려줌 - \u0026#34;traefik.http.services.whoami.loadbalancer.server.port=80\u0026#34; # Traefik과 서비스들이 함께 사용할 외부 네트워크 정의 networks: traefik-proxy: external: true 실행 및 확인 # 모든 파일 작성이 끝났습니다. 이제 네트워크를 생성하고 컨테이너를 실행합니다.\n# 1. Docker Compose에서 사용할 공용 네트워크 생성 docker network create traefik-proxy # 2. Docker Compose로 Traefik과 whoami 서비스 실행 (-d는 백그라운드 실행) docker-compose up -d 최종 확인 은 아래의 방법으로 할 수 있습니다.\n대시보드 접속: 웹 브라우저에서 http://localhost:8080 으로 접속하여 Traefik 대시보드가 보이는지 확인합니다. Routers 메뉴에 whoami가 등록되어 있다면 성공입니다.\n라우팅 테스트: 터미널에서 아래 명령을 실행합니다.\n# \u0026#39;Host\u0026#39; 헤더를 지정하여 Traefik이 올바른 라우팅 규칙을 찾도록 합니다. curl -H Host:whoami.localhost http://localhost 결과로 whoami 컨테이너의 정보(Hostname, IP 주소 등)가 출력되면 기본 설정이 완벽하게 끝난 것입니다.\nLet\u0026rsquo;s Encrypt로 HTTPS 자동화 # 이제 기본 설정이 완료되었으니, Traefik의 진정한 힘을 발휘할 시간입니다. Let\u0026rsquo;s Encrypt를 연동하여 whoami 서비스에 완전 자동화된 HTTPS를 적용해 보겠습니다.\ntraefik.yml 수정: 인증서 해석기 추가 # traefik.yml 파일에 Let\u0026rsquo;s Encrypt 설정을 담당할 인증서 해석기(Certificates Resolver) 를 추가하고, HTTP를 HTTPS로 자동 리디렉션하는 설정을 추가합니다.\n# traefik.yml api: insecure: true dashboard: true entryPoints: web: address: \u0026#34;:80\u0026#34; # (추가) 80포트로 온 모든 HTTP 요청을 websecure(HTTPS)로 리디렉션 http: redirections: entryPoint: to: websecure scheme: https websecure: address: \u0026#34;:443\u0026#34; providers: docker: exposedByDefault: false network: traefik-proxy # (추가) Let\u0026#39;s Encrypt를 위한 인증서 해석기 정의 certificatesResolvers: letsencrypt: # 이 해석기의 이름은 \u0026#39;letsencrypt\u0026#39;로 지정합니다. acme: # ※반드시 실제 사용하는 이메일 주소를 입력하세요. 인증서 만료 알림 등에 사용됩니다. email: \u0026#34;your-email@example.com\u0026#34; # 발급받은 인증서를 저장할 파일 경로 storage: \u0026#34;/etc/traefik/acme.json\u0026#34; # 도메인 소유권 확인 방식 (HTTP-01 챌린지) httpChallenge: entryPoint: web docker-compose.yml 수정: HTTPS 라우팅 규칙 적용 # docker-compose.yml 파일을 수정하여 인증서 저장 파일을 볼륨으로 연결하고, whoami 서비스의 레이블을 HTTPS에 맞게 변경합니다.\n# docker-compose.yml version: \u0026#39;3.8\u0026#39; services: traefik: image: \u0026#34;traefik:v3.0\u0026#34; container_name: \u0026#34;traefik\u0026#34; command: - \u0026#34;--configFile=/etc/traefik/traefik.yml\u0026#34; ports: - \u0026#34;80:80\u0026#34; - \u0026#34;443:443\u0026#34; - \u0026#34;8080:8080\u0026#34; volumes: - \u0026#34;/var/run/docker.sock:/var/run/docker.sock:ro\u0026#34; - \u0026#34;./traefik.yml:/etc/traefik/traefik.yml:ro\u0026#34; # (추가) 인증서 파일(acme.json)을 호스트에 영속적으로 저장하기 위한 볼륨 - \u0026#34;./acme.json:/etc/traefik/acme.json\u0026#34; networks: - traefik-proxy restart: unless-stopped whoami: image: \u0026#34;traefik/whoami\u0026#34; container_name: \u0026#34;whoami\u0026#34; networks: - traefik-proxy labels: - \u0026#34;traefik.enable=true\u0026#34; # (수정) 라우터가 사용할 엔트리포인트를 \u0026#39;websecure\u0026#39;(443 포트)로 변경 - \u0026#34;traefik.http.routers.whoami.entrypoints=websecure\u0026#34; # (수정) Host 규칙을 실제 소유한 도메인으로 변경 - \u0026#34;traefik.http.routers.whoami.rule=Host(`whoami.your-domain.com`)\u0026#34; # (추가) 이 라우터에 TLS를 활성화 - \u0026#34;traefik.http.routers.whoami.tls=true\u0026#34; # (추가) TLS 인증서 발급을 위해 \u0026#39;letsencrypt\u0026#39; 해석기를 사용하도록 지정 - \u0026#34;traefik.http.routers.whoami.tls.certresolver=letsencrypt\u0026#34; - \u0026#34;traefik.http.services.whoami.loadbalancer.server.port=80\u0026#34; networks: traefik-proxy: external: true 실행 및 최종 확인 # 마지막 단계입니다. 인증서 파일을 생성하고 권한을 설정한 뒤, 서비스를 다시 시작하겠습니다.\n인증서 파일 생성 및 권한 설정:\n이 과정은 매우 중요합니다. Traefik 컨테이너가 인증서 파일에 쓸 수 있는 권한이 없으면 인증서 발급에 실패합니다. # 비어있는 acme.json 파일 생성 touch acme.json # 파일 소유자만 읽고 쓸 수 있도록 권한 설정 (600) chmod 600 acme.json Docker Compose 재시작:\n변경된 설정을 적용하기 위해 컨테이너를 다시 시작합니다.\ndocker-compose up -d 최종 확인:\n웹 브라우저에서 https://whoami.your-domain.com 으로 접속합니다.\n아래 이미지처럼 주소창에 자물쇠 아이콘이 나타나고, 클릭했을 때 \u0026ldquo;Let\u0026rsquo;s Encrypt\u0026quot;에서 발급한 유효한 인증서라는 정보가 보이면 성공입니다.\n이제 http://whoami.your-domain.com (HTTP)으로 접속해도 자동으로 https:// (HTTPS) 주소로 리디렉션되는 것을 확인할 수 있습니다.\n마치며 # 이것으로 Docker와 Traefik, Let\u0026rsquo;s Encrypt를 이용한 완전 자동화된 리버스 프록시 환경 구축이 모두 끝났습니다. 이제 여러분은 새로운 서비스를 추가할 때 docker-compose.yml 파일에 레이블 몇 줄만 추가하면, 라우팅부터 HTTPS 적용까지 모든 것이 자동으로 처리되는 편리함을 누릴 수 있습니다.\n더 이상 번거로운 인프라 설정에 시간을 낭비하지 마십시오. 이 가이드가 여러분이 더 중요한 가치인 개발에 집중하는 데 작은 보탬이 되기를 바랍니다.\n참조\nTraefik 공식 웹사이트: https://www.traefik.io/ Traefik GitHub 저장소: https://github.com/traefik/traefik ","date":"17 July 2025","externalUrl":null,"permalink":"/posts/hosting/traefik/traefik-setup/","section":"","summary":"","title":"Traefik: Docker와 Let's Encrypt로 HTTPS 자동화 완전 정복","type":"posts"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"Blowfish","type":"tags"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/categories/hugo-%EB%B8%94%EB%A1%9C%EA%B7%B8/","section":"Categories","summary":"","title":"Hugo 블로그","type":"categories"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/tags/obsidian/","section":"Tags","summary":"","title":"Obsidian","type":"tags"},{"content":"","date":"17 July 2025","externalUrl":null,"permalink":"/categories/tools/","section":"Categories","summary":"","title":"Tools","type":"categories"},{"content":"블로그를 운영하다 보면 글의 내용 외에도 반복적으로 처리해야 하는 작업들에 시간을 뺏기곤 합니다. 특히 Hugo와 같은 정적 사이트 생성기로 블로그를 관리할 때, 정해진 파일 이름과 형식에 맞춰 Frontmatter를 작성하는 일은 번거롭게 느껴질 수 있습니다.\n오늘은 Obsidian의 강력한 플러그인 \u0026lsquo;Templater\u0026rsquo;를 활용하여, Hugo 블로그 포스트 생성 과정을 자동화하는 실용적인 방법을 소개해 드리고자 합니다. 이 가이드를 통해 파일 이름을 \u0026lsquo;index.md\u0026rsquo;로 자동 변경하고, 글 작성 시간을 Frontmatter에 정확히 기록하는 과정을 설정하여, 여러분이 오직 글쓰기 자체에만 집중할 수 있도록 돕겠습니다.\nTemplater 플러그인 설치 및 활성화 # 가장 먼저 자동화의 핵심 도구인 Templater 플러그인을 설치하고 활성화해야 합니다.\nObsidian 화면 좌측 하단의 설정(톱니바퀴 아이콘) 메뉴를 클릭하십시오.\n커뮤니티 플러그인 탭으로 이동한 뒤, 탐색 버튼을 누릅니다.\n검색창에 Templater를 입력하여 플러그인을 찾고 설치합니다.\n설치가 완료되면, 활성화 토글 버튼을 눌러 플러그인을 즉시 사용할 수 있도록 설정하는 것을 잊지 마십시오.\n자동화를 위한 템플릿 파일 만들기 # 이제 반복적인 작업을 대신 처리해 줄 템플릿 노트를 만들 차례입니다.\n템플릿 파일들을 보관할 폴더를 하나 생성하는 것을 권장합니다. (예: templates) 이렇게 하면 나중에 템플릿을 관리하기가 한결 수월해집니다.\n새로 만든 폴더 안에 \u0026lsquo;기본 노트 템플릿\u0026rsquo;과 같은 이름으로 새 노트를 하나 만드십시오.\n생성한 노트에 아래의 코드를 그대로 복사하여 붙여넣습니다. 이 코드가 바로 자동화의 핵심입니다.\n--- title: description: preview: feature.webp draft: false tags: keywords: categories: date: \u0026lt;% tp.date.now(\u0026#34;YYYY-MM-DDTHH:mm:ss.SSS\u0026#34;) %\u0026gt;Z --- \u0026lt;%* await tp.file.rename(\u0026#34;index\u0026#34;); %\u0026gt; ※ 템플릿 코드 핵심 설명:\ndate: \u0026lt;% tp.date.now(\u0026quot;YYYY-MM-DDTHH:mm:ss.SSS\u0026quot;) %\u0026gt;Z: 이 부분은 템플릿이 실행되는 바로 그 순간의 날짜와 시간을 Hugo에서 사용하는 표준 형식으로 자동으로 삽입합니다. YYYY-MM-DD는 년-월-일, HH:mm:ss.SSS는 시-분-초(밀리초까지)를 의미합니다.\n\u0026lt;%* await tp.file.rename(\u0026quot;index\u0026quot;); %\u0026gt;: 이 스크립트는 노트가 생성된 직후, 파일의 이름을 \u0026lsquo;index\u0026rsquo;로 자동으로 변경합니다. Hugo의 콘텐츠 구성 방식에 따라 index.md 파일이 필요한 경우 매우 유용합니다.\n템플릿으로 새 글 손쉽게 작성하기 # 모든 준비가 끝났습니다. 이제 직접 템플릿을 사용하여 새 글을 작성해 보겠습니다.\nHugo 포스트를 저장할 폴더에서 마우스 오른쪽 버튼을 클릭하십시오.\n나타나는 메뉴에서 Templater: Create new note from template을 선택합니다.\n앞서 만들었던 \u0026lsquo;기본 노트 템플릿\u0026rsquo; 파일을 선택합니다.\n위 이미지처럼, 파일 이름은 index.md로 변경되고 Frontmatter의 date 필드는 현재 시간으로 완벽하게 채워진 새 노트가 생성된 것을 확인할 수 있습니다. 이제 여러분은 title과 description 등 필요한 내용만 채우고 글쓰기를 시작하면 됩니다.\n이처럼 간단한 설정만으로 블로그 운영의 번거로운 과정 하나를 줄일 수 있습니다.\n참조\nObsidian 공식 사이트: https://obsidian.md/ Templater 플러그인 공식 문서: https://silentvoid.github.io/Templater/ ","date":"17 July 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/plugin-templater-for-hugo-blowfish/","section":"","summary":"","title":"반복은 그만, Obsidian 템플릿으로 Hugo 블로그 글쓰기 자동화","type":"posts"},{"content":"","date":"11 July 2025","externalUrl":null,"permalink":"/tags/ollama/","section":"Tags","summary":"","title":"Ollama","type":"tags"},{"content":"Obsidian은 지식 관리에 혁신을 가져다주었고, 여기에 Ollama를 더하면서 글쓰기 방식은 완전히 새로운 차원으로 발전했습니다. 이 글을 통해 어떻게 효율적으로 글을 작성하는지 알아보겠습니다.\nObsidian과 LLM, 그리고 Ollama 소개 # 먼저 각 도구에 대해 간단히 알아보겠습니다.\nObsidian: 마크다운 기반의 노트 앱으로, 파일들이 로컬에 저장되어 개인 정보 보호에 유리합니다. 노트들을 서로 연결하여 자신만의 지식 네트워크를 구축할 수 있는 강력한 기능을 제공합니다.\nLLM (Large Language Model): 거대 언어 모델의 약자로, 방대한 텍스트 데이터를 학습하여 인간과 유사한 텍스트를 생성하고 이해하는 인공지능 모델입니다. ChatGPT가 대표적인 예입니다.\nOllama: 개인 컴퓨터에 LLM을 설치하고 실행할 수 있게 해주는 도구입니다. Ollama를 사용하면 인터넷 연결 없이도, 비용 걱정 없이 다양한 LLM을 활용할 수 있습니다.\n이 세 가지를 조합하면, Obsidian이라는 강력한 문서 관리 도구 안에서 나만의 데이터를 활용하여 LLM으로 글을 생성하고 편집하는, 완전히 독립적이고 효율적인 글쓰기 환경을 구축할 수 있습니다.\n사용 전 준비사항 # 본격적인 설정에 앞서 몇 가지 준비가 필요합니다.\nObsidian 설치: 사용 중인 운영체제에 맞는 Obsidian을 공식 홈페이지에서 내려받아 설치합니다.\nOllama 설치: Ollama 공식 홈페이지에서 자신의 운영체제에 맞는 버전을 내려받아 설치합니다.\n내 손안의 AI 비서, Ollama로 나만의 ChatGPT 만들기 11 July 2025\u0026middot;579 words\u0026middot;3 mins Obsidian에서 AI 글쓰기 비서 만들기 # 이제 Obsidian에서 ChatGPT MD 플러그인을 설치하고 Ollama와 연동하는 방법을 단계별로 알아보겠습니다.\nChatGPT MD 플러그인 설치 # Obsidian을 실행하고 왼쪽 하단의 설정(Settings) 아이콘을 클릭합니다.\n커뮤니티 플러그인(Community plugins) 탭으로 이동하여 탐색(Browse) 버튼을 클릭합니다.\n검색창에 ChatGPT MD를 입력하여 플러그인을 찾은 뒤 설치(Install) 버튼을 누릅니다.\n설치가 완료되면 활성화(Enable) 버튼을 눌러 플러그인을 활성화합니다.\n플러그인 설정 및 Ollama 연동 # 플러그인이 활성화되면 ChatGPT MD 설정 탭이 나타납니다.\nDefault Chat Frontmatter에 선언된 모델을 ollama@\u0026lt;설치한 모델\u0026gt;로 변경해 줍니다.\n--- system_commands: [\u0026#39;I am a helpful assistant.\u0026#39;] frequency_penalty: 0 max_tokens: 300 model: ollama@exaone3.5:2.4b presence_penalty: 0 stream: true temperature: 1 --- 나머지 설정은 기본값을 유지해도 무방합니다. 이제 Obsidian에서 Ollama를 사용할 준비가 모두 끝났습니다. 로컬 PC가 아니거나, 포트를 다르게 설정한 경우, ServiceUrls의 Ollama API Url값의 수정이 필요합니다. 또한, 이 기능을 사용하려면 백그라운드에서 Ollama가 실행 중이어야 합니다. LLM으로 글쓰기 # 이제 실제로 LLM을 활용하여 글을 작성해 보겠습니다.\nObsidian에서 새로운 노트를 생성하거나 기존 노트를 엽니다.\nCtrl + P (Windows) 또는 Cmd + P (macOS)를 눌러 명령어 팔레트를 엽니다.\nChatGPT MD: Chat 명령어를 검색하여 실행합니다.\n노트 안에 채팅 형식의 프롬프트 창이 나타납니다. user: 부분에 원하는 요청 사항을 입력합니다.\n예: user: 옵시디언과 올라마를 연동하는 방법에 대해 블로그 글의 초안을 작성해줘. Enter 키를 누르면 assistant: 섹션에 LLM이 생성한 답변이 나타납니다.\n생성된 내용은 언제든지 수정하거나 추가 요청을 통해 발전시킬 수 있습니다. 예를 들어, 생성된 초안이 마음에 들지 않으면 user: 좀 더 전문적인 톤으로 다시 작성해줘. 와 같이 추가적인 지시를 내릴 수 있습니다.\n마무리 # 지금까지 Obsidian과 Ollama를 연동하여 나만의 AI 글쓰기 환경을 구축하는 방법을 알아보았습니다. 이 조합의 가장 큰 장점은 모든 데이터가 내 컴퓨터에만 저장된다는 점, 그리고 인터넷 연결이나 외부 서비스 비용 없이 강력한 AI 모델을 자유롭게 활용할 수 있다는 점입니다.\n물론, 로컬 LLM의 성능은 컴퓨터 사양에 따라 달라질 수 있습니다. 하지만 간단한 아이디어 구상부터 초안 작성, 교정 작업까지 글쓰기의 여러 단계에서 충분히 훌륭한 보조 역할을 해낼 수 있습니다. 이 가이드가 여러분의 글쓰기 여정에 실질적인 도움이 되기를 바랍니다. 직접 사용해보시면서 자신만의 활용법을 찾아가시는 즐거움을 누리시길 응원합니다.\n참조\nObsidian 공식 홈페이지 Ollama 공식 홈페이지 ChatGPT MD 플러그인 GitHub 저장소 ","date":"11 July 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/obsidian-with-ollama/","section":"","summary":"","title":"내 손안의 AI 비서: Obsidian과 Ollama로 글쓰기 도움 받기","type":"posts"},{"content":"AI가 우리 삶에 깊숙이 자리 잡은 지금, 나만의 AI를 직접 만들어보고 싶다는 생각, 한 번쯤 해보셨을 겁니다. 하지만 복잡한 과정과 어려운 기술 용어에 지레 겁먹고 포기하는 경우가 많습니다. 10년 넘게 IT 현장에서 기술 문서를 작성해온 경험을 바탕으로, 누구나 쉽게 따라 할 수 있는 \u0026lsquo;Ollama로 나만의 ChatGPT 만들기\u0026rsquo; 방법을 안내해 드리고자 합니다.\nOllama가 무엇일까요? # Ollama는 간단히 말해, 여러분의 개인 컴퓨터에서 강력한 대규모 언어 모델(LLM)을 손쉽게 실행할 수 있도록 도와주는 도구입니다. 인터넷 연결 없이도, 외부 서버를 거치지 않고도 AI 모델을 사용할 수 있어 보안이 중요한 데이터를 다루거나 오프라인 환경에서 AI를 사용하고 싶을 때 매우 유용합니다. 마치 내 컴퓨터에 직접 ChatGPT를 설치하는 것과 같다고 생각하시면 이해하기 쉽습니다.\n다양한 오픈소스 LLM을 지원하기 때문에, 사용자는 필요에 따라 원하는 모델을 선택하고 교체하며 사용할 수 있는 높은 자유도를 자랑합니다.\n왜 Docker Compose를 사용해야 할까요? # Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 컨테이너 기술입니다. 특히 Docker Compose를 사용하면, Ollama와 사용자 친화적인 웹 인터페이스(WebUI)처럼 여러 서비스로 구성된 애플리케이션을 하나의 파일로 간단하게 정의하고 실행할 수 있습니다.\n간편한 설치: 복잡한 설치 과정 없이, 명령어 한 줄로 필요한 모든 것을 한 번에 설치하고 실행할 수 있습니다. 독립된 환경: 내 컴퓨터의 다른 프로그램과 충돌 없이 독립된 환경에서 Ollama를 운영할 수 있어 안정적입니다. 쉬운 관리: 업데이트나 삭제가 매우 간편하여 유지보수가 용이합니다. Ollama 설치하기 # 이제 본격적으로 나만의 AI를 만들어 보겠습니다. 차근차근 따라오시면 결코 어렵지 않습니다.\nDocker와 Docker Compose 설치하기 # Ollama를 Docker Compose로 설치하기 위해서는 당연히 Docker와 Docker Compose가 먼저 설치되어 있어야 합니다.\nUbuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins Mac에 Docker 설치: 개발 환경을 컨테이너로 관리하는 첫걸음 11 July 2025\u0026middot;219 words\u0026middot;2 mins docker-compose.yml 파일 작성하기 # 설치가 완료되었다면, 이제 Ollama와 웹 인터페이스를 함께 실행하기 위한 설정 파일을 작성할 차례입니다. 원하는 위치에 새로운 폴더를 하나 만드신 후, 그 안에 docker-compose.yml 이라는 이름으로 파일을 생성하고 아래 내용을 그대로 복사하여 붙여넣으십시오.\nversion: \u0026#39;3.8\u0026#39; services: ollama: image: ollama/ollama container_name: ollama ports: - \u0026#34;11434:11434\u0026#34; volumes: - ./ollama:/root/.ollama restart: unless-stopped open-webui: image: ghcr.io/open-webui/open-webui:main container_name: open-webui ports: - \u0026#34;8080:8080\u0026#34; environment: - \u0026#39;OLLAMA_BASE_URL=http://ollama:11434\u0026#39; depends_on: - ollama restart: unless-stopped volumes: - ./webui:/app/backend/data 위 설정 파일은 Ollama와 Open WebUI라는 웹 인터페이스를 함께 설치합니다. Open WebUI는 ChatGPT와 유사한 화면을 제공하여 우리가 Ollama를 더욱 편리하게 사용할 수 있도록 도와줍니다. Docker Compose 실행하기 # docker-compose.yml 파일을 저장했다면, 터미널을 열고 해당 파일이 있는 폴더로 이동한 뒤, 아래 명령어를 입력하여 실행하십시오.\ndocker compose up -d 이 명령어는 백그라운드에서(-d) 필요한 이미지를 내려받고 컨테이너를 생성 및 실행합니다. 인터넷 속도에 따라 몇 분 정도 소요될 수 있습니다.\n나만의 ChatGPT, 직접 사용해보기 # 설치가 성공적으로 완료되었다면, 이제 나만의 AI와 대화할 시간입니다.\n웹 인터페이스 접속하기 # 웹 브라우저를 열고 주소창에 http://localhost:8080 을 입력하여 접속합니다. Open WebUI 초기 화면이 나타나면, 간단한 가입 절차를 거쳐 로그인하십시오.\n언어 모델 다운로드하기 # 처음 접속하면 사용할 수 있는 AI 모델이 없습니다. 우리가 직접 사용할 모델을 내려받아야 합니다.\nOpen WebUI 화면 우측 상단의 계정 아이콘을 클릭하고, \u0026lsquo;관리자 패널\u0026rsquo; 메뉴로 이동합니다.\n설정 - 모델 - 모델 관리하기 - \u0026lsquo;Ollama.com에서 모델 가져오기(pull)\u0026rsquo; 입력창에 원하는 모델 이름을 입력하고 옆의 다운로드 버튼을 클릭합니다. 처음 시작하는 분들께는 범용적으로 사용하기 좋은 llama3:8b 모델 이나 LG에서 만든 exaone3.5:7.8b 모델을 을 추천합니다.\n다운로드가 시작되며, 모델 크기에 따라 시간이 걸릴 수 있습니다.\n대화 시작하기 # 모델 다운로드가 완료되면, 이제 모든 준비가 끝났습니다. 메인 화면으로 돌아와 하단의 채팅창에 궁금한 것을 질문하거나 원하는 대화를 시작해 보십시오. 여러분의 컴퓨터에서 실행되는 나만의 AI가 즉시 답변을 생성해 줄 것입니다.\n마무리하며 # 지금까지 Docker Compose를 사용하여 Ollama와 Open WebUI를 설치하고, 직접 AI 모델을 내려받아 대화하는 전 과정을 함께했습니다. 생각보다 간단하지 않으셨나요? 이제 여러분은 외부 서비스에 의존하지 않는, 완벽히 독립적인 나만의 AI 비서를 갖게 되었습니다.\n참조\nOllama 공식 페이지: https://ollama.com/ Open WebUI GitHub 저장소: https://github.com/open-webui/open-webui Docker 공식 문서: https://docs.docker.com/ ","date":"11 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/setup-ollama-using-docker/","section":"","summary":"","title":"내 손안의 AI 비서, Ollama로 나만의 ChatGPT 만들기","type":"posts"},{"content":"macOS 환경에 Docker Desktop을 설치하는 방법을 단계별로 알아보겠습니다.\n설치 전 준비사항 # Docker Desktop을 설치하기 전에 사용 중인 Mac이 다음 시스템 요구 사항을 충족하는지 확인해야 합니다.\nmacOS: 최신 버전의 macOS 및 이전 두 버전까지 지원합니다. (예: macOS Sonoma, Ventura, Monterey)\nRAM: 최소 4GB의 RAM이 필요하지만, 원활한 사용을 위해 8GB 이상을 권장합니다.\n칩: Apple Silicon (M1, M2, M3 등) 또는 Intel 프로세서를 지원합니다.\n단계별 설치 방법 # Docker Desktop 다운로드 # Docker 공식 홈페이지 에 접속합니다.\n사용 중인 Mac의 칩 종류에 맞는 \u0026lsquo;Download for Mac\u0026rsquo; 버튼을 클릭합니다.\n설치 파일 실행 # 다운로드한 Docker.dmg 파일을 더블 클릭하여 엽니다.\n창이 나타나면 Docker 아이콘을 Applications 폴더로 드래그 앤 드롭하여 복사합니다.\nDocker Desktop 실행 및 설정 # Applications 폴더에서 Docker를 찾아 실행합니다.\n처음 실행 시 서비스 이용 약관 동의 창이 나타납니다. 내용을 확인하고 \u0026lsquo;Accept\u0026rsquo; 버튼을 클릭합니다.\n설치 과정에서 시스템 암호를 요구할 수 있습니다.\n설치 확인 # 설치가 완료되면 화면 상단 메뉴 막대에 고래 모양의 Docker 아이콘이 나타납니다.\n터미널(Terminal) 앱을 열고 다음 명령어를 입력하여 Docker가 정상적으로 설치되었는지 확인합니다.\ndocker --version Docker 버전 정보가 출력되면 성공적으로 설치된 것입니다. 마무리 # 이제 여러분의 Mac에 Docker가 성공적으로 설치되었습니다. Docker를 사용하여 다양한 애플리케이션을 컨테이너 환경에서 실행하고 관리할 준비가 되었습니다. 다음 단계로 간단한 \u0026lsquo;hello-world\u0026rsquo; 이미지를 실행하여 Docker가 제대로 작동하는지 테스트해 보시는 것을 추천합니다.\n터미널에 아래 명령어를 입력해 보십시오.\ndocker run hello-world 참조\nDocker 공식 문서: Install Docker Desktop on Mac ","date":"11 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/install-docker-on-mac/","section":"","summary":"","title":"Mac에 Docker 설치: 개발 환경을 컨테이너로 관리하는 첫걸음","type":"posts"},{"content":"","date":"10 July 2025","externalUrl":null,"permalink":"/tags/google-analytics/","section":"Tags","summary":"","title":"Google Analytics","type":"tags"},{"content":"오늘은 여러분의 블로그에 방문하는 사람들은 누구이고, 어떤 콘텐츠에 관심을 보이는지 파악할 수 있는 강력한 도구, 구글 애널리틱스(Google Analytics)를 Hugo Blowfish 테마에 적용하는 방법을 안내해 드리고자 합니다.\n구글 애널리틱스, 왜 필요할까요? # 웹사이트를 운영하는 것은 단순히 글을 쓰고 발행하는 것에서 그치지 않습니다. 방문객들이 어떤 경로를 통해 들어오는지, 어떤 페이지를 가장 많이 보는지, 얼마나 오래 머무는지 등을 파악해야 독자들이 진정으로 원하는 콘텐츠를 제공하고 웹사이트를 성장시킬 수 있습니다.\n구글 애널리틱스는 이러한 방문자 데이터를 수집하고 분석할 수 있게 해주는 무료 서비스입니다. 마치 웹사이트의 내비게이션처럼, 방문객의 행동 패턴을 보여주어 우리가 나아갈 방향을 알려줍니다.\n시작 전 준비사항: 구글 애널리틱스 측정 ID 발급받기 # Hugo에 구글 애널리틱스를 적용하기 위해서는 먼저 \u0026lsquo;측정 ID\u0026rsquo;라는 것을 발급받아야 합니다. 이 ID는 우리 웹사이트를 구글 애널리틱스가 식별하기 위한 고유한 값입니다.\n구글 애널리틱스 접속 및 로그인 # 구글 애널리틱스 공식 페이지 에 접속하여 구글 계정으로 로그인합니다.\n계정 및 속성 생성: # 처음 사용하시는 분이라면 \u0026lsquo;측정 시작\u0026rsquo;을 클릭하여 계정을 만듭니다. 계정 이름은 회사나 개인 이름 등 식별하기 쉬운 이름으로 정합니다. 다음으로 \u0026lsquo;속성\u0026rsquo;을 만들어야 합니다. 속성은 우리가 분석하고자 하는 웹사이트나 앱을 의미합니다. 속성 이름에는 웹사이트 이름을 입력하고, 보고 시간대와 통화를 대한민국 기준으로 설정합니다. 비즈니스 정보를 입력합니다. 개인 블로그이니 \u0026ldquo;작음\u0026quot;을 선택합니다. 비즈니스 목표를 선택합니다. 저는 아래 두 항목을 선택하였습니다. 웹 또는 앱 트래픽 파악 사용자 참여 발생 시간 및 유지율 보기 웹\u0026rsquo;을 플랫폼으로 선택하고 웹사이트의 URL을 입력합니다. 데이터 스트림 및 측정 ID 확인: # 속성 생성을 완료하면 \u0026lsquo;데이터 스트림\u0026rsquo; 설정 화면으로 이동합니다. 방금 생성한 웹 스트림을 클릭하면 \u0026lsquo;측정 ID\u0026rsquo;가 표시됩니다. \u0026lsquo;G-\u0026lsquo;로 시작하는 이 ID를 복사해 둡니다. Hugo Blowfish 테마에 구글 애널리틱스 적용하기 # 이제 발급받은 측정 ID를 여러분의 Hugo 웹사이트에 적용할 차례입니다. Blowfish 테마는 Hugo의 기본 기능을 잘 지원하고 있어 설정이 매우 간단합니다.\n설정 파일 열기: 여러분의 Hugo 프로젝트 폴더에서 config/_default/hugo.toml 파일을 엽니다. hugo.toml 파일이 없는 경우, config.toml 파일을 확인합니다. 측정 ID 추가: hugo.toml 파일의 맨 아래에 다음 한 줄을 추가합니다. 복사해 두었던 여러분의 측정 ID를 붙여넣으십시오.\ngoogleAnalytics = \u0026#34;G-XXXXXXXXXX\u0026#34; G-XXXXXXXXXX 부분에는 반드시 본인의 측정 ID를 입력해야 합니다. 변경사항 저장 및 웹사이트 빌드: 파일을 저장한 후, 변경사항을 웹사이트에 반영합니다.\n로컬 환경에서 확인하려면 터미널에서 hugo server 명령어를 실행합니다.\n웹사이트를 실제 서버에 배포하는 경우, 변경된 파일을 Git에 푸시(push)하는 등의 배포 절차를 진행합니다.\n적용 확인: 실시간 방문자 데이터 보기 # 설정이 올바르게 완료되었는지 확인하는 가장 확실한 방법은 구글 애널리틱스에서 실시간 데이터를 확인하는 것입니다.\n구글 애널리틱스 접속: 구글 애널리틱스에 다시 접속합니다.\n실시간 보고서 확인: 왼쪽 메뉴에서 \u0026lsquo;보고서\u0026rsquo; \u0026gt; \u0026lsquo;실시간\u0026rsquo;으로 이동합니다.\n웹사이트 접속 및 데이터 확인: 이제 여러분의 웹사이트에 직접 접속해 보십시오. 잠시 후 실시간 보고서의 \u0026lsquo;지난 30분간의 사용자\u0026rsquo; 수가 1 이상으로 표시되면 성공적으로 연동된 것입니다.\n마무리 # 이제 여러분은 자신의 웹사이트 방문자에 대한 귀중한 데이터를 얻기 위한 첫걸음을 내디뎠습니다. 꾸준히 데이터를 관찰하고 분석하며 방문자들이 무엇을 원하는지 파악해 보십시오. 여러분의 웹사이트가 한 단계 더 성장하는 데 훌륭한 밑거름이 될 것입니다. 궁금한 점이 있다면 언제든 주저하지 말고 관련 커뮤니티나 공식 문서를 참고하는 것을 추천합니다.\n참조\nHugo 공식 문서 - Google Analytics Blowfish 테마 문서 - Partials Google 애널리틱스 고객센터 - [GA4] Google 애널리틱스 설정 ","date":"10 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/set-google-analytics/","section":"","summary":"","title":"Hugo Blowfish에 구글 애널리틱스 적용하기","type":"posts"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/google-search-console/","section":"Tags","summary":"","title":"Google Search Console","type":"tags"},{"content":"오늘은 Hugo Blowfish 테마로 만든 웹사이트를 구글 서치 콘솔(Google Search Console)에 등록하는 방법을 차근차근 안내해 드리겠습니다.\n구글 서치 콘솔은 내 웹사이트가 구글 검색 결과에 어떻게 표시되는지 확인하고, 검색 트래픽을 분석하며, 발생할 수 있는 문제들을 해결할 수 있도록 구글이 무료로 제공하는 강력한 도구입니다. 어렵게 느껴질 수 있지만, 제가 안내하는 대로만 따라오시면 초보자분들도 누구나 쉽게 등록을 마칠 수 있을 것입니다.\n구글 서치 콘솔에 내 사이트 추가하기 # 가장 먼저 구글 서치 콘솔에 접속하여 내 웹사이트를 \u0026lsquo;속성\u0026rsquo;으로 추가해야 합니다.\n구글 서치 콘솔 에 접속하여 \u0026lsquo;시작하기\u0026rsquo; 버튼을 클릭합니다. 구글 계정으로 로그인이 필요합니다.\n왼쪽 상단의 속성 선택 메뉴에서 \u0026lsquo;+ 속성 추가\u0026rsquo;를 선택합니다.\n속성 유형 선택 창이 나타나면 \u0026lsquo;URL 접두어\u0026rsquo; 방식을 선택합니다. 그리고 내 웹사이트의 전체 주소(예: https://example.com)를 입력하고 \u0026lsquo;계속\u0026rsquo; 버튼을 누릅니다. 소유권 확인 창이 나타나면 \u0026lsquo;다른 확인 방법\u0026rsquo; 섹션에서 \u0026lsquo;HTML 태그\u0026rsquo;를 선택합니다. 화면에 \u0026lt;meta\u0026gt;로 시작하는 태그가 나타날 것입니다. 오른쪽에 있는 \u0026lsquo;복사\u0026rsquo; 버튼을 클릭하여 이 태그를 복사해 둡니다. 이 확인 창을 닫지 말고 그대로 유지해 주십시오. 다음 단계를 완료한 후 다시 돌아와서 \u0026lsquo;확인\u0026rsquo; 버튼을 눌러야 합니다. \u0026ldquo;도메인\u0026rdquo; 방식과 \u0026ldquo;URL 접두어\u0026rdquo; 방식, 무엇이 다를까요? # 구글 서치 콘솔은 두 가지 속성 유형을 제공합니다. 각 방식의 특징을 이해하면 왜 우리가 \u0026lsquo;URL 접두어\u0026rsquo; 방식을 선택했는지 쉽게 알 수 있습니다.\n도메인 방식 URL 접두어 방식 범위 www가 붙거나 붙지 않은 주소, http와 httpshttps 프로토콜, 그리고 모든 하위 도메인(예: blog.example.com, m.example.com)까지 모두 포함하여 확인합니다. 입력한 정확한 주소만을 대상으로 합니다. 예를 들어 https://example.com으로 등록하면 http://example.com이나 https://www.example.com은 별개의 속성으로 간주됩니다. 인증 방법 DNS 레코드 수정이 필요합니다. 이는 웹사이트가 등록된 도메인 서비스(예: 가비아, Cloudflare 등)에 직접 접속하여 TXT 레코드를 추가하는 방식으로, 초보자에게는 다소 복잡하고 어렵게 느껴질 수 있습니다. HTML 파일 업로드, HTML 태그 추가 등 비교적 간단하고 다양한 방법을 제공합니다. 웹사이트 코드에 직접 태그를 추가하는 방식은 직관적이라 초보자도 쉽게 따라 할 수 있습니다. 여기서 \u0026ldquo;URL 접두어\u0026rdquo; 방식을 선택한 이유는 명확합니다. 개인 블로그나 웹사이트는 보통 하나의 대표 주소(Canonical URL)를 사용하므로, \u0026lsquo;URL 접두어\u0026rsquo; 방식으로도 충분히 구글 검색 데이터를 분석하고 관리할 수 있습니다.\nHugo Blowfish 테마에 HTML 태그 추가하기 # 이제 복사한 HTML 태그를 내 Hugo 웹사이트에 추가할 차례입니다. Blowfish 테마는 사용자가 쉽게 \u0026lt;head\u0026gt; 영역에 코드를 추가할 수 있도록 편리한 기능을 제공합니다.\n내 Hugo 프로젝트의 루트 디렉터리에서 layouts/partials/ 폴더로 이동합니다. 만약 layouts나 partials 폴더가 없다면 직접 생성해 주시면 됩니다.\n해당 폴더 안에 extend-head.html이라는 이름의 파일을 새로 생성합니다.\n생성한 extend-head.html 파일을 열고, 이전에 구글 서치 콘솔에서 복사했던 \u0026lt;meta\u0026gt; 태그를 그대로 붙여넣습니다.\n\u0026lt;meta name=\u0026#34;google-site-verification\u0026#34; content=\u0026#34;여기에_구글이_제공한_코드를_붙여넣으세요\u0026#34; /\u0026gt; 파일을 저장한 후, Hugo 사이트를 다시 빌드하고 서버에 배포합니다. 로컬 환경에서 테스트 중이라면 Hugo 서버를 재시작하여 변경사항이 적용되었는지 확인합니다. \u0026lt;head\u0026gt; 영역은 웹사이트의 눈에 보이지 않는 중요한 정보들을 담는 부분입니다. 검색 엔진은 이 영역의 정보를 읽어 사이트의 특징을 파악합니다. Blowfish 테마의 extend-head.html 파일은 바로 이 \u0026lt;head\u0026gt; 영역에 우리가 원하는 코드를 손쉽게 추가할 수 있도록 약속된 파일명입니다. 소유권 확인 완료 # 웹사이트에 HTML 태그를 성공적으로 추가하고 배포했다면, 이제 마지막 단계입니다.\n이전에 열어두었던 구글 서치 콘솔의 소유권 확인 창으로 돌아갑니다. \u0026lsquo;확인\u0026rsquo; 버튼을 클릭합니다. 구글이 내 웹사이트를 확인하고 추가된 메타 태그를 발견하면 \u0026ldquo;소유권이 확인되었습니다\u0026quot;라는 메시지가 나타납니다.\n이제 \u0026lsquo;속성으로 이동\u0026rsquo; 버튼을 클릭하여 내 사이트의 서치 콘솔 대시보드로 이동할 수 있습니다.\n데이터가 수집되고 보고서가 표시되기까지는 며칠 정도 시간이 걸릴 수 있습니다. 사이트맵(Sitemap) 등록으로 구글에 길 알려주기 # 소유권 확인이 끝났다면, 구글 검색 로봇에게 내 웹사이트의 전체 구조를 알려주는 \u0026lsquo;사이트맵\u0026rsquo;을 제출할 차례입니다. 사이트맵은 웹사이트의 모든 페이지 목록을 담고 있는 \u0026lsquo;지도\u0026rsquo;와 같아서, 구글이 내 사이트의 어떤 페이지들을 수집해가야 하는지 정확하게 알려주는 역할을 합니다.\n다행히도 Hugo는 별도의 설정 없이 sitemap.xml이라는 이름의 사이트맵을 자동으로 생성해 줍니다. 우리는 이 파일을 구글 서치 콘솔에 등록하기만 하면 됩니다.\n구글 서치 콘솔 대시보드의 왼쪽 메뉴에서 \u0026lsquo;Sitemaps\u0026rsquo;를 선택합니다. \u0026lsquo;새 사이트맵 추가\u0026rsquo; 섹션에 sitemap.xml을 입력하고 \u0026lsquo;제출\u0026rsquo; 버튼을 클릭합니다.\n제출이 완료되면 \u0026lsquo;상태\u0026rsquo; 항목에 \u0026lsquo;성공\u0026rsquo;이라고 표시됩니다. 구글이 사이트맵을 처리하고 페이지를 수집하는 데는 약간의 시간이 걸릴 수 있습니다.\n처음 제출하면 상태가 \u0026lsquo;수집할 수 없음\u0026rsquo;으로 표시될 수 있으나, 보통 몇 시간 또는 며칠 내로 \u0026lsquo;성공\u0026rsquo;으로 변경되니 잠시 기다려 주십시오. 마무리 # 이제 구글 서치 콘솔 등록부터 사이트맵 제출까지 모든 과정을 마쳤습니다. 구글 검색 로봇이 내 사이트를 더 효율적으로 방문하고 중요한 페이지들을 빠짐없이 색인(검색 데이터베이스에 등록)할 준비가 되었습니다. 앞으로는 서치 콘솔을 통해 방문자들이 어떤 검색어로 내 사이트를 찾아오는지, 혹시 사이트에 문제는 없는지 등을 주기적으로 확인하며 더 나은 웹사이트로 가꾸어 나가시길 바랍니다.\n참조\nGoogle Search Console 도움말 Hugo Blowfish Theme Documentation - Partials ","date":"8 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/register-google-search-console/","section":"","summary":"","title":"Hugo Blowfish 테마: 내 사이트를 구글에 알리는 첫걸음, 서치 콘솔 등록 가이드","type":"posts"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/domain/","section":"Tags","summary":"","title":"Domain","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github Pages","type":"tags"},{"content":"열심히 만든 블로그를 배포한 후, 설정해 둔 커스텀 도메인으로 접속이 되지 않아 당황하셨을 것 같습니다. 이 문제는 많은 분들이 겪는 흔한 상황이며, 원인만 알면 간단하게 해결할 수 있습니다.\nHugo Blowfish 테마를 포함한 대부분의 Hugo 사이트 배포 시 CNAME 파일이 사라지는 문제의 해결 방법을 명확하게 알려드리겠습니다.\n문제의 원인: Hugo 빌드 프로세스 # 이 문제의 원인을 먼저 이해하면 해결책을 찾기 쉽습니다.\nhugo 명령어를 실행하여 사이트를 빌드하면, Hugo는 기존의 public 폴더를 완전히 삭제하고 콘텐츠, 테마, 설정 등을 바탕으로 새로운 public 폴더를 생성합니다.\n따라서 배포 전에 수동으로 public 폴더 안에 CNAME 파일을 넣어두었다면, 다음 빌드 시점에서 해당 파일이 예외 없이 삭제되는 것입니다.\n해결 방법: static 폴더 활용하기 # 가장 확실하고 올바른 해결 방법은 Hugo의 static 폴더를 활용하는 것입니다. static 폴더 안의 모든 파일과 폴더는 빌드 시점에 public 폴더 안으로 그대로 복사됩니다.\n이 원리를 이용하여 CNAME 파일이 항상 최종 결과물에 포함되도록 할 수 있습니다.\nCNAME 파일 생성하기 # 메모장이나 코드 에디터를 열어 아무 내용 없이 여러분의 커스텀 도메인 주소만 정확하게 입력합니다.\n파일 내용 예시:\nblog.example.com http:// 나 https:// 와 같은 프로토콜은 포함하지 마십시오. 오직 도메인 주소만 적어야 합니다. static 폴더에 CNAME 파일 배치하기 # 생성한 CNAME 파일을 Hugo 프로젝트의 루트(최상위)에 있는 static 폴더 안으로 옮깁니다. static 폴더가 없다면 직접 생성하시면 됩니다.\n올바른 파일 경로:\n내-휴고-프로젝트/ ├── archetypes/ ├── content/ ├── data/ ├── layouts/ ├── static/ │ └── CNAME \u0026lt;-- 바로 여기에 위치해야 합니다. └── hugo.toml 빌드 및 확인 # 이제 로컬 환경에서 hugo 명령어를 실행하여 사이트를 빌드해 보십시오. 빌드가 완료된 후 public 폴더 안을 확인하면 CNAME 파일이 생성된 것을 볼 수 있습니다.\n이제 이 상태로 원격 저장소에 푸시(Push)하거나 서버에 배포하면, CNAME 파일이 항상 포함되어 커스텀 도메인이 정상적으로 연결됩니다.\nGitHub Actions 배포 환경에서의 추가 확인 사항 # 만약 GitHub Actions를 사용하여 GitHub Pages에 자동 배포하고 있다면, 워크플로우(.github/workflows/deploy.yml 등) 파일을 확인해 볼 필요가 있습니다.\n몇몇 Hugo 배포 워크플로우 템플릿에는 빌드 후에 CNAME 파일을 생성하는 명령어가 포함되어 있기도 합니다.\n# .github/workflows/deploy.yml 파일 예시 - name: Build with Hugo run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public cname: blog.example.com # \u0026lt;--- 이 부분이 CNAME을 생성합니다. 만약 위와 같이 cname: 설정이 워크플로우 파일에 있다면, 이 값을 본인의 도메인으로 수정하는 것만으로도 문제가 해결될 수 있습니다. 하지만 static 폴더에 CNAME 파일을 두는 방법이 Hugo의 표준적인 방식이며, 배포 환경이 바뀌더라도 동일하게 적용할 수 있어 더욱 권장되는 방법입니다.\n마무리 # 핵심은 \u0026ldquo;Hugo가 public 폴더를 새로 만들기 전에, CNAME 파일을 static 폴더에 미리 준비해 둔다\u0026rdquo; 는 것입니다. 이 간단한 규칙만 기억하시면 앞으로 Hugo 사이트를 운영하면서 커스텀 도메인 문제로 고민할 일이 없으실 겁니다.\n","date":"8 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/github-cname-issue/","section":"","summary":"","title":"휴고 블로그 커스텀 도메인이 자꾸 사라져요! CNAME 파일 유지 방법 (static 폴더 사용)","type":"posts"},{"content":"정성껏 만든 당신의 블로그나 프로젝트가 username.github.io라는 주소에 머무는 것이 아쉬웠던 적 없으신가요? 나만의 고유한 도메인을 연결하는 것은 당신의 온라인 정체성을 확립하고 전문성을 한 단계 끌어올리는 중요한 과정입니다.\n이번 글에서는 이미 보유하고 계신 도메인을 GitHub Pages에 연결하는 전체 과정을 안내해 드리고자 합니다. DNS 설정과 같이 다소 생소할 수 있는 부분도 저의 경험을 녹여 누구나 따라 할 수 있도록 차근차근 설명하겠습니다.\nGitHub Pages: 개발자를 위한 가장 간단한 웹 호스팅 # GitHub Pages는 GitHub 저장소(Repository)에 있는 HTML, CSS, JavaScript 파일들을 그대로 웹사이트로 만들어주는 정적 사이트 호스팅 서비스입니다. 복잡한 서버 설정 없이, 저장소에 코드를 올리는 것만으로 간편하게 내 사이트를 세상에 공개할 수 있어 수많은 개발자의 포트폴리오, 프로젝트 문서, 블로그 등으로 널리 활용되고 있습니다.\n도메인 연결, 무엇을 준비해야 할까요? # 본격적인 연결 작업에 앞서, 몇 가지 준비물을 확인해 보겠습니다.\nGitHub Pages 사이트: [사용자명].github.io 또는 [사용자명].github.io/[저장소명] 주소로 접속 가능한, 이미 만들어진 GitHub Pages 사이트가 필요합니다.\n구입한 개인 도메인: 호스팅케이알, 가비아, Google Domains 등 도메인 등록 업체(Registrar)를 통해 구입한 도메인이 있어야 합니다.\n당신의 온라인 공간 주소 - 도메인 구입하기 6 July 2025\u0026middot;439 words\u0026middot;3 mins DNS 설정은 변경된 내용이 전 세계 인터넷에 전파되기까지 시간이 걸릴 수 있습니다. 짧게는 몇 분에서 길게는 48시간까지 소요될 수 있으니, 설정 변경 후 바로 적용되지 않더라도 조급해하지 마십시오. 이를 \u0026lsquo;DNS 전파 시간(Propagation Time)\u0026lsquo;이라고 합니다. GitHub 저장소에 커스텀 도메인 알려주기 # 가장 먼저 할 일은 GitHub Pages 저장소에 앞으로 사용할 도메인이 무엇인지 알려주는 것입니다.\n도메인을 연결할 GitHub 저장소로 이동합니다.\n상단 탭에서 [Settings] 를 클릭합니다.\n좌측 메뉴에서 [Pages] 탭으로 들어갑니다.\n\u0026lsquo;Custom domain\u0026rsquo; 섹션의 입력란에 연결할 도메인 주소(예: www.example.com 또는 example.com)를 입력하고 [Save] 버튼을 클릭합니다.\nSave를 누르면 저장소에 CNAME이라는 파일이 자동으로 생성되며, 파일 안에는 방금 입력한 도메인 주소가 적혀 있습니다. 이 파일이 GitHub Pages에 어떤 도메인을 연결할지 알려주는 역할을 합니다. 도메인 등록 업체에서 DNS 설정하기 # 이제 가장 중요한 단계입니다. 당신이 구입한 도메인 업체 사이트로 가서, \u0026ldquo;이 도메인 주소로 접속하면 GitHub Pages 서버로 안내해 줘\u0026quot;라고 설정하는 과정입니다. 이를 DNS 레코드 설정이라고 합니다.\n도메인 등록 업체(예: 호스팅케이알, 가비아) 웹사이트에 로그인 후, \u0026lsquo;DNS 관리\u0026rsquo;, \u0026lsquo;도메인 설정\u0026rsquo; 또는 이와 유사한 메뉴로 이동하십시오. 여기서 설정할 레코드는 도메인을 어떻게 사용하느냐에 따라 나뉩니다.\nwww 같은 서브도메인 연결하기 (예: www.example.com) # DNS 설정 메뉴에서 CNAME 유형의 레코드를 새로 추가합니다.\n각 항목을 다음과 같이 입력합니다.\n호스트(Host) / 이름(Name): www\n값(Value) / 내용(Content) / 가리킬 위치(Points to): [내 GitHub 사용자명].github.io\nTTL (Time To Live): 기본값으로 둡니다 (보통 3600 또는 \u0026lsquo;자동\u0026rsquo;).\n기본 도메인(Apex 도메인) 직접 연결하기 (예: example.com) # www 없이 도메인 주소 자체를 연결하고 싶을 때 사용합니다.\nDNS 설정 메뉴에서 A 유형의 레코드를 새로 추가합니다.\n각 항목을 다음과 같이 입력합니다.\n호스트(Host) / 이름(Name): @ 또는 비워둡니다 (업체마다 다름).\n값(Value) / 내용(Content) / IP 주소: 185.199.108.153\n같은 방식으로 A 레코드를 3개 더 추가하여, 아래의 IP 주소를 각각 입력합니다.\n185.199.109.153\n185.199.110.153\n185.199.111.153\nA 레코드와 CNAME 레코드**\nA 레코드: 특정 도메인을 IP 주소로 직접 연결하는 가장 기본적인 방식입니다.\nCNAME 레코드: 특정 도메인을 다른 도메인 이름으로 연결하는 별명 같은 방식입니다. GitHub의 서버 IP가 바뀌더라도 우리는 신경 쓸 필요가 없어 유지보수에 더 편리합니다.\nHTTPS 적용 및 확인 # DNS 설정이 완료되고 전파 시간(최대 48시간)이 지나면, 다시 GitHub 저장소의 [Settings] \u0026gt; [Pages] 메뉴로 돌아옵니다.\n\u0026lsquo;Custom domain\u0026rsquo; 섹션에 \u0026ldquo;Your site is published at\u0026hellip;\u0026rdquo; 라는 녹색 알림이 나타나면 정상적으로 연결된 것입니다.\n이때 \u0026lsquo;Enforce HTTPS\u0026rsquo; 옵션이 활성화되면 반드시 체크하여 주십시오. 이 옵션은 당신의 사이트 방문자들이 안전한 암호화(SSL) 연결을 통해 접속하도록 강제하여 보안을 강화합니다. GitHub에서 알아서 무료로 인증서를 발급하고 적용해 줍니다.\n모든 과정이 끝나면, 이제 브라우저 주소창에 나만의 도메인을 입력하여 당신의 GitHub Pages 사이트로 접속할 수 있습니다.\n마무리하며 # 지금까지 GitHub Pages에 개인 도메인을 연결하는 방법을 단계별로 알아보았습니다. DNS 설정과 같은 용어가 처음에는 다소 어렵게 느껴질 수 있지만, 이 글에서 안내한 절차를 차분히 따라오시면 분명 성공적으로 나만의 주소를 갖게 되실 겁니다.\n참조\nGitHub Docs - Managing a custom domain for your GitHub Pages site: https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site GitHub Docs - Troubleshooting custom domains and GitHub Pages: https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages ","date":"8 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/github-pages-connect-own-domain/","section":"","summary":"","title":"내 블로그가 세상과 만나는 주소, GitHub Pages에 커스텀 도메인 연결하기","type":"posts"},{"content":"","date":"7 July 2025","externalUrl":null,"permalink":"/tags/freshrss/","section":"Tags","summary":"","title":"Freshrss","type":"tags"},{"content":"정보의 홍수 속에서 나에게 꼭 필요한 소식만 골라보는 것은 무엇보다 중요합니다. RSS는 바로 이러한 필요를 충족시켜주는 훌륭한 기술이지만, 나만의 취향과 필요에 맞는 완벽한 구독기를 찾기란 쉽지 않습니다.\n이번 글에서는 도커(Docker) 기술을 활용하여, 광고나 외부 서비스의 제약 없이 온전히 내 소유의 RSS 구독기, FreshRSS를 우분투 서버에 구축하는 방법을 안내해 드리고자 합니다. 이 방법을 사용하면 복잡한 서버 지식 없이도, 놀라울 정도로 빠르고 효율적으로 \u0026lsquo;나만의 정보 허브\u0026rsquo;를 만들 수 있습니다.\n설치 전 준비사항 # Docker Compose를 이용한 설치는 준비 과정이 매우 간단합니다.\n우분투 서버(Ubuntu Server): 최신 LTS 버전이면 충분합니다.\n도커(Docker) 및 도커 컴포즈(Docker Compose): 서버에 미리 설치되어 있어야 합니다. Ubuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins 작업 공간 및 Docker Compose 파일 생성 # 가장 먼저, FreshRSS 관련 파일들을 보관할 폴더를 만들고 그 안에 설정 파일을 생성합니다.\n작업 폴더 생성 및 이동 # mkdir freshrss-docker cd freshrss-docker mkdir data mkdir extensions docker-compose.yml 파일 생성 # nano 또는 선호하는 텍스트 편집기를 사용하여 설정 파일을 만듭니다.\nnano docker-compose.yml 설정 파일 내용 붙여넣기 # 아래 내용을 그대로 복사하여 docker-compose.yml 파일에 붙여넣습니다.\nversion: \u0026#39;3\u0026#39; services: freshrss: image: freshrss/freshrss:latest container_name: freshrss restart: unless-stopped ports: - \u0026#39;8080:80\u0026#39; environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul - CRON_MIN=*/30 volumes: - ./data:/var/www/FreshRSS/data - ./extensions:/var/www/FreshRSS/extensions services: 이 파일로 실행할 서비스(컨테이너)의 목록입니다. 여기서는 freshrss 하나만 실행합니다. image: 컨테이너를 만들 때 사용할 원본 이미지(설계도)입니다. container_name: 실행될 컨테이너에 부여하는 고유한 이름입니다. restart: unless-stopped: 서버가 재시작되더라도, 내가 직접 중지시키지 않는 한 컨테이너가 자동으로 다시 실행되도록 합니다. ports: 서버의 포트(:의 왼쪽)와 컨테이너의 포트(:의 오른쪽)를 연결합니다. 8080:80은 서버의 8080 포트로 들어오는 요청을 컨테이너의 80번 포트로 전달하라는 의미입니다. environment: 컨테이너 내부에 환경 변수를 설정합니다. TZ=Asia/Seoul은 시간대를 서울로, CRON_MIN=*/30은 30분마다 새로운 RSS 피드를 가져오도록 설정합니다. volumes: 컨테이너의 특정 폴더(:의 오른쪽)를 우리 서버의 실제 폴더(:의 왼쪽)와 연결합니다. 이렇게 하면 컨테이너가 삭제되어도 데이터가 안전하게 보존됩니다. Docker Compose 실행 # 설정 파일 작성이 끝났다면, 이제 마법의 주문을 외칠 차례입니다. docker-compose.yml 파일이 있는 폴더에서 아래의 명령어를 입력하십시오.\ndocker compose up -d -d 옵션은 컨테이너를 백그라운드에서 실행하라는 의미입니다. 처음 실행하면 freshrss/freshrss 이미지를 다운로드하므로 약간의 시간이 걸릴 수 있습니다. \u0026ldquo;Done\u0026rdquo; 메시지가 나타나면 성공적으로 실행된 것입니다. FreshRSS 접속 및 설정 # 모든 서버 설정이 끝났습니다. 이제 웹 브라우저에서 FreshRSS에 접속하여 마지막 설정을 진행합니다.\nFreshRSS 접속 # 웹 브라우저에서 http://[내 서버의 IP 주소]:8080 주소로 접속합니다.\n초기 설정 진행 # 언어를 \u0026lsquo;한국어\u0026rsquo;로 선택하고 다음 단계로 진행합니다. \u0026ldquo;설치 요구 사항 확인\u0026rdquo; 체크 화면에서 모든 항목이 녹색으로 표시되는지 확인합니다. 데이터베이스 유형은 기본값인 SQLite를 그대로 사용하면 됩니다. Docker 볼륨을 통해 데이터가 안전하게 저장되므로 별도의 데이터베이스 설정이 필요 없습니다. 기본 사용자 계정을 생성하고, 인증 방식을 선택합니다. [설치] 버튼을 누르면 모든 과정이 완료됩니다. 마무리하며 # 이제 당신은 가장 현대적이고 효율적인 방식으로 FreshRSS 서버 구축을 완료했습니다. 잘 작성된 docker-compose.yml 파일 하나가 복잡한 서버 설정을 얼마나 간단하게 만드는지 경험하셨을 겁니다.\n직접 구축한 FreshRSS에 원하는 언론사, 블로그, 커뮤니티의 RSS 피드를 하나씩 추가하며, 나만의 지식 정원을 가꾸는 즐거움을 만끽하시길 바랍니다. 이 가이드가 그 여정에 든든한 첫걸음이 되었기를 바랍니다.\n참조\nFreshRSS 공식 홈페이지 FreshRSS Github Deploy FreshRSS with Docker ","date":"7 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/fresh-rss/","section":"","summary":"","title":"나만의 뉴스레터, FreshRSS 간편하게 구축하기","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/hostingkr/","section":"Tags","summary":"","title":"Hostingkr","type":"tags"},{"content":"온라인에서 나만의 공간을 마련하는 첫걸음은 바로 \u0026lsquo;도메인\u0026rsquo;을 갖는 것에서부터 시작합니다. 도메인은 인터넷 세상에서 당신의 집 주소와도 같습니다. 방문자들이 당신의 웹사이트를 쉽게 찾아올 수 있도록 하는 중요한 이정표인 셈입니다.\n이번 글에서는 국내에서 많은 분들이 이용하는 \u0026lsquo;호스팅케이알(Hosting.kr)\u0026rsquo; 서비스를 기준으로, 누구나 쉽게 따라 할 수 있도록 도메인 구입의 전 과정을 안내해 드리고자 합니다.\n도메인, 무엇을 준비해야 할까요? # 도메인을 구입하기 전에 몇 가지 준비해두시면 과정이 한결 수월해집니다. 복잡한 내용은 아니니, 아래 목록을 가볍게 확인해 보시기 바랍니다.\n원하는 도메인 이름 구상: 당신의 웹사이트 정체성을 잘 나타낼 수 있는 간결하고 기억하기 쉬운 이름을 2~3개 정도 미리 생각해 두십시오. 이미 다른 사람이 사용하고 있을 가능성에 대비하는 것입니다.\n회원가입: 호스팅케이알에서 도메인을 구입하려면 계정이 필요합니다. 미리 가입해두시면 결제 과정을 신속하게 진행할 수 있습니다.\n소유자 정보: 도메인을 등록할 때는 소유자의 이름, 주소, 이메일, 연락처 등 정확한 정보가 필요합니다. 이는 국제 인터넷 주소 관리 기구(ICANN)의 정책에 따른 필수 절차입니다.\n\u0026lsquo;.us\u0026rsquo;\u001f 같은 국가 도메인은 소유자 이메일 인증 절차를 거쳐야 등록이 완료됩니다. 차근차근 따라 하는 도메인 구입 절차 # 이제 본격적으로 도메인을 구입하는 방법을 단계별로 상세히 알려드리겠습니다.\n원하는 도메인 검색하기 # 호스팅케이알 웹사이트 중앙에 있는 검색창에 생각했던 도메인 이름을 입력하고 \u0026lsquo;검색\u0026rsquo; 버튼을 누릅니다.\n검색 결과에서 원하는 도메인 주소(.com, .kr, .net 등)를 확인하고, \u0026lsquo;등록 가능\u0026rsquo; 상태라면 오른쪽의 \u0026lsquo;장바구니\u0026rsquo; 아이콘을 클릭하여 담습니다. \u0026lsquo;이미 사용중\u0026rsquo;이라고 표시된 도메인은 다른 사람이 소유하고 있으므로 등록할 수 없습니다.\n장바구니 확인 및 기간 설정 # 장바구니로 이동하여 선택한 도메인이 맞는지 확인합니다.\n등록 기간: 도메인은 최소 1년부터 최대 10년까지 년 단위로 등록 기간을 설정할 수 있습니다. 원하는 기간을 선택하십시오.\n도메인 개인정보보호: \u0026lsquo;WHOIS\u0026rsquo;라는 서비스를 통해 누구나 도메인 소유자의 정보를 조회할 수 있습니다. 이때 이름, 이메일 주소 등 개인 정보가 노출되는 것을 원치 않으시면 \u0026lsquo;개인정보보호\u0026rsquo; 서비스를 신청하는 것이 좋습니다. 호스팅케이알에서는 이 서비스를 무료로 제공하는 경우가 많습니다.\n소유자 정보 입력 및 네임서버 설정 # \u0026lsquo;등록하기\u0026rsquo; 버튼을 누르면 소유자 정보를 입력하는 페이지로 이동합니다. 미리 준비한 정보를 정확하게 입력하십시오.\n네임서버(Name Server): 도메인과 웹사이트가 저장된 서버를 연결해주는 역할을 합니다. 아직 웹호스팅 서비스를 결정하지 않으셨다면, 기본으로 설정된 \u0026lsquo;호스팅케이알 네임서버\u0026rsquo;를 그대로 사용하시면 됩니다. 추후 언제든지 변경할 수 있습니다. 네임서버는 사람이 기억하기 쉬운 도메인 이름(예: example.com)을 컴퓨터가 이해하는 IP 주소(예: 192.0.2.1)로 변환해주는 서버입니다.\n결제 진행 # 정보 입력을 마친 후, 원하는 결제 수단(카드 결제, 계좌 이체 등)을 선택하여 결제를 완료합니다. 결제가 성공적으로 끝나면 도메인 등록 절차가 마무리됩니다.\n5. 등록 완료 및 확인\n결제 완료 후 \u0026lsquo;나의서비스 \u0026gt; 도메인 관리\u0026rsquo; 메뉴로 이동하면 방금 구입한 도메인 목록을 확인할 수 있습니다. 경우에 따라 도메인이 완전히 등록되고 전 세계 인터넷에 적용되기까지 약간의 시간이 소요될 수 있습니다.\n마무리 # 지금까지 호스팅케이알을 통해 나만의 도메인을 구입하는 방법에 대해 알아보았습니다. 처음에는 낯설게 느껴질 수 있지만, 안내해 드린 절차대로 차분히 따라오시면 결코 어렵지 않은 과정입니다.\n도메인은 단순한 인터넷 주소를 넘어, 당신의 브랜드와 비전을 담는 소중한 자산입니다. 신중하게 선택하고 애정을 갖고 가꾸어 나가시길 바랍니다.\n참고\n호스팅케이알 고객센터: https://help.hosting.kr/hc/ko ","date":"6 July 2025","externalUrl":null,"permalink":"/posts/hosting/server/domain-purchase/","section":"","summary":"","title":"당신의 온라인 공간 주소 - 도메인 구입하기","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/categories/hosting/","section":"Categories","summary":"","title":"Hosting","type":"categories"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/%ED%99%88%EC%96%B4%EC%8B%9C%EC%8A%A4%ED%84%B4%ED%8A%B8/","section":"Tags","summary":"","title":"홈어시스턴트","type":"tags"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/posts/hosting/ha/","section":"","summary":"","title":"홈어시스턴트 운영하기","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/lg-thinq/","section":"Tags","summary":"","title":"LG ThinQ","type":"tags"},{"content":"오늘은 LG전자가 공식적으로 제공하는 개발자 API와 PAT(Personal Access Token)를 이용하여 홈어시스턴트와 LG ThinQ를 연동하는 방법에 대해 상세히 안내해 드리겠습니다.\nLG 개발자 포털에서 PAT 발급받기 # 가장 먼저, LG ThinQ 서버에 접근할 수 있는 권한을 가진 우리만의 고유한 열쇠, 즉 PAT를 발급받아야 합니다.\nLG ThinQ Developer 포털 접속: # 웹 브라우저를 열어 아래 주소로 이동한 뒤, 일반 LG 계정으로 로그인합니다.\n주소: https://smartsolution.developer.lge.com/ko/cloud/landing 메뉴에서 [적용 가이드] - [마이 커넥트(개인 API)] 를 선택합니다.\nPAT 발급하기: # [PAT] 버튼을 선택하면 다시 한번 로그인 과정을 거치고 PAT 발급 화면으로 이동합니다.\n권한 범위를 선택하고 [토큰 만들기]를 선택해서 토큰을 생성합니다.\n생성된 PAT 우측의 복사 아이콘을 눌러 토큰 전체를 복사합니다.\n이 PAT는 여러분의 모든 LG 가전을 제어할 수 있는 비밀 키와 같습니다. 절대 외부에 노출해서는 안 됩니다. 홈어시스턴트에 연동 정보 설정하기 # 이제 발급받은 PAT를 홈어시스턴트에 설정할 차례입니다. 이 과정은 PAT를 지원하는 커스텀 컴포넌트를 사용해야 합니다.\n(주의: 현재 HACS의 대표적인 ThinQ 컴포넌트는 LG 계정 로그인을 우선 지원합니다. PAT 방식을 위해서는 해당 컴포넌트가 PAT 입력을 지원하는지 확인하거나, RESTful API 센서 등을 이용한 수동 설정이 필요할 수 있습니다. 여기서는 PAT 입력을 지원하는 가상의 통합 구성요소를 기준으로 설명합니다.)\n통합 구성요소 추가:\n[설정] \u0026gt; [기기 및 서비스] 로 이동하여 [+ 통합 구성요소 추가] 버튼을 누릅니다.\nLG ThinQ 선택:\n설정 창이 나타나면, 인증 정보를 입력합니다.\n개인 엑세스 토큰(Personal Access Token) 에 이전 단계에서 복사해 둔 PAT 값 을 여기에 붙여넣습니다.\n인증이 성공하면, 홈어시스턴트가 PAT를 통해 여러분의 LG 계정에 등록된 기기 목록을 가져와 시스템에 자동으로 추가합니다.\n연동 후 활용 # 모든 과정이 끝나면, 여러분의 LG 스마트 가전은 홈어시스턴트의 엔티티(Entity)가 되어 다른 스마트 기기들과 똑같이 제어하고 자동화에 활용할 수 있게 됩니다. 공식 API를 사용하므로, 상태 업데이트가 빠르고 제어 명령의 신뢰도가 높다는 장점을 체감하실 수 있을 겁니다.\n마무리하며 # LG 개발자 포털을 이용한 PAT 방식의 연동은 간편하게 LG 디바이스와 홈어시스턴트를 연동해 주고, 기기들을 사용할 수 있게 해줍니다.\n","date":"6 July 2025","externalUrl":null,"permalink":"/posts/hosting/ha/connect-lg-thinq/","section":"","summary":"","title":"홈어시스턴트와 LG ThinQ 연동하기","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/https/","section":"Tags","summary":"","title":"HTTPS","type":"tags"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/proxy/","section":"Tags","summary":"","title":"Proxy","type":"tags"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/%EB%8F%84%EC%BB%A4/","section":"Tags","summary":"","title":"도커","type":"tags"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/%EC%9D%B8%EC%A6%9D%EC%84%9C/","section":"Tags","summary":"","title":"인증서","type":"tags"},{"content":"홈어시스턴트(Home Assistant)를 외부에서도 안전하게 접속하기 위해 HTTPS 암호화를 적용하는 것은 이제 선택이 아닌 필수입니다. 수많은 방법 중에서도, 가장 널리 사용하고 추천하는 것이 바로 Nginx Proxy Manager(NPM) 를 이용하는 방식입니다.\n오늘은 이 Nginx Proxy Manager를 도커(Docker)로 설치하고, 홈어시스턴트와 연결하여 Let\u0026rsquo;s Encrypt SSL 인증서를 자동으로 발급 및 갱신하는 가장 표준적인 방법을 안내해 드리고자 합니다\n사전 준비물 # 본격적인 설치에 앞서, 아래 항목들이 반드시 준비되어 있어야 합니다.\n개인 도메인 # 외부에서 접속할 나만의 주소입니다. (예: ha.mydomain.com) 무료 DDNS 서비스(예: DuckDNS)를 이용하시는게 좋습니다.\n공유기 포트포워딩 설정 # 외부 인터넷에서 들어오는 웹 트래픽을 홈서버로 정확히 전달해주는 설정입니다. 공유기 관리 페이지에서 아래와 같이 설정해 주십시오.\n외부(WAN) 포트 80 → 홈서버의 내부 IP 주소, 포트 80 외부(WAN) 포트 443 → 홈서버의 내부 IP 주소, 포트 443 Nginx Proxy Manager 설치 # Docker Compose를 사용하면 설치와 관리가 매우 간편합니다. 홈서버의 적당한 위치에 docker-compose.yml 파일을 생성하고 아래 내용을 붙여넣으십시오.\nversion: \u0026#39;3.8\u0026#39; services: app: image: \u0026#39;jc21/nginx-proxy-manager:latest\u0026#39; restart: unless-stopped ports: # Public HTTP Port - \u0026#39;80:80\u0026#39; # Public HTTPS Port - \u0026#39;443:443\u0026#39; # Admin Web Port - \u0026#39;81:81\u0026#39; environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul volumes: - ./data:/data - ./letsencrypt:/etc/letsencrypt ports: 80번과 443번 포트는 외부 사용자의 실제 웹 트래픽을 처리하는 데 사용되고, 81번 포트는 우리가 NPM을 설정하기 위해 접속하는 관리자 페이지용입니다. environment: PUID와 PGID는 현재 사용자와 docker container 내부의 사용자 ID를 설정합니다. volumes: ./data와 ./letsencrypt 폴더에 모든 설정과 SSL 인증서 정보가 저장됩니다. 이 부분이 있어야 컨테이너를 재시작하거나 업데이트해도 모든 설정이 안전하게 유지됩니다. 파일을 저장한 후, 터미널에서 해당 파일이 있는 폴더로 이동하여 아래 명령어를 실행해 NPM 컨테이너를 시작합니다.\ndocker-compose up -d Nginx Proxy Manager 초기 설정 # 웹 브라우저에서 http://\u0026lt;홈서버_IP\u0026gt;:81 주소로 접속합니다. (예: http://192.168.1.10:81) 아래 기본 계정 정보로 로그인합니다. Email: admin@example.com Password: changeme 로그인 직후, 보안을 위해 반드시 나타나는 안내에 따라 사용자 정보와 비밀번호를 자신만의 것으로 변경해주십시오. 프록시 호스트 및 SSL 인증서 설정 # 이제 외부 도메인 주소와 내부 홈어시스턴트를 연결하고, SSL 인증서를 발급받는 가장 중요한 단계입니다.\nNPM 관리자 페이지 상단 메뉴에서 [Hosts] \u0026gt; [Proxy Hosts] 로 이동합니다. [Add Proxy Host] 버튼을 클릭합니다. Details 탭을 아래와 같이 채웁니다.\nDomain Names: 준비한 개인 도메인을 입력합니다. (예: ha.mydomain.com) Scheme: http Forward Hostname / IP: 홈어시스턴트가 설치된 홈서버의 내부 IP 주소를 입력합니다. (예: 192.168.1.10) Forward Port: 홈어시스턴트의 포트 번호인 8123을 입력합니다. Websockets support: 반드시 체크(활성화) 해야 합니다. 홈어시스턴트 UI의 상태가 실시간으로 부드럽게 업데이트되기 위해 필수적인 설정입니다. SSL 탭으로 이동하여 아래와 같이 설정합니다.\nSSL Certificate: Request a new SSL Certificate를 선택합니다. Force SSL: 체크(활성화)합니다. 모든 접속을 자동으로 HTTPS로 전환하여 보안을 높입니다. Email Address for Let\u0026rsquo;s Encrypt: 유효한 이메일 주소를 입력합니다. 인증서 만료일이 다가올 때 알림을 받을 수 있습니다. I Agree to the Let's Encrypt Terms of Service를 체크(활성화)합니다. 마지막으로 [Save] 버튼을 누릅니다.\nNPM이 자동으로 Let\u0026rsquo;s Encrypt를 통해 SSL 인증서를 발급받고 적용하는 과정이 진행됩니다. 잠시 후 목록의 상태(Status)가 Online으로 바뀌면 성공입니다.\n도커 네트워크 대역 확인 # Nginx Proxy Manager(NPM) 컨테이너가 어떤 네트워크에 연결되어 있는지 확인하고, 그 네트워크의 IP 대역(Subnet)을 찾아야 합니다.\nNPM 컨테이너가 사용하는 네트워크 이름 찾기 # 먼저, 실행 중인 NPM 컨테이너의 정보를 확인하여 연결된 네트워크 이름을 찾습니다. docker-compose.yml 파일이 있는 폴더에서 아래 명령어를 실행하세요.\n$ docker compose ps WARN[0000] /home/user/Services/nginx-proxy-manager/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion NAME IMAGE COMMAND SERVICE CREATED STATUS PORTS nginx-proxy-manager-app-1 jc21/nginx-proxy-manager:latest \u0026#34;/init\u0026#34; app 9 hours ago Up 9 hours 0.0.0.0:80-81-\u0026gt;80-81/tcp, [::]:80-81-\u0026gt;80-81/tcp, 0.0.0.0:443-\u0026gt;443/tcp, [::]:443-\u0026gt;443/tcp nginx-proxy-manager-app-1 이 현재 NPM 컨테이너의 이름입니다.\nNPM 컨테이너의 이름을 확인했다면, docker inspect 명령어로 네트워크 정보를 봅니다.\ndocker inspect nginx-proxy-manager-app-1 출력된 결과(JSON 형식)가 매우 길게 나오는데, 그중에서 \u0026quot;Networks\u0026quot; 부분을 찾으면 아래와 같이 연결된 네트워크 이름이 보입니다. 보통 docker-compose로 만들었다면 폴더명_default 같은 이름으로 생성됩니다.\n... \u0026#34;Networks\u0026#34;: { // \u0026lt;-- 여기를 검색합니다. \u0026#34;npm_default\u0026#34;: { // \u0026lt;-- 이 부분이 네트워크 이름입니다. ... } } ... 네트워크의 상세 정보에서 IP 대역 확인하기 # 이제 위에서 찾은 네트워크 이름(npm_default)을 사용하여 네트워크의 상세 정보를 확인합니다.\ndocker network inspect npm_default 출력된 정보에서 \u0026quot;IPAM\u0026quot; (IP Address Management) 섹션을 찾으면, 우리가 원하는 \u0026quot;Subnet\u0026quot; 값이 있습니다.\n[ { ... \u0026#34;IPAM\u0026#34;: { \u0026#34;Driver\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Config\u0026#34;: [ { \u0026#34;Subnet\u0026#34;: \u0026#34;172.23.0.0/16\u0026#34;, // \u0026lt;-- 바로 이 값입니다! \u0026#34;Gateway\u0026#34;: \u0026#34;172.23.0.1\u0026#34; } ] }, ... } ] 홈어시스턴트 설정 파일 수정 # 마지막으로 홈어시스턴트가 리버스 프록시(NPM)를 통해 들어오는 접속을 신뢰하도록 설정해야 합니다.\n홈어시스턴트의 configuration.yaml 파일을 엽니다. 아래 http 설정을 추가하거나, 기존 내용이 있다면 trusted_proxies 부분을 추가합니다. http: use_x_forwarded_for: true trusted_proxies: - 172.19.0.2/16 # NPM이 포함된 도커 네트워크 대역 trusted_proxies 설정은 \u0026ldquo;이 IP 대역에서 오는 요청은 내가 신뢰하는 Nginx Proxy Manager를 거친 것이니 믿고 받아들여라\u0026quot;라고 홈어시스턴트에게 알려주는 역할을 합니다. 위 예시처럼 입력하면 대부분의 도커 환경에서 문제없이 작동합니다. configuration.yaml 파일을 저장한 후, 홈어시스턴트를 재시작합니다. 마무리하며 # 모든 설정이 끝났습니다. 이제 웹 브라우저에서 https://ha.mydomain.com 처럼 자신의 도메인으로 접속해 보십시오. 주소창에 안전함을 상징하는 자물쇠(🔒)가 표시된 홈어시스턴트 화면을 마주하실 수 있을 겁니다.\nNginx Proxy Manager를 통해 여러분의 홈서버는 더욱 안전해졌을 뿐만 아니라, 앞으로 다른 서비스를 추가하더라도 손쉽게 HTTPS를 적용할 수 있는 강력한 확장성까지 갖추게 되었습니다.\n","date":"6 July 2025","externalUrl":null,"permalink":"/posts/hosting/ha/set-certificate/","section":"","summary":"","title":"홈어시스턴트 HTTPS 연동하기","type":"posts"},{"content":"","date":"6 July 2025","externalUrl":null,"permalink":"/tags/duckdns/","section":"Tags","summary":"","title":"Duckdns","type":"tags"},{"content":"홈서버를 운영하거나 외부에서 집 안의 네트워크에 접속하려면, 계속해서 바뀌는 우리 집의 공인 IP 주소 대신, 기억하기 쉬운 고정된 도메인 주소가 필요합니다. 이 역할을 해주는 것이 바로 DDNS(Dynamic DNS) 서비스이며, 그중에서도 DuckDNS는 무료로 개인 도메인을 제공하는 가장 유명하고 신뢰도 높은 서비스 중 하나입니다.\n오늘은 DuckDNS에서 나만의 무료 도메인을 생성하고, 자동으로 IP 주소를 갱신하도록 설정하는 방법까지 모든 과정을 상세히 안내해 드리고자 합니다. 이 가이드를 마치고 나면, 여러분도 my-home.duckdns.org와 같은 근사한 개인 도메인을 갖게 되실 겁니다.\nDuckDNS 사이트 접속 및 로그인 # 가장 먼저 DuckDNS 계정을 생성해야 합니다. DuckDNS는 별도의 회원가입 절차 없이, 기존에 사용하던 소셜 계정을 통해 간편하게 로그인할 수 있습니다.\n웹 브라우저를 열어 DuckDNS 공식 사이트로 이동합니다.\nhttps://www.duckdns.org 메인 화면에 보이는 여러 소셜 로그인 버튼 중에서, 사용하고자 하는 계정(Google, Github, Reddit 등)을 선택하여 로그인합니다. 가장 보편적으로 사용하는 Google 계정으로 로그인하는 것을 추천합니다.\n서브도메인 생성하기 # 로그인을 완료하면 즉시 도메인을 관리할 수 있는 간단한 대시보드가 나타납니다.\ndomains 섹션의 subdomain 입력 칸에 원하는 도메인 이름을 입력합니다.\n전 세계에서 유일해야 하므로, 다른 사람이 사용하지 않을 만한 나만의 이름을 정해야 합니다. (예: my-smart-home-2025) 최종적으로는 입력한 이름 뒤에 .duckdns.org가 붙게 됩니다. 도메인 이름을 입력한 뒤, 우측의 [add domain] 버튼을 클릭합니다.\n잠시 후, 아래 domains 목록에 방금 생성한 도메인 주소와 함께 현재 여러분의 공인 IP 주소가 자동으로 등록된 것을 확인할 수 있습니다.\n토큰(Token) 확인 및 보관 # 이 단계가 매우 중요합니다. 생성된 도메인의 IP 주소를 자동으로 업데이트하려면, 각 계정마다 부여되는 고유한 토큰(Token) 값이 필요합니다.\nDuckDNS 대시보드 상단에서 token 항목을 찾습니다. 여기에 보이는 긴 영문/숫자 조합의 문자열이 바로 여러분의 고유 토큰입니다.\n이 토큰은 여러분의 도메인을 제어할 수 있는 비밀 키와 같습니다. 절대 외부에 노출해서는 안 되며, 안전한 곳(예: 비밀번호 관리 앱, 개인 메모장)에 잘 복사하여 보관해 두십시오. 이 토큰은 다음 단계에서 사용됩니다. IP 자동 업데이트 설정하기 # 이제 우리 집의 공인 IP가 바뀌더라도, 방금 만든 DuckDNS 도메인이 새로운 IP를 자동으로 찾아가도록 설정해야 합니다. 이 과정은 보통 공유기 자체의 DDNS 기능을 이용하거나, 홈서버에 직접 업데이트 스크립트를 설치하여 진행합니다.\n가장 보편적인 리눅스 서버(라즈베리 파이 등) 환경에서의 자동 업데이트 설정 방법은 다음과 같습니다.\nDuckDNS 사이트 상단의 [install] 탭으로 이동합니다.\nOperating System 항목에서 linux cron을 선택합니다.\nDomain 항목에서 방금 생성한 나의 도메인(my-smart-home-2025)을 선택합니다.\n아래 your command 섹션에 해당 도메인과 토큰 정보가 포함된 자동 업데이트 명령어가 자동으로 생성됩니다. 이 명령어를 그대로 복사합니다.\n생성된 명령어 예시: echo url=\u0026#34;https://www.duckdns.org/update?domains=my-smart-home-2025\u0026amp;token=YOUR-TOKEN-HERE\u0026#34; | curl -k -o ~/duckdns/duck.log -K - 홈서버 터미널에 접속하여, 이 명령어가 5분마다 주기적으로 실행되도록 crontab에 등록합니다.\n# crontab 편집기 열기 crontab -e # 편집기 맨 아래에 아래 내용 추가 (5분마다 실행) */5 * * * * /bin/bash -c \u0026#39;echo url=\u0026#34;https://www.duckdns.org/update?domains=my-smart-home-2025\u0026amp;token=YOUR-TOKEN-HERE\u0026#34; | curl -k -o ~/duckdns/duck.log -K -\u0026#39; 이제 여러분의 홈서버는 5분마다 한 번씩 DuckDNS 서버에 \u0026ldquo;나 여기 있어!\u0026ldquo;라고 신호를 보내, 항상 최신 IP 주소를 유지하게 됩니다.\n마무리하며 # DuckDNS를 통해 여러분은 이제 숫자 IP 주소의 굴레에서 벗어나, 의미 있고 기억하기 쉬운 자신만의 도메인을 갖게 되었습니다. 비록 간단한 과정이지만, 이는 홈서버 운영과 원격 접속의 세계로 들어서는 매우 의미 있는 첫걸음입니다.\n","date":"6 July 2025","externalUrl":null,"permalink":"/posts/hosting/server/duck-dns/","section":"","summary":"","title":"DuckDNS로 나만의 무료 도메인 만들기","type":"posts"},{"content":"집에 있는 나만의 서버(홈서버)를 외부에서도 접속하여 활용하고 싶다는 생각을 해보셨을 겁니다. NAS에 저장된 파일을 꺼내 보거나, 원격으로 데스크톱에 접속하는 등 그 활용성은 무궁무진합니다. 오늘은 가정용 공유기의 설정을 통해 홈서버에 안전하게 외부 접속 환경을 구축하는 방법을 차근차근 안내해 드리고자 합니다.\n어떻게 해야할까? # 외부에서 집 안에 있는 서버에 접속하기 위해서는, 외부의 요청을 집 안의 특정 서버 PC로 정확히 안내해주는 \u0026lsquo;이정표\u0026rsquo;를 공유기에 설정해 주어야 합니다. 이 과정은 크게 두 단계로 나뉩니다.\nDDNS 설정: 유동적인 집의 인터넷 주소(공인 IP)에 고정된 도메인 이름을 부여하는 작업. 포트 포워딩 설정: 부여된 도메인 이름의 특정 \u0026lsquo;문(포트)\u0026lsquo;으로 들어온 요청을 실제 서버 PC의 \u0026lsquo;문(포트)\u0026lsquo;으로 연결해주는 작업. DDNS (동적 DNS) 설정하기 # 가정용 인터넷은 대부분 IP 주소가 주기적으로 바뀌는 유동 IP를 사용합니다. IP 주소가 계속 바뀌면 외부에서 집을 찾아올 수 없으므로, DDNS(Dynamic Domain Name System) 기능을 사용해 이 유동 IP에 myserver.iptime.org 와 같은 고정된 \u0026lsquo;문자 주소(도메인)\u0026lsquo;를 연결해야 합니다. IP가 바뀌더라도 공유기가 DDNS 서버에 바뀐 IP를 자동으로 알려주어, 우리는 항상 고정된 도메인 주소로 접속할 수 있게 됩니다.\n공유기 관리 페이지 접속: 웹 브라우저 주소창에 192.168.0.1 (ipTIME 기준, 공유기마다 다를 수 있음)을 입력하여 공유기 관리 페이지에 로그인합니다. DDNS 설정 메뉴 이동: [고급 설정] \u0026gt; [특수 기능] \u0026gt; [DDNS 설정] 메뉴로 이동합니다. 호스트 이름 및 계정 등록: 호스트 이름: 원하는 주소를 입력합니다. (예: my-home-server) .iptime.org가 붙어 my-home-server.iptime.org 라는 최종 주소가 됩니다. 사용자 계정/암호: 사용할 이메일 주소와 암호를 입력합니다. [추가] 버튼을 누르고, 잠시 후 \u0026lsquo;접속 상태\u0026rsquo;에 \u0026ldquo;정상 등록\u0026rdquo; 메시지가 나타나는지 확인합니다.\n포트 포워딩 설정하기 # 이제 DDNS로 만든 도메인 주소로 들어온 요청을 내부 서버 PC로 연결해 줄 차례입니다. 예를 들어, 외부에서 http://my-home-server.iptime.org:8080 으로 접속했을 때, 이 요청을 내부 서버 PC(내부 IP: 192.168.0.10)의 웹 서비스 포트(80)로 연결해주는 것이 포트 포워딩입니다.\n내부 서버의 IP 주소 확인 및 고정:\n먼저, 외부 접속의 대상이 될 홈서버 PC의 내부 IP 주소를 확인해야 합니다. (ipconfig 또는 ifconfig 명령어 사용) 이 IP 주소가 바뀌지 않도록 공유기의 [DHCP 서버 설정] 메뉴에서 해당 PC의 MAC 주소에 IP를 고정 할당하는 것이 좋습니다. 포트 포워딩 메뉴 이동:\n[고급 설정] \u0026gt; [NAT/라우터 관리] \u0026gt; [포트포워드 설정] 메뉴로 이동합니다.\n규칙 추가:\n규칙 이름: 관리하기 쉬운 이름을 입력합니다. (예: 내 서버 웹, 원격데스크톱) 내부 IP 주소: 홈서버의 고정된 내부 IP 주소(예: 192.168.0.10)를 입력합니다. 프로토콜: 서비스에 맞는 프로토콜을 선택합니다. (보통 웹, FTP, 원격 데스크톱 등은 TCP) 외부 포트: 외부에서 접속할 때 사용할 포트 번호를 입력합니다. (예: 8080) 내부 포트: 서버 PC에서 실제 서비스가 실행되고 있는 포트 번호를 입력합니다. (예: 웹서버 80) [적용] 버튼을 눌러 규칙을 추가합니다.\n이제 모든 설정이 끝났습니다. 외부 네트워크(예: 스마트폰 LTE) 환경에서 웹 브라우저를 열고 http://my-home-server.iptime.org:8080 와 같이 접속하면, 집 안에 있는 서버의 웹 화면이 나타나는 것을 확인할 수 있습니다.\n※ 보안을 위한 중요 사항 # 서버를 외부에 개방하는 것은 해킹의 위험에 노출된다는 의미이기도 합니다. 아래의 기본적인 보안 수칙을 반드시 지켜주십시오.\n기본 포트 변경: 원격 데스크톱(3389), SSH(22) 등 잘 알려진 포트는 공격의 첫 번째 대상이 됩니다. 포트 포워딩 설정 시, 외부 포트는 3389 대신 33389 와 같이 추측하기 어려운 번호로 변경하는 것이 안전합니다.\n강력한 비밀번호 사용: 서버의 계정, 공유기 관리자 페이지 등의 비밀번호는 매우 복잡하게 설정하십시오.\nVPN 사용 고려: 더욱 안전한 접속을 원한다면, 공유기에서 제공하는 VPN 서버 기능을 활성화하여 외부에서 VPN으로 집에 먼저 접속한 뒤, 내부망처럼 서버를 이용하는 것이 가장 안전한 방법입니다.\n마무리하며 # DDNS와 포트 포워딩은 내 손으로 직접 서비스 환경을 구축하는 홈서버 운영의 첫걸음이자 가장 핵심적인 과정입니다. 처음에는 용어가 낯설 수 있지만, 이 가이드에 담긴 원리를 이해하고 차근차근 따라 해보신다면 분명 성공하실 수 있을 겁니다. 이제 여러분의 서버는 더 이상 집 안에 갇혀 있지 않고, 전 세계 어디서든 여러분의 손길을 기다리는 진정한 \u0026lsquo;개인 서버\u0026rsquo;가 되었습니다.\n","date":"5 July 2025","externalUrl":null,"permalink":"/posts/hosting/server/ddns-using-router/","section":"","summary":"","title":"공유기 설정으로 외부에서 홈서버 접속하기","type":"posts"},{"content":"이전 \u0026lsquo;Ubuntu 서버에 홈어시스턴트 설치 가이드\u0026rsquo; 글에 이어서 초기 설정을 진행해 보도록 하겠습니다.\n홈어시스턴트 설치를 마치고 처음 접속하면, 여러분의 스마트 홈을 위한 몇 가지 기본 설정 과정이 시작됩니다. 이 과정을 통해 관리자 계정을 만들고, 집의 위치를 설정하며, 첫 스마트 기기를 연동하게 됩니다.\n웹 브라우저로 접속 # 가장 먼저, 홈어시스턴트가 설치된 장치와 같은 네트워크에 있는 PC나 스마트폰에서 웹 브라우저를 열어주십시오. 주소창에 아래와 같은 형식으로 주소를 입력하여 접속합니다.\n접속 주소: http://[홈어시스턴트가 설치된 장치의 IP 주소]:8123 (예: http://192.168.1.10:8123)\n관리자 계정 생성 # 초기 접속 시 가장 먼저 보게 될 화면은 관리자 계정을 만드는 페이지입니다. 이 계정은 앞으로 홈어시스턴트의 모든 설정을 관리할 최고 권한을 갖게 됩니다.\n이름: 사용할 사용자 이름을 입력합니다. (예: 홍길동) 사용자 이름: 로그인 시 사용할 ID를 입력합니다. (예: gildong) 비밀번호 및 비밀번호 확인: 시스템 접근에 사용할 강력한 비밀번호를 설정합니다. 정보를 모두 입력한 뒤 [계정 만들기] 버튼을 클릭하여 다음 단계로 진행합니다. 지역 설정 및 정보 공유 # 다음으로 홈어시스턴트가 정확한 시간과 위치 기반 자동화를 수행할 수 있도록 지역 위치를 설정합니다.\n[다음] 을 눌러 계속 진행합니다.\n익명 정보 공유 설정 # 이 단계에서는 홈어시스턴트 개선을 위해 익명의 사용 통계, 진단 정보 등을 공유할지 선택합니다. 이는 전적으로 사용자의 선택에 달려 있습니다. 정보 공유에 동의하지 않아도 홈어시스턴트의 모든 기능을 사용하는 데 아무런 제약이 없습니다.\n원하는 항목을 선택하거나 선택하지 않고 [다음] 버튼을 클릭합니다.\n기기 검색 및 추가 # 이제 홈어시스턴트가 자동으로 여러분의 네트워크 안에서 호환되는 스마트 기기들을 검색합니다.\n화면에 자동으로 검색된 기기와 서비스 목록이 나타납니다. 목록에 나타난 기기는 바로 설정하거나, [완료] 버튼을 눌러 이 단계를 마치고 나중에 수동으로 추가할 수 있습니다.\n대시보드 구성하기 # 초기 설정을 완료하면 홈어시스턴트의 메인 화면인 대시보드로 이동합니다. 이곳은 모든 스마트 기기를 한눈에 보고 제어하는 관제탑과 같습니다.\n초기 상태: 처음에는 기본적인 정보만 표시되거나 비어있을 수 있습니다. 편집 모드: 우측 상단의 점 3개 메뉴 버튼을 누르고 [대시보드 편집] 을 선택하면, 대시보드를 자유롭게 꾸밀 수 있습니다. 카드 추가: 편집 모드에서 (+) 카드 추가 버튼을 눌러, 연동된 기기(조명, 센서, 스위치 등)를 제어하거나 상태를 표시하는 다양한 위젯(카드)을 추가할 수 있습니다. 자주 사용하는 기기들을 원하는 위치에 배치하여 자신만의 맞춤형 리모컨을 만들어 보십시오.\n마무리하며 # 이상으로 홈어시스턴트의 초기 설정부터 기본적인 대시보드 구성까지의 전 과정을 알아보았습니다. 이제 여러분은 스마트 홈을 제어하기 위한 모든 준비를 마쳤습니다.\n처음에는 몇 개의 기기만으로 시작하겠지만, 점차 다양한 장치를 추가하고 자동화를 설정하면서 이 대시보드는 점점 더 강력하고 편리한 여러분만의 공간으로 발전할 것입니다.\n","date":"5 July 2025","externalUrl":null,"permalink":"/posts/hosting/ha/initial-setup/","section":"","summary":"","title":"홈어시스턴트 초기 설정 및 대시보드 구성하기","type":"posts"},{"content":"오늘은 스마트 홈 구축의 첫걸음이라 할 수 있는 Ubuntu Server에 홈어시스턴트(Home Assistant)를 설치하는 모든 과정을 안내해 드리고자 합니다. 이 가이드 하나만으로 설치를 완벽하게 끝내실 수 있도록, 가장 핵심적인 내용을 상세히 다루겠습니다.\n차근차근 절차를 밟아나가시면, 누구나 성공적으로 자신만의 스마트 홈 허브를 구축하실 수 있을 겁니다.\n시작하기 전에: Docker 준비 # 이 가이드는 시스템에 도커(Docker)가 이미 설치된 것을 전제로 합니다. 도커는 홈어시스턴트를 컨테이너 환경에서 안정적으로 구동하기 위한 필수 프로그램입니다.\n만약 아직 도커를 설치하지 않으셨다면, 먼저 아래 링크의 가이드를 따라 설치를 완료하신 후 이 글의 다음 단계를 진행해 주시기 바랍니다.\nUbuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins 홈어시스턴트 설치: 두 가지 방법 중 선택 # 이제 홈어시스턴트를 설치할 차례입니다. 아래 두 가지 방법 중 하나를 선택하여 진행하십시오.\n방법 1: docker run - 간단하고 빠르게 컨테이너 하나를 실행하고 싶을 때 적합합니다. 방법 2: docker-compose - 설정 내용을 파일로 저장하여 장기적으로 관리하고 싶을 때 추천하는 방식입니다. docker run 명령어를 직접 사용하는 방법 # 가장 기본적인 방식입니다. 한 줄의 명령어로 홈어시스턴트를 즉시 실행할 수 있습니다.\n홈어시스턴트 설정 파일이 저장될 디렉터리를 생성합니다.\nmkdir ~/homeassistant/config 아래의 docker run 명령어를 터미널에 입력하여 홈어시스턴트를 실행합니다.\nsudo docker run -d \\ --name homeassistant \\ --privileged \\ --restart=unless-stopped \\ -v ~/homeassistant/config:/config \\ -v /run/dbus:/run/dbus:ro \\ -e TZ=Asia/Seoul \\ --network=host \\ ghcr.io/home-assistant/home-assistant:stable \u0026ndash;name homeassistant: 컨테이너의 이름을 \u0026lsquo;homeassistant\u0026rsquo;로 지정합니다. -v ~/homeassistant_config:/config: 호스트의 ~/homeassistant_config 디렉터리를 컨테이너의 /config에 연결하여 설정을 영구적으로 보존합니다. -v /run/dbus:/run/dbus:ro: 호스트의 블루투스 기능을 사용할수 있도록 연동합니다. \u0026ndash;network=host: 컨테이너가 호스트의 네트워크를 직접 사용하도록 설정하여 별도의 포트 설정 없이 8123 포트로 접근하게 합니다. docker-compose 파일을 사용하는 방법 (권장) # 설정 내용을 docker-compose.yml 파일로 저장하여 관리하므로, 재설치나 수정, 업데이트가 매우 편리합니다.\n홈어시스턴트 관리를 위한 디렉터리를 만들고 그 안으로 이동합니다.\nmkdir ~/homeassistant cd ~/homeassistant nano 와 같은 편집기로 docker-compose.yml 파일을 생성하고 아래 내용을 작성합니다.\nnano docker-compose.yml version: \u0026#39;3\u0026#39; services: homeassistant: container_name: homeassistant image: \u0026#34;ghcr.io/home-assistant/home-assistant:stable\u0026#34; volumes: - /PATH_TO_YOUR_CONFIG:/config - /etc/localtime:/etc/localtime:ro - /run/dbus:/run/dbus:ro restart: unless-stopped privileged: true network_mode: host docker run 명령어의 모든 옵션이 YAML 형식으로 보기 쉽게 정리되어 있습니다. volumes의 ./config:/config는 docker-compose.yml 파일이 위치한 곳에 config 폴더를 만들어 설정을 저장하겠다는 의미입니다. 작성이 완료되었다면, 아래 명령어로 홈어시스턴트를 실행합니다. -d는 백그라운드 실행 옵션입니다.\ndocker compose up -d docker-compose 관리 명령어:\n종료: docker compose down 업데이트: docker compose pull 실행 후, sudo docker compose up -d 실행 홈어시스턴트 초기 설정 # 위 두 가지 방법 중 어떤 것을 선택했더라도, 초기 설정 과정은 동일합니다.\n같은 네트워크에 있는 PC나 스마트폰의 웹 브라우저를 열고 주소창에 다음 주소를 입력합니다.\nhttp://[우분투 서버의 IP 주소]:8123 (예: http://192.168.0.10:8123) 화면에 나타나는 안내에 따라 관리자 계정을 생성하고, 집 위치 등 기본적인 정보를 입력하여 설정을 완료합니다.\n접속이 되지 않는다면? 방화벽 설정 # 우분투 서버에서 UFW(Uncomplicated Firewall)와 같은 방화벽을 사용하고 있다면, 외부에서 홈어시스턴트의 웹 인터페이스(8123 포트)에 접근할 수 있도록 허용 규칙을 추가해야 합니다.\nsudo ufw allow 8123/tcp 마무리하며 # 이것으로 우분투 서버에 도커를 이용한 홈어시스턴트 설치가 모두 완료되었습니다. docker run의 간편함과 docker-compose의 관리 용이성 사이에서 독자분께 더 적합한 방법을 선택하여 성공적으로 설치를 마치셨기를 바랍니다.\n참조\nHome Assistant 공식 설치 가이드 (www.home-assistant.io/installation/linux ) ","date":"5 July 2025","externalUrl":null,"permalink":"/posts/hosting/ha/install-using-docker/","section":"","summary":"","title":"Ubuntu 서버에 홈어시스턴트 설치하기","type":"posts"},{"content":"오늘은 macOS를 처음 사용하시거나 아직 익숙하지 않은 분들을 위해 실용적인 팁 하나를 알려드리고자 합니다. 바로 Finder에서 숨김 파일을 확인하고 다시 숨기는 방법입니다.\n컴퓨터를 사용하다 보면 시스템 파일이나 설정 파일처럼 평소에는 보이지 않던 파일들을 확인해야 할 때가 종종 있습니다. 오늘 이 글을 통해 그 방법을 명확하게 안내해 드리겠습니다.\n숨김 파일이란 무엇일까요? # macOS는 사용자의 실수로 중요한 시스템 파일이 변경되거나 삭제되는 것을 방지하기 위해 기본적으로 특정 파일과 폴더를 숨김 처리하여 화면에 표시하지 않습니다. 이러한 파일들은 대부분 시스템의 안정적인 구동에 필수적인 역할을 하므로, 일반적인 상황에서는 보이지 않는 것이 더 안전합니다.\n시스템 파일: macOS 운영체제가 작동하는 데 필요한 핵심 파일들입니다. 설정 파일: 특정 프로그램의 설정을 저장하는 파일들로, 보통 \u0026lsquo;.\u0026rsquo;(마침표)로 시작하는 이름을 가집니다. (예: .bash_profile, .DS_Store) Finder에서 숨김 파일 보는 방법 # 가장 간단하고 빠른 방법은 단축키를 사용하는 것입니다.\nFinder 앱을 실행하십시오. 숨김 파일을 확인하고 싶은 폴더로 이동합니다. (예: Macintosh HD, 홈 폴더, 응용 프로그램 등) 키보드에서 Command(⌘) + Shift + . (마침표) 키를 동시에 누릅니다. 단축키를 누르면 이전에는 보이지 않던 파일과 폴더들이 회색으로 흐리게 표시되는 것을 확인할 수 있습니다. 이것이 바로 숨김 처리된 항목들입니다. 숨김 파일을 다시 숨기는 방법 # 숨김 파일을 다시 보이지 않게 하는 방법 역시 간단합니다.\n숨김 파일이 표시된 상태의 Finder 창에서 다시 한번 Command(⌘) + Shift + . (마침표) 키를 동시에 누릅니다. 이 단축키는 토글(toggle) 방식으로 작동하여, 누를 때마다 숨김 파일 표시 상태와 숨김 상태를 전환합니다. ※ 주의사항 # 숨김 파일을 다룰 때는 각별한 주의가 필요합니다.\n임의로 수정하거나 삭제하지 마십시오: 숨겨진 파일들은 대부분 시스템 및 응용 프로그램의 정상적인 작동과 직접적으로 관련이 있습니다. 내용을 잘 알지 못하는 상태에서 파일을 수정하거나 삭제하면, 시스템에 심각한 오류가 발생하거나 특정 프로그램이 더 이상 실행되지 않을 수 있습니다. 필요한 작업 후에 다시 숨기십시오: 문제 해결이나 설정 변경 등 필요한 작업을 마쳤다면, 가급적 다시 숨김 처리하여 실수로 파일을 건드리는 일을 방지하는 것이 좋습니다. 마무리하며 # 오늘 안내해 드린 Command(⌘) + Shift + . 단축키는 macOS를 사용하면서 알아두면 매우 유용한 기능 중 하나입니다. 특히 시스템 설정에 직접 접근해야 하거나, 특정 프로그램의 깊이 있는 설정을 변경해야 할 때 큰 도움이 될 것입니다.\n이 글이 독자 여러분의 Mac 사용 경험을 한 단계 더 편안하게 만들어 드렸기를 바랍니다. 앞으로도 실질적이고 유용한 정보를 꾸준히 전달해 드리는 테크니컬 라이터가 되겠습니다.\n감사합니다.\n참조\nApple macOS 사용 설명서 ","date":"5 July 2025","externalUrl":null,"permalink":"/posts/apps/mac/finder-show-hidden-files/","section":"","summary":"","title":"Mac OS Finder에서 숨김 파일 보기/숨기기","type":"posts"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/tags/couchdb/","section":"Tags","summary":"","title":"Couchdb","type":"tags"},{"content":"디지털 세상에서 정보는 흩어지기 쉽습니다. 특히 여러 장치에서 노트를 작성하고 관리하는 분들이라면, 모든 기기에서 최신 정보를 유지하는 것이 얼마나 중요한지 공감하실 것입니다. 오늘은 Obsidian 사용자를 위한 강력한 동기화 솔루션인 Self-hosted LiveSync 플러그인을 소개하고, CouchDB를 이용해 직접 동기화 환경을 구축하는 방법을 안내해 드리고자 합니다. 이 글은 공식적인 유료 서비스인 Obsidian Sync를 대체할 수 있는 방법을 찾는 분들을 위해 작성되었습니다. 조금은 기술적인 내용이 포함될 수 있지만, 차근차근 따라 하실 수 있도록 최대한 쉽고 명확하게 설명해 드리겠습니다.\nSelf-hosted LiveSync 플러그인이란? # Self-hosted LiveSync는 Obsidian의 커뮤니티 플러그인 중 하나로, 사용자가 직접 제어하는 서버를 통해 노트 데이터를 거의 실시간으로 동기화할 수 있게 해주는 도구입니다. 공식 서비스와 달리 월별 비용이 발생하지 않으며, 데이터의 소유권을 온전히 사용자에게 보장한다는 큰 장점이 있습니다.\n동기화 서버로는 CouchDB, IBM Cloudant 등 호환되는 데이터베이스를 사용할 수 있으며, 이 가이드에서는 널리 사용되고 비교적 설정이 용이한 CouchDB를 기준으로 설명하겠습니다.\nCouchDB란?\nApache 소프트웨어 재단에서 개발한 오픈소스 NoSQL 데이터베이스입니다. 문서 지향 데이터베이스로, JSON 형식으로 데이터를 저장하여 웹 및 모바일 애플리케이션에서 유연하게 사용될 수 있습니다. 특히, 여러 장치 간의 데이터 복제 및 동기화 기능이 강력하여 LiveSync 플러그인의 백엔드로 적합합니다.\n사용 전 준비사항 # 플러그인을 설정하기에 앞서, 노트를 저장하고 동기화할 중앙 저장소, 즉 CouchDB 서버가 준비되어 있어야 합니다. CouchDB를 구축하는 방법은 다양하지만, 대표적으로 다음과 같은 방법들이 있습니다.\nDocker를 이용한 설치: 개인 서버나 NAS(Network Attached Storage)가 있다면 Docker를 이용해 손쉽게 CouchDB 컨테이너를 실행할 수 있습니다. 가장 안정적이고 추천되는 방법입니다.\n클라우드 플랫폼 활용 (예: fly.io): 클라우드 호스팅 서비스를 이용하여 CouchDB 인스턴스를 생성하고 외부에서 접속할 수 있도록 설정하는 방법입니다. 비교적 간단하게 시작할 수 있습니다.\nCouchDB의 설치는 아래의 글을 참조해 주세요\nubuntu 서버에 CouchDB 설치하기 4 July 2025\u0026middot;510 words\u0026middot;3 mins 이 가이드에서는 CouchDB 서버가 이미 구축되어 있고, 접속에 필요한 정보(주소, 사용자 이름, 비밀번호)를 알고 있다는 가정하에 설명을 진행합니다. CouchDB 서버 구축 방법은 사용하시는 환경에 따라 상이하므로, 별도의 가이드를 참조하여 주시기 바랍니다.\n동기화 설정을 진행하기 전에, 만일의 사태에 대비하여 기존의 Obsidian Vault(노트 저장소)를 반드시 백업해두시길 바랍니다. 이제 본격적으로 Obsidian에 Self-hosted LiveSync 플러그인을 설치하고 CouchDB 서버와 연동하는 방법을 단계별로 알아보겠습니다.\nSelf-hosted LiveSync 플러그인 설치 및 활성화 # Obsidian을 실행하고, 좌측 하단의 \u0026lsquo;설정\u0026rsquo; (톱니바퀴 아이콘)을 클릭합니다. 설정 창에서 \u0026lsquo;커뮤니티 플러그인\u0026rsquo; 탭으로 이동합니다. \u0026lsquo;안전 모드\u0026rsquo;가 활성화되어 있다면, \u0026lsquo;안전 모드 끄기\u0026rsquo; 버튼을 클릭하여 비활성화합니다. \u0026lsquo;커뮤니티 플러그인 탐색\u0026rsquo; 버튼을 클릭합니다. 검색창에 Self-hosted LiveSync를 입력하여 플러그인을 찾은 뒤, \u0026lsquo;설치\u0026rsquo; 버튼을 누릅니다. 설치가 완료되면 \u0026lsquo;활성화\u0026rsquo; 버튼을 클릭하여 플러그인을 활성화합니다. LiveSync 설정 및 CouchDB 연동 # 플러그인 활성화 후, 설정 메뉴의 \u0026lsquo;커뮤니티 플러그인\u0026rsquo; 목록 아래에 새로 생긴 \u0026lsquo;Self-hosted LiveSync\u0026rsquo; 탭을 클릭하여 설정 창으로 이동합니다.\n설정 창 상단에 여러 아이콘이 표시됩니다. 가장 왼쪽에 있는 위성(🛰️) 아이콘이 선택되었는지 확인합니다.\nCouchDB 데이터베이스 설정 정보를 입력하는 항목들이 나타납니다. 준비해 둔 CouchDB 서버 접속 정보를 각 항목에 맞게 정확히 입력합니다.\nURI: CouchDB 서버의 전체 주소를 입력합니다. (예: http://127.0.0.1:5984 또는 https://your-domain.com/couchdb) ⚠️주소 마지막에 /가 포함되지 않도록 주의하세오. Username: CouchDB 접속 시 사용하는 사용자 이름을 입력합니다. Password: CouchDB 접속 시 사용하는 비밀번호를 입력합니다. ⚠️ 이 비밀번호는 Obsidian Vault 내 설정 파일에 일반 텍스트로 저장됩니다. 보안에 유의하시기 바랍니다. Database name: 동기화를 위해 사용할 데이터베이스의 이름을 지정합니다. 임의로 지정할 수 있지만, 다른 기기에서도 동일한 이름을 사용해야 하므로 기억하기 쉬운 이름으로 설정하는 것이 좋습니다. (예: obsidian-notes) 정보를 모두 입력한 후, \u0026lsquo;Test database connection\u0026rsquo; 버튼을 클릭하여 서버와 정상적으로 연결되는지 확인합니다. 모든 항목에 녹색 체크 표시가 나타나면 성공입니다.\n필요에 따라 \u0026lsquo;End-to-end encryption\u0026rsquo; (종단간 암호화) 설정을 할 수 있습니다. 암호화 사용 시, 데이터를 보호할 추가 비밀번호를 설정하게 됩니다. 이 비밀번호는 CouchDB 서버에도 저장되지 않으며, 분실 시 데이터를 복구할 수 없으므로 반드시 안전한 곳에 보관해야 합니다.\n동기화 설정하기 # LiveSync를 선택한 후 Apply를 눌러줍니다. 동시 접속 문제로 동기화가 원활하지 않을 때는 Sync Mode를 Periodic and On Events로 바꿔 사용하는 것도 좋습니다.\n동기화 시작 및 확인 # CouchDB 설정이 완료되면, 에디터 우측 하단 상태바에 LiveSync 상태 아이콘이 나타납니다. 아이콘의 모양으로 현재 동기화 상태를 파악할 수 있습니다.\n💤 (잠자기): 동기화가 활성화되었으며, 파일 변경을 기다리는 상태입니다. ⚡️ (번개): 현재 동기화가 진행 중인 상태입니다. ⏹️ (정지): 동기화가 중지된 상태입니다. ⚠️ (경고): 오류가 발생한 상태입니다. 다른 기기(PC, 모바일)에도 동일한 방법으로 Obsidian과 LiveSync 플러그인을 설치하고, 반드시 동일한 CouchDB 접속 정보와 데이터베이스 이름, 그리고 암호화 비밀번호를 입력하여 설정을 완료합니다.\n설정이 완료된 후, 한 기기에서 노트를 수정하거나 새로 생성하면 잠시 후 다른 기기에도 해당 내용이 자동으로 반영되는 것을 확인할 수 있습니다.\n마무리 # 지금까지 Self-hosted LiveSync 플러그인과 CouchDB를 이용하여 자신만의 Obsidian 동기화 환경을 구축하는 방법에 대해 알아보았습니다. 처음에는 다소 복잡하게 느껴질 수 있지만, 이 가이드를 차근차근 따라오셨다면 성공적으로 설정을 마치셨으리라 믿습니다.\n직접 동기화 서버를 운영하는 것은 자신의 소중한 지식 자산을 온전히 통제하고 관리한다는 점에서 큰 의미가 있습니다. 이제 여러 장치를 넘나들며 끊김 없이 아이디어를 기록하고 발전시켜 나가시길 바랍니다.\n궁금한 점이나 막히는 부분이 있다면, 언제든 관련 커뮤니티나 문서를 참조하여 해결해 나가실 수 있을 것입니다. 여러분의 지식 여정에 이 글이 실질적인 도움이 되었기를 바랍니다.\n참고\nSelf-hosted LiveSync Plugin (Official GitHub ) Apache CouchDB (Official Website ) ","date":"5 July 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/obsidian-plugin-self-hoted-live-sync/","section":"","summary":"","title":"Obsidian Self-hosted LiveSync 플러그인과 CouchDB를 이용한 동기화 가이드","type":"posts"},{"content":"수많은 데이터베이스 중에서도, 이번에는 특별한 매력을 가진 Apache CouchDB를 알아보고, 우리가 이전에 배운 도커 컴포즈를 이용해 가장 간편하고 현명한 방법으로 설치해 보겠습니다.\nCouchDB란 무엇이며, 왜 사용할까요? # CouchDB는 Apache Software Foundation에서 개발하는 NoSQL 데이터베이스입니다. NoSQL은 전통적인 관계형 데이터베이스(RDBMS, 예: MySQL)의 테이블 구조가 아닌, 보다 유연한 방식으로 데이터를 저장하는 데이터베이스를 말합니다. CouchDB는 데이터를 JSON 문서(Document) 형태로 저장하는데, 이는 마치 서류 캐비닛에 파일을 정리하는 것과 비슷합니다.\n그렇다면 수많은 데이터베이스 중에서 CouchDB를 주목하는 이유는 무엇일까요?\n독보적인 데이터 동기화 기능 (Multi-Master Replication)\nCouchDB의 가장 강력한 특징입니다. 여러 대의 CouchDB 서버 혹은 클라이언트(모바일 기기 등)가 있을 때, 네트워크 연결이 끊겼다가 다시 연결되어도 알아서 데이터를 서로 복제하고 동기화합니다. 오프라인 상태에서도 앱이 정상적으로 작동해야 하는 \u0026lsquo;오프라인 우선(Offline-First)\u0026rsquo; 모바일 앱이나, 전 세계에 분산된 서버들이 데이터를 공유해야 하는 서비스, IoT 기기 데이터 수집 등에서 막강한 성능을 발휘합니다.\n웹 친화적인 구조 (HTTP API)\nCouchDB는 모든 통신을 웹 표준인 HTTP 프로토콜 위에서 수행합니다. 즉, 웹 브라우저나 curl 같은 간단한 명령어로도 데이터의 조회, 입력, 수정, 삭제(CRUD)가 모두 가능합니다. 이는 웹 개발자에게 매우 직관적이고 다루기 쉬운 환경을 제공합니다.\n유연한 데이터 모델\n엄격한 스키마(데이터 구조)를 미리 정의할 필요가 없습니다. 프로젝트를 진행하면서 필요한 필드를 자유롭게 추가하거나 변경할 수 있어, 변화가 잦은 초기 스타트업이나 애자일 환경의 프로젝트에 적합합니다.\n뛰어난 안정성과 내구성\n데이터를 저장할 때마다 이전 버전을 남겨두는 방식을 사용하여, 데이터베이스 파일이 손상되더라도 복구할 수 있는 능력이 뛰어납니다.\n솔직히 말해, CouchDB가 MongoDB나 PostgreSQL처럼 시장을 지배하는 주류 데이터베이스는 아닐 수 있습니다. 하지만 위에서 언급한 독보적인 동기화 기능 덕분에, 특정 분야에서는 그 어떤 데이터베이스보다 뛰어난, \u0026lsquo;대체 불가능한 강력한 조연\u0026rsquo; 같은 역할을 톡톡히 해내고 있습니다.\nDocker Compose로 CouchDB 설치하기 # 이제 docker compose를 이용해 CouchDB를 1분 만에 설치해 보겠습니다. 이 방법은 여러분의 PC를 깨끗하게 유지하면서, 필요할 때마다 명령어 한 줄로 데이터베이스를 실행하고 중지할 수 있는 가장 효율적인 방법입니다.\ndocker-compose.yml 파일 작성하기 # 프로젝트 폴더를 하나 만들고, 그 안에 docker-compose.yml 이라는 이름의 파일을 생성한 후 아래 내용을 입력하십시오.\nversion: \u0026#39;3.8\u0026#39; services: couchdb: image: apache/couchdb:3.3.3 container_name: my-couchdb restart: always environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=password ports: - \u0026#34;5984:5984\u0026#34; volumes: - couchdb-data:/opt/couchdb/data volumes: couchdb-data: image: apache/couchdb:3.3.3: CouchDB 공식 이미지를 사용합니다. environment: CouchDB에 접속할 관리자 계정(admin)과 비밀번호(password)를 설정합니다. ports: - \u0026quot;5984:5984\u0026quot;: 내 컴퓨터의 5984번 포트를 컨테이너의 5984번 포트와 연결합니다. CouchDB는 5984 포트를 사용합니다. volumes: 컨테이너가 삭제되더라도 데이터베이스의 데이터는 사라지지 않도록 couchdb-data 라는 볼륨에 영구적으로 저장합니다. 이것은 매우 중요한 설정입니다. 실제 운영 환경에서는 절대 이렇게 간단한 비밀번호를 사용해서는 안 됩니다. CouchDB 실행하기 🚀 # docker-compose.yml 파일이 있는 폴더에서 터미널을 열고 다음 명령어를 입력하십시오.\ndocker compose up -d -d 옵션은 컨테이너를 백그라운드에서 조용히 실행하라는 의미입니다.\n설치 확인하기 # 이제 CouchDB가 정상적으로 실행되고 있는지 확인해볼 차례입니다.\n웹 관리 도구 접속\n웹 브라우저를 열고 http://localhost:5984/_utils/ 주소로 접속하십시오.\ndocker-compose.yml 파일에 설정했던 사용자 이름(admin)과 비밀번호(password)를 입력하고 로그인했을 때, 데이터베이스 관리 화면이 나타난다면 성공입니다.\n터미널에서 curl로 확인\n터미널에 다음 명령어를 입력해 보십시오.\ncurl http://admin:password@localhost:5984/ {\u0026quot;couchdb\u0026quot;:\u0026quot;Welcome\u0026quot;,\u0026quot;version\u0026quot;:\u0026quot;3.3.3\u0026quot;, ...} 와 같이 CouchDB의 환영 메시지가 JSON 형태로 출력된다면 성공적으로 설치되고 실행 중인 것입니다.\n맺음말 # 수고하셨습니다. 여러분은 이제 복잡한 설치 과정 없이, 단 하나의 설정 파일과 명령어 한 줄만으로 강력한 NoSQL 데이터베이스인 CouchDB를 여러분의 개발 환경에 구축했습니다.\n이제 여러분의 애플리케이션 컨테이너에서 이 CouchDB 컨테이너로 접속하여 데이터를 저장하고 조회하는 작업을 수행할 수 있습니다. 이것이 바로 여러 개의 컨테이너가 서로 협력하며 하나의 서비스를 만들어나가는, 도커 컴포즈의 진정한 힘입니다.\n","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/couchdb-service/","section":"","summary":"","title":"ubuntu 서버에 CouchDB 설치하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/minidlna/","section":"Tags","summary":"","title":"Minidlna","type":"tags"},{"content":"집안의 다양한 기기, 예를 들어 스마트 TV, 게임 콘솔, 스마트폰에서 PC나 서버에 저장된 영상, 음악, 사진을 손쉽게 즐기고 싶을 때가 많습니다. 이번 글에서는 Ubuntu(우분투) 서버에 MiniDLNA를 설치하여 간단하면서도 강력한 DLNA(Digital Living Network Alliance) 미디어 서버를 구축하는 방법을 안내해 드리겠습니다.\nMiniDLNA란? # MiniDLNA(현재는 ReadyMedia라는 이름으로도 불립니다) 는 이름에서 알 수 있듯이 아주 가벼운 DLNA 서버 소프트웨어입니다. 복잡한 기능 없이 DLNA의 핵심 기능에만 충실하여 시스템 자원을 매우 적게 소모하는 것이 가장 큰 장점입니다. 저사양의 홈서버나 NAS(Network Attached Storage)에서도 부담 없이 운영할 수 있으며, 설정이 간단하여 초보자도 쉽게 미디어 서버를 구축할 수 있습니다.\nDLNA는 제조사가 다른 전자기기끼리도 미디어 콘텐츠를 자유롭게 공유할 수 있도록 만들어진 규격입니다. 따라서 MiniDLNA 서버를 구축해두면, 같은 네트워크에 연결된 대부분의 스마트 TV나 플레이스테이션 등에서 별도의 클라이언트 앱 설치 없이도 서버의 파일을 바로 재생할 수 있습니다.\nMiniDLNA 패키지 설치 # 이제 본격적으로 MiniDLNA 서버 구축을 시작하겠습니다. 먼저, Ubuntu 서버에 MiniDLNA 패키지를 설치합니다. 터미널을 열고 아래 명령어를 순서대로 입력하십시오.\nsudo apt update sudo apt install minidlna 설치가 끝나면 자동으로 MiniDLNA 서비스가 시작됩니다. 다음 명령어로 정상 실행 여부를 확인할 수 있습니다.\nsystemctl status minidlna 미디어 디렉터리 지정 # MiniDLNA가 어떤 폴더의 파일들을 공유할지 알려주어야 합니다. 설정 파일인 /etc/minidlna.conf를 수정하여 미디어 디렉터리를 지정합니다.\n수정하기에 앞서 원본 설정 파일을 백업해두는 것이 안전합니다.\nsudo cp /etc/minidlna.conf /etc/minidlna.conf.bak nano와 같은 텍스트 편집기로 설정 파일을 엽니다.\nsudo nano /etc/minidlna.conf 파일 내용 중에서 media_dir 항목을 찾습니다. 이 부분이 미디어 파일이 위치한 경로를 지정하는 곳입니다. 기본적으로 주석 처리( # 기호로 시작) 되어 있으니, 주석을 제거하고 경로를 수정해야 합니다.\n예를 들어, 영상은 /data/videos, 음악은 /data/music, 사진은 /data/pictures 폴더에 저장되어 있다면 다음과 같이 설정합니다.\n# Path to the directory you want scanned for media files. # # This option can be specified more than once if you want to scan # multiple directories. # # If you want to restrict a media_dir to a specific content type, you # can prepend the type (\u0026#39;A\u0026#39; for audio, \u0026#39;V\u0026#39; for video, \u0026#39;P\u0026#39; for # picture) followed by a comma to the directory (e.g. media_dir=V,/var/lib/video). media_dir=V,/data/videos media_dir=A,/data/music media_dir=P,/data/pictures V,는 비디오, A,는 오디오, P,는 사진 전용 폴더임을 명시하는 것입니다. 이렇게 타입을 지정하면 MiniDLNA가 더 효율적으로 파일을 분류합니다. 경로는 각자 미디어 파일을 저장해 둔 실제 경로로 변경해야 합니다. (선택 사항) 서버의 이름을 변경하고 싶다면 friendly_name 항목을 찾아 수정합니다. 이 이름이 클라이언트 기기에 표시됩니다.\n# Name that the DLNA server presents to clients. friendly_name=My Home Media 수정이 완료되면 Ctrl+X, Y, Enter를 차례로 눌러 저장하고 편집기를 종료합니다.\n방화벽 설정 # 서버에 UFW 방화벽이 활성화된 경우, DLNA 클라이언트가 서버를 찾고 접속할 수 있도록 관련 포트를 허용해야 합니다.\nsudo ufw allow 1900/udp sudo ufw allow 8200/tcp 1900/udp: 클라이언트가 네트워크에서 DLNA 서버를 발견(Discovery)하기 위해 사용하는 포트입니다. 8200/tcp: 발견된 서버의 파일 목록에 접근하고 스트리밍하기 위해 사용하는 포트입니다. 서비스 재시작 및 라이브러리 갱신 # 설정 변경 사항을 적용하고, 미디어 파일을 스캔하여 라이브러리를 구축하도록 서비스를 재시작합니다.\nsudo systemctl restart minidlna 만약 새로운 미디어 파일을 추가한 후 즉시 라이브러리에 반영하고 싶다면, 다음 명령어로 강제 갱신을 할 수 있습니다.\nsudo service minidlna force-reload 클라이언트에서 접속 확인 # 이제 서버 설정은 모두 끝났습니다. 스마트 TV나 스마트폰의 DLNA 지원 앱(예: VLC media player, BubbleUPnP 등)을 실행하여 미디어 서버를 검색해 보십시오.\nminidlna.conf 파일에서 설정한 friendly_name(예: My Home Media)을 가진 서버가 목록에 나타날 것입니다. 해당 서버를 선택하면 지정해 둔 비디오, 오디오, 사진 폴더에 접근하여 파일을 스트리밍으로 감상할 수 있습니다.\n마무리 # MiniDLNA는 복잡한 설정 없이도 누구나 손쉽게 개인 미디어 서버를 구축할 수 있게 해주는 훌륭한 도구입니다. 이 가이드를 통해 여러분의 홈 네트워크 환경이 더욱 풍요로워지기를 바랍니다. 서버에 새로운 영화나 음악을 추가하고, 거실 소파에 편히 앉아 TV로 바로 감상하는 편리함을 누려보십시오.\n궁금하신 점은 언제든 질문 주시면 제가 아는 선에서 최대한 도와드리겠습니다.\n참조\nReadyMedia (Formerly MiniDLNA) 프로젝트 페이지: https://sourceforge.net/projects/minidlna/ Ubuntu 공식 문서: https://help.ubuntu.com/community/MiniDLNA ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/dlna-server-using-minidlna/","section":"","summary":"","title":"Ubuntu 서버에 MiniDLNA로 미디어 서버 구축하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/smb/","section":"Tags","summary":"","title":"Smb","type":"tags"},{"content":"여러 장치 간에 파일을 공유하는 가장 확실하고 안정적인 방법 중 하나는 파일 서버를 구축하는 것입니다. 이번 글에서는 Ubuntu(우분투) 환경에서 Samba(삼바)를 이용하여 윈도우, macOS, 리눅스 등 다양한 운영체제와 파일을 공유할 수 있는 서버를 구축하는 방법을 안내해 드리겠습니다.\nSamba(삼바)란? # Samba는 윈도우 운영체제에서 사용하는 파일 공유 프로토콜인 SMB/CIFS를 리눅스나 유닉스 계열 운영체제에서도 사용할 수 있도록 해주는 소프트웨어입니다. Samba를 이용하면 리눅스 서버에 공유 폴더를 만들어두고, 윈도우 탐색기에서 마치 로컬 드라이브처럼 접속하여 파일을 읽고 쓸 수 있게 됩니다. 홈서버나 사무실 환경에서 중앙 데이터 저장소로 활용하기에 매우 적합합니다.\nSamba 설치 및 설정 # Samba 패키지 설치 # 가장 먼저 할 일은 서버에 Samba 패키지를 설치하는 것입니다. 터미널에서 다음 명령어를 차례로 실행하여 패키지 목록을 최신화하고 Samba를 설치합니다.\nsudo apt update sudo apt install samba 설치가 완료되면 다음 명령어로 Samba 서비스의 상태를 확인하여 정상적으로 실행 중인지 점검합니다.\nsystemctl status smbd 공유할 디렉터리 생성 # 다음으로 클라이언트와 공유할 디렉터리를 생성합니다. 여기서는 예시로 /home/\u0026lt;user\u0026gt;/share 경로에 디렉터리를 만들겠습니다. \u0026lt;user\u0026gt; 실제 사용자의 계정으로 변경해주시면 됩니다.\nsudo mkdir -p /home/\u0026lt;user\u0026gt;/share Samba 설정 파일 수정 # Samba의 핵심 설정은 /etc/samba/smb.conf 파일에서 이루어집니다. 원본 설정을 보존하기 위해 파일을 백업한 후, 편집을 시작하겠습니다.\n사용자 추가\nsudo smbpasswd -a $USER 현재 사용자 계정으로 samba에 접속할 수 있도록 계정과 비밀번호를 설정해 줍니다.\n설정 파일 백업\nsudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak 설정 파일 편집 (nano 편집기 사용 예시)\nsudo nano /etc/samba/smb.conf smb.conf 파일의 가장 아래쪽에 다음 내용을 추가합니다. 이것이 우리가 생성한 공유 폴더에 대한 정의입니다.\n[share] comment = Samba Share path = /srv/samba/share read only = no browsable = yes guest ok = \bno [share]: 클라이언트에서 보이게 될 공유 폴더의 이름입니다. 원하는 이름으로 변경할 수 있습니다. comment: 공유 폴더에 대한 간단한 설명입니다. path: 2단계에서 생성한 실제 공유 디렉터리의 경로입니다. read only = no: \u0026lsquo;아니오\u0026rsquo;로 설정해야 파일을 쓸 수 있습니다. 읽기 전용으로 하려면 yes로 변경합니다. browsable = yes: 파일 탐색기에서 해당 공유 폴더가 보이도록 설정합니다. guest ok = no: 인증된 사용자만 접속하게 하려면 이 항목을 \bno로 설정합니다. yes인 경우 별도의 사용자 인증 없이 손님(guest) 계정으로 접근을 허용합니다. 설정 파일의 문법에 오류가 없는지 다음 명령어로 확인합니다.\ntestparm \u0026lsquo;Loaded services file OK.\u0026rsquo; 메시지가 나타나면 정상입니다.\n수정한 설정을 적용하기 위해 Samba 서비스를 재시작합니다.\nsudo systemctl restart smbd sudo systemctl restart nmbd 방화벽 설정 # Ubuntu에 UFW(Uncomplicated Firewall) 방화벽이 활성화되어 있다면 Samba가 사용하는 포트를 허용해 주어야 합니다.\nsudo ufw allow samba 이 명령어 하나로 Samba에 필요한 포트들이 자동으로 허용됩니다.\n클라이언트에서 접속하기 # 윈도우 PC에서 # 윈도우 PC에서 접속하여 파일이 정상적으로 공유되는지 확인해 보겠습니다.\n키보드에서 Win + R 키를 눌러 실행창을 엽니다. \\\\[서버 IP 주소]를 입력하고 \u0026lsquo;확인\u0026rsquo;을 누릅니다. 예를 들어 서버 IP가 192.168.0.10이라면 \\\\192.168.0.10을 입력합니다. 사용자의 계정과 설정한 비밀 번호를 입력합니다. 탐색기 창이 열리면서 앞서 smb.conf에서 설정한 share 폴더가 보일 것입니다. Mac OS에서 접속하기 # Mac OS에서 접속하여 파일이 정상적으로 공유되는지 확인해 보겠습니다.\nFinder나 바탕화면에서 Command(⌘) + K를 누릅니다. \\\\[서버 IP 주소]를 입력하고 \u0026lsquo;확인\u0026rsquo;을 누릅니다 사용자의 계정과 설정한 비밀 번호를 입력합니다. Finder 창이 열리면서 앞서 smb.conf에서 설정한 share 폴더가 보일 것입니다. 폴더에 들어가서 새 파일을 만들거나 파일을 복사하여 서버에 정상적으로 저장이 되는지 확인합니다.\n마무리 (사용자 인증 설정) # Samba를 이용하면 리눅스 환경에 익숙하지 않은 사용자도 윈도우 환경에서 손쉽게 서버의 파일에 접근할 수 있어 매우 유용합니다. 이 글이 여러분의 데이터 관리 환경을 개선하는 데 도움이 되기를 바랍니다.\n참조\nSamba 공식 위키: https://wiki.samba.org/ Ubuntu 공식 문서: https://ubuntu.com/server/docs/samba-file-server ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/smb-file-server/","section":"","summary":"","title":"Ubuntu에서 Samba 파일 서버 운영하기","type":"posts"},{"content":"홈서버를 운영하며 Docker를 활용해 다양한 서비스를 구축하는 일은 이제 보편적인 일이 되었습니다. 이번 글에서는 여러 토렌트 클라이언트 중에서도 많은 분이 애용하시는 Transmission을 Docker 환경에 설치하는 방법을 안내해 드리고자 합니다.\nTransmission을 사용하는 이유 # Transmission은 다른 토렌트 클라이언트에 비해 여러 가지 장점을 가지고 있습니다.\n가볍고 빠른 속도\nTransmission은 시스템 자원을 적게 소모하여 저사양의 홈서버나 NAS(Network Attached Storage)에서도 부담 없이 운영할 수 있습니다. 불필요한 기능 없이 핵심적인 기능에 집중하여 가볍고 빠른 성능을 자랑합니다.\n직관적인 웹 인터페이스\n별도의 클라이언트 프로그램 설치 없이 웹 브라우저만으로 모든 기능을 제어할 수 있습니다. 스마트폰이나 태블릿 등 어떤 기기에서든 쉽게 접속하여 토렌트 파일을 추가하고 관리할 수 있어 편리합니다.\n뛰어난 안정성\n오랜 기간 개발되어 온 만큼 안정성이 매우 뛰어납니다. 예기치 않은 오류나 시스템 중단 없이 꾸준하게 파일을 주고받을 수 있습니다.\n이러한 장점들 덕분에 Transmission은 홈서버 환경에서 가장 선호되는 토렌트 클라이언트 중 하나로 자리 잡았습니다.\n설치 전 준비 사항 # 본격적인 설치에 앞서, 다음 사항이 준비되어 있어야 합니다.\nDocker가 설치된 환경\n여기서는 Docker가 이미 시스템에 설치되어 있다는 것을 전제로 진행합니다. Docker 설치 방법은 아래 포스트를 확인해 주세요.\nUbuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins 데이터를 저장할 디렉터리 생성\n다운로드한 파일과 설정 파일을 저장할 디렉터리를 미리 만들어 두어야 합니다. 이는 컨테이너가 삭제되더라도 데이터를 보존하기 위함입니다. 터미널에서 다음 명령어를 사용하여 디렉터리를 생성하는 것을 권장합니다.\nmkdir -p /path/to/your/storage/transmission/config mkdir -p /path/to/your/storage/transmission/downloads mkdir -p /path/to/your/storage/transmission/watch /path/to/your/storage/ 부분은 실제 데이터를 저장하고자 하는 경로로 변경해 주십시오. (예: /home/user/docker/transmission) config: Transmission의 설정 파일이 저장될 공간입니다. downloads: 다운로드가 완료된 파일이 저장될 공간입니다. watch: 이 디렉터리에 토렌트 파일을 넣어두면 Transmission이 자동으로 다운로드를 시작합니다. Docker를 이용한 Transmission 설치 # Docker를 이용하여 Transmission을 설치하는 방법은 docker run 명령어를 직접 사용하는 방법과 docker-compose를 이용하는 방법이 있습니다. 여기서는 두 가지 방법을 모두 안내해 드리겠습니다.\ndocker run 명령어를 이용한 설치 # 터미널을 열고 다음 명령어를 입력하여 Transmission 컨테이너를 생성하고 실행합니다.\ndocker run --name=transmission \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Seoul \\ -p 9091:9091 \\ -p 51413:51413 \\ -p 51413:51413/udp \\ -v /path/to/your/storage/transmission/config:/config \\ -v /path/to/your/storage/transmission/downloads:/downloads \\ -v /path/to/your/storage/transmission/watch:/watch \\ --restart unless-stopped \\ linuxserver/transmission 각 옵션의 의미를 정확히 이해하고 사용하시는 것이 중요합니다. --name=transmission: 컨테이너의 이름을 transmission으로 지정합니다. -e PUID=1000 / -e PGID=1000: 컨테이너 내에서 실행되는 프로세스의 사용자 ID와 그룹 ID를 지정합니다. id 명령어를 터미널에 입력하여 현재 사용자의 UID와 GID 값을 확인하고 그에 맞게 수정해 주십시오. 이는 파일 권한 문제 발생을 예방합니다. -e TZ=Asia/Seoul: 컨테이너의 시간대를 서울로 설정합니다. -p 9091:9091: 웹 인터페이스 접속을 위한 포트입니다. 외부 포트(왼쪽)와 내부 포트(오른쪽)를 연결합니다. -p 51413:51413 / -p 51413:51413/udp: 토렌트 데이터 교환을 위한 포트입니다. TCP와 UDP 프로토콜을 모두 열어줍니다. -v /path/to/your/storage/... : 앞서 생성한 호스트의 디렉터리와 컨테이너 내부의 디렉터리를 연결(마운트)합니다. --restart unless-stopped: 시스템이 재시작되더라도 사용자가 직접 정지시키지 않는 한 컨테이너가 자동으로 다시 시작되도록 설정합니다. linuxserver/transmission: 설치할 Docker 이미지의 이름입니다. linuxserver.io 그룹에서 제공하는 이미지는 안정성과 편의성이 높아 많은 사용자가 선호합니다. docker-compose를 이용한 설치 # docker-compose는 여러 컨테이너를 정의하고 실행하기 위한 도구로, 설정 파일을 통해 관리하므로 더 편리합니다.\n원하는 위치에 docker-compose.yml 파일을 생성하고 아래 내용을 입력합니다.\nversion: \u0026#34;2.1\u0026#34; services: transmission: image: lscr.io/linuxserver/transmission:latest container_name: transmission environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul volumes: - /path/to/your/storage/transmission/config:/config - /path/to/your/storage/transmission/downloads:/downloads - /path/to/your/storage/transmission/watch:/watch ports: - 9091:9091 - 51413:51413 - 51413:51413/udp restart: unless-stopped docker-compose.yml 파일이 저장된 폴더에서 다음 명령어를 실행합니다.\ndocker compose up -d -d 옵션은 컨테이너를 백그라운드에서 실행하도록 합니다. Transmission 접속 및 초기 설정 # 컨테이너 실행이 완료되었다면 이제 웹 브라우저를 통해 Transmission에 접속할 수 있습니다.\n웹 브라우저 주소창에 http://[서버 IP 주소]:9091을 입력합니다. 최초 접속 시 인증을 요구하는 창이 나타날 수 있습니다. linuxserver/transmission 이미지의 경우, 초기 사용자 이름과 비밀번호는 대부분 transmission 입니다. 접속 후, 화면 하단의 설정(스패너 모양 아이콘) 버튼을 클릭하여 몇 가지 중요한 설정을 변경하는 것이 좋습니다. Peers 탭: Peer listening port가 51413으로 설정되어 있는지 확인하고, Use port forwarding from my router 옵션을 활성화하는 것이 좋습니다. 공유기를 사용하신다면 해당 포트에 대한 포트 포워딩 설정을 해주어야 원활한 속도를 확보할 수 있습니다. RPC 탭: 보안을 위해 Authentication required에 체크하고, Username과 Password를 자신만의 것으로 변경하십시오. 마무리 # 지금까지 Docker를 이용하여 Transmission 토렌트 클라이언트를 설치하고 기본적인 설정을 진행하는 방법에 대해 알아보았습니다. Docker를 활용하면 이처럼 복잡한 과정 없이 몇 가지 명령어만으로 강력한 서비스를 손쉽게 구축할 수 있습니다.\n이 글이 여러분의 성공적인 홈서버 운영에 작은 보탬이 되기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해 주십시오. 제가 아는 범위 내에서 성심껏 답변해 드리겠습니다.\n참조\nDocker Hub - linuxserver/transmission: https://hub.docker.com/r/linuxserver/transmission Transmission 공식 홈페이지: https://transmissionbt.com/ ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/transmission-server/","section":"","summary":"","title":"Ubuntu 홈서버에 Docker로 Transmission 설치하기","type":"posts"},{"content":"아마 도커 명령어를 실행할 때마다 매번 sudo를 입력하는 것이 다소 번거롭게 느껴지셨을 겁니다. 이는 기본적으로 도커 데몬(Docker Daemon)이 루트(root) 권한으로 실행되기 때문에, 일반 사용자 계정으로 도커를 제어하려면 관리자 권한을 획득하는 sudo가 필요한 것입니다.\n이번 글에서는 docker 그룹에 현재 사용자를 추가하여 sudo 없이 도커 명령어를 실행하는 방법과, 이 작업이 가지는 보안상 의미에 대해 정확히 알려드리겠습니다.\n왜 sudo를 생략하고 싶을까요? # 가장 큰 이유는 \u0026lsquo;편의성\u0026rsquo; 입니다. 개발 과정에서 수없이 많은 docker 명령어를 입력하게 되는데, 이때마다 sudo를 붙이는 것은 번거로울 뿐만 아니라 비밀번호를 반복적으로 입력해야 할 수도 있습니다. docker 그룹에 사용자를 추가하면 이러한 불편함을 해소하고, 마치 일반 명령어처럼 docker ps, docker images 등을 바로 사용할 수 있습니다.\n하지만 편의성에는 항상 뒤따르는 책임이 있습니다. 이 점을 염두에 두시고 다음 단계를 진행해 주십시오.\ndocker 그룹에 현재 사용자 추가하기 # 리눅스에서 docker 그룹은 도커 엔진 설치 시 자동으로 생성됩니다. 우리는 이 그룹에 현재 로그인된 사용자를 포함시키기만 하면 됩니다.\ndocker 그룹에 사용자 추가 # 터미널을 열고 다음 명령어를 입력하십시오. 이 명령어는 docker라는 그룹(-G docker)에 현재 사용자($USER)를 추가(-a)하는 명령어입니다. $USER는 시스템에 현재 로그인된 사용자 이름으로 자동 치환되는 환경 변수입니다.\nsudo usermod -aG docker $USER 변경 사항 시스템에 적용하기 # 위 명령어를 실행했다고 해서 바로 sudo 없이 docker 명령어를 사용할 수 있는 것은 아닙니다. 그룹 변경 사항을 현재 사용자 세션에 적용하기 위해 시스템에서 로그아웃한 후 다시 로그인하거나, 시스템을 재부팅해야 합니다.\n또는, 다음 명령어를 사용하여 새 그룹 멤버십을 즉시 활성화할 수도 있습니다.\nnewgrp docker 하지만 가장 확실하고 권장되는 방법은 로그아웃 후 다시 로그인하는 것입니다.\n반드시 알아야 할 보안상 의미 # sudo를 생략하는 편리함을 얻는 대신, 우리는 보안 측면에서 매우 중요한 권한을 사용자 계정에 부여하게 됩니다.\ndocker 그룹의 멤버가 된다는 것은, 사실상 시스템의 루트(root) 권한을 직접 얻는 것과 동일한 수준의 권한을 갖게 됨을 의미합니다. 왜냐하면 도커는 호스트 시스템과 파일을 공유하거나(-v 옵션), 호스트의 네트워크를 직접 사용하는 등 시스템 깊숙한 영역을 제어할 수 있기 때문입니다.\n예를 들어, docker 그룹에 속한 사용자는 다음과 같은 명령어를 통해 호스트의 모든 파일에 접근할 수 있는 루트 셸(root shell)을 컨테이너 내부에 띄울 수 있습니다.\ndocker run -v /:/host -it --entrypoint /bin/bash ubuntu 이것이 의미하는 바는, 만약 여러분의 사용자 계정이 어떤 이유로든 탈취당한다면 공격자는 sudo 비밀번호 없이도 시스템 전체를 장악할 수 있다는 것입니다.\n따라서 이 방법은 개인 개발용 컴퓨터나 보안이 통제된 신뢰할 수 있는 환경에서만 사용하시기를 강력히 권고합니다. 여러 사람이 함께 사용하는 프로덕션 서버나 중요한 시스템에서는 각별한 주의가 필요하며, sudo를 사용하는 기본 정책을 유지하는 것이 더 안전할 수 있습니다.\n적용 결과 확인하기 # 시스템에 다시 로그인했다면, 이제 sudo 없이 도커 명령어가 잘 실행되는지 확인해볼 차례입니다. 터미널을 열고 다음 명령어를 입력해 보십시오.\ndocker ps 만약 \u0026ldquo;permission denied\u0026quot;와 같은 오류 메시지 없이 위와 같이 정상적으로 결과가 출력된다면, 모든 설정이 성공적으로 완료된 것입니다.\n맺음말 # 이제 여러분은 sudo의 번거로움에서 벗어나 훨씬 편리하게 도커를 사용하실 수 있게 되었습니다. 하지만 오늘 함께 알아본 보안상의 의미를 항상 기억해 주시길 바랍니다. 기술의 편리함을 누리는 만큼, 그 기술이 시스템에 미치는 영향을 이해하고 책임감 있게 사용하는 자세는 좋은 개발자에게 반드시 필요한 덕목입니다.\n","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/docker-without-sudo/","section":"","summary":"","title":"sudo 없이 Docker 명령어 사용하기","type":"posts"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu","type":"tags"},{"content":"지난번에는 도커(Docker)가 무엇이고 왜 필요한지에 대해 알아보았습니다. 개념을 이해했다면 이제 직접 내 손으로 설치하고 실행해 볼 차례입니다.\n이번 글에서는 가장 널리 사용되는 리눅스 배포판 중 하나인 Ubuntu에 도커를 설치하는 과정을 안내해 드리고자 합니다. 처음 리눅스 환경에서 무언가를 설치하는 분들도 쉽게 따라 하실 수 있도록, 명령어 하나하나의 의미를 짚어가며 최대한 상세하게 설명하겠습니다. 저와 함께 차근차근 진행해 보십시오.\n기존 도커 패키지 정리하기 # 혹시라도 시스템에 예전에 설치되었거나 비공식적으로 설치된 도커 관련 패키지가 남아있다면, 충돌을 방지하기 위해 먼저 깨끗하게 삭제하는 것이 좋습니다. 아래 명령어를 터미널에 입력하여 관련 패키지들을 제거해 주십시오.\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done 이 명령어를 실행했을 때 \u0026ldquo;Package \u0026lsquo;xxx\u0026rsquo; is not installed, so not removed\u0026quot;는 메시지가 나와도 괜찮습니다. 시스템을 가장 깔끔한 상태에서 시작하기 위한 예방 조치이므로 안심하고 다음 단계로 넘어가시면 됩니다.\n※ 주의: 이 명령어는 /var/lib/docker/ 디렉터리에 저장된 기존의 이미지, 컨테이너, 볼륨 등은 삭제하지 않습니다. 도커 공식 GPG 키 추가하기 # 도커는 공식적으로 안전성이 검증된 패키지만 설치하도록 권장합니다. 이를 위해, 우리가 설치하려는 패키지가 도커에서 공식적으로 배포한 것이 맞는지 인증하는 과정을 거쳐야 합니다. GPG(GNU Privacy Guard) 키는 이 인증을 위한 \u0026lsquo;공식 인증서\u0026rsquo;와 같은 역할을 합니다.\n아래 명령어들을 순서대로 실행하여 도커의 공식 GPG 키를 다운로드하고 시스템에 등록하십시오.\n필수 패키지 설치 # GPG 키를 추가하고 APT 저장소를 HTTPS를 통해 사용할 수 있도록 관련 도구들을 설치합니다.\nsudo apt-get update sudo apt-get install ca-certificates curl GPG 키를 저장할 디렉터리 생성 # sudo install -m 0755 -d /etc/apt/keyrings 도커 공식 GPG 키 다운로드 # curl 명령어를 사용해 GPG 키를 다운로드한 후, 지정된 위치에 저장합니다.\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc 도커 APT 저장소 설정하기 # 이제 우리 시스템의 패키지 관리자(APT)에게 \u0026ldquo;앞으로 도커는 이 공식 저장소에서 다운로드해줘\u0026quot;라고 알려줄 차례입니다. 다음 명령어를 실행하면, 시스템 아키텍처(예: amd64)에 맞는 도커 공식 저장소 주소가 sources.list 파일에 추가됩니다.\necho \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;${UBUNTU_CODENAME:-$VERSION_CODENAME}\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 이 복잡해 보이는 명령어는 현재 우분투 버전(예: jammy)에 맞는 안정적인(stable) 도커 버전을 다운로드하도록 설정하는 과정입니다.\n도커 엔진 설치하기 # 모든 사전 준비가 끝났습니다. 이제 정말로 도커를 설치할 시간입니다.\n패키지 목록 업데이트 # 방금 추가한 도커 공식 저장소의 정보를 시스템에 반영하기 위해 패키지 목록을 다시 한번 업데이트합니다.\nsudo apt-get update [이미지 설명: \u0026lsquo;apt-get update\u0026rsquo; 명령어 실행 후, 마지막 줄에 \u0026lsquo;https://www.google.com/search?q=download.docker.com\u0026rsquo; 주소가 보이는 터미널 화면. 새 저장소가 성공적으로 인식되었음을 보여줍니다.]\n최신 버전 도커 엔진 설치 # 아래 명령어를 통해 도커 엔진(Docker Engine)과 컨테이너 실행에 필요한 핵심 구성 요소들(containerd, Docker Compose)을 한번에 설치합니다.\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce: 도커 커뮤니티 에디션(Community Edition)의 약자로, 실제 도커 엔진입니다. docker-ce-cli: 도커 명령어를 입력할 수 있게 해주는 클라이언트 도구입니다. containerd.io: 컨테이너의 실행과 생명 주기를 관리하는 핵심 런타임입니다. docker-buildx-plugin, docker-compose-plugin: 도커의 추가 기능들(빌드, 다중 컨테이너 관리)을 사용하기 위한 플러그인입니다. 설치 과정에서 디스크 공간을 얼마나 사용할지 묻는 메시지가 나타나면, \u0026lsquo;Y\u0026rsquo; 를 입력하고 엔터를 눌러 계속 진행하십시오.\n설치 확인하기 # 설치가 올바르게 완료되었는지 확인하는 것은 매우 중요합니다. 다음 명령어를 입력하여 도커가 우리를 반겨주는지 확인해 보십시오.\nsudo docker run hello-world 이 명령어를 실행했을 때 터미널 화면에 \u0026ldquo;Hello from Docker!\u0026rdquo; 라는 메시지가 포함된 환영 문구가 나타난다면, 여러분의 Ubuntu 시스템에 도커가 성공적으로 설치된 것입니다!\n맺음말 # 수고하셨습니다. 다소 복잡해 보이는 과정이었을지 모르지만, 이 글을 차근차근 따라오셨다면 이제 여러분의 시스템은 도커 컨테이너를 실행할 모든 준비를 마쳤습니다. 공식적인 절차를 따라 안전하게 설치했으므로, 앞으로 안정적으로 도커를 사용하실 수 있을 겁니다.\n참조:\n도커 공식 문서 (Docker Documentation) Install Docker Engine on Ubuntu ","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/install-docker-on-ubuntu/","section":"","summary":"","title":"Ubuntu에 Docker 설치하기","type":"posts"},{"content":"이 글을 읽는 분들은 아마도 \u0026ldquo;도커가 도대체 뭐길래 다들 이야기하는 걸까?\u0026rdquo; 하는 궁금증을 갖고 계실 겁니다. 괜찮습니다. 누구나 처음은 있으니까요. 저 역시 수많은 기술을 처음 접하며 하나씩 익혔던 경험이 있습니다. 이 글에서는 도커가 무엇인지 쉽고 명확하게 안내해 드리겠습니다.\n도커(Docker)란 무엇일까요? # 가장 간단하게 설명하자면, 도커는 애플리케이션을 \u0026lsquo;컨테이너\u0026rsquo;라는 독립된 공간에 담아 어디서든 동일한 환경에서 실행할 수 있게 해주는 기술(플랫폼)입니다.\n혹시 이런 경험 없으신가요? 제 컴퓨터에서는 잘 작동하던 프로그램이 동료의 컴퓨터나 실제 서버에서는 오류를 일으키는 상황 말입니다. 이는 개발 환경과 운영 환경이 미세하게 달라서 발생하는 문제입니다. 운영체제 버전, 설치된 라이브러리, 각종 설정값의 차이가 원인이죠.\n도커는 바로 이 문제를 해결합니다. 애플리케이션 실행에 필요한 모든 것(코드, 라이브러리, 시스템 도구 등)을 하나의 \u0026lsquo;컨테이너\u0026rsquo;에 담아 패키징합니다. 이 컨테이너는 어느 컴퓨터로 옮기든 내용물이 변하지 않고 그대로 실행됩니다. 마치 해외로 물건을 보낼 때, 튼튼한 컨테이너에 담아 보내면 내용물이 파손되거나 변질될 걱정이 없는 것과 같은 원리입니다.\n왜 도커를 사용해야 할까요? # 도커를 사용하면 개발자와 시스템 관리자 모두에게 다음과 같은 실질적인 이점을 제공합니다.\n환경 통일로 인한 문제 해결: \u0026ldquo;제 컴퓨터에선 됐는데\u0026hellip;\u0026ldquo;라는 말이 사라집니다. 개발, 테스트, 운영 환경을 모두 동일하게 구성할 수 있어 환경 차이로 인한 오류를 원천적으로 방지합니다.\n빠르고 쉬운 배포: 잘 만들어진 컨테이너 이미지 하나만 있으면, 수십, 수백 대의 서버에도 몇 가지 명령어로 간단하게 애플리케이션을 배포할 수 있습니다.\n서버 자원의 효율적 사용: 기존의 가상 머신(VM) 방식보다 훨씬 가볍습니다. 가상 머신은 매번 게스트 운영체제(Guest OS)를 통째로 설치해야 해서 무겁고 느렸지만, 컨테이너는 호스트 컴퓨터의 운영체제 커널을 공유하며 최소한의 라이브러리와 파일만으로 실행되므로 훨씬 적은 자원으로 더 많은 애플리케이션을 실행할 수 있습니다.\n독립적인 실행 환경: 각 컨테이너는 서로 완전히 격리된 공간에서 실행됩니다. 따라서 하나의 컨테이너에서 문제가 발생하더라도 다른 컨테이너에 영향을 주지 않아 안정적인 서비스 운영이 가능합니다.\n도커는 어디서 활용될 수 있을까요? # 도커의 활용 범위는 매우 넓습니다. 대표적인 활용 분야는 다음과 같습니다.\n웹 애플리케이션 개발 및 배포\n개발자가 자신의 노트북에서 만든 애플리케이션을 도커 컨테이너에 담아 테스트팀에 전달하고, 테스트가 완료된 컨테이너를 그대로 운영 서버에 배포하는 것이 가능합니다. 모든 환경이 동일하므로 배포 과정의 예측 가능성과 안정성이 크게 향상됩니다.\n마이크로서비스 아키텍처 (MSA)\n거대한 하나의 서비스를 여러 개의 작은 기능 단위(마이크로서비스)로 쪼개어 개발하는 방식입니다. 도커는 각 서비스를 독립된 컨테이너로 만들어 개발하고 배포하는 데 최적의 환경을 제공합니다. 예를 들어 \u0026lsquo;사용자 인증 서비스\u0026rsquo;, \u0026lsquo;상품 서비스\u0026rsquo;, \u0026lsquo;결제 서비스\u0026rsquo;를 각각의 컨테이너로 분리하여 독립적으로 관리하고 확장할 수 있습니다.\n데이터 과학 및 머신러닝\n데이터 분석이나 머신러닝 모델 개발에는 수많은 라이브러리와 복잡한 설정이 필요합니다. 분석 환경 자체를 도커 이미지로 만들어두면, 누구나 동일한 환경에서 코드를 실행하고 연구 결과를 재현할 수 있어 협업과 검증이 매우 용이해집니다.\nCI/CD 파이프라인 자동화\nCI/CD는 \u0026lsquo;지속적 통합/지속적 배포\u0026rsquo;를 의미하며, 코드 변경 사항을 자동으로 빌드, 테스트, 배포하는 과정을 말합니다. 도커는 이 과정에서 매번 깨끗하고 일관된 테스트 환경을 즉시 생성하고 폐기하는 데 사용되어 자동화 파이프라인의 신뢰도를 높여줍니다.\n도커를 배우면 무엇을 할 수 있을까요? # 도커를 익히면 개발자로서 다음과 같은 역량을 갖추게 됩니다.\n나만의 독립된 개발 환경 구축:\n프로젝트마다 필요한 환경이 다를 때 유용합니다. 예를 들어, 한 프로젝트는 오래된 버전의 데이터베이스가 필요하고 다른 프로젝트는 최신 버전이 필요할 때, 각 프로젝트를 위한 컨테이너를 따로 만들어 충돌 없이 작업할 수 있습니다.\n복잡한 소프트웨어를 명령어 하나로 실행:\n데이터베이스(PostgreSQL, Redis 등)나 분석 도구(Elasticsearch)처럼 설치 과정이 까다로운 소프트웨어도, 공식 도커 이미지를 이용해 명령어 한 줄로 간단히 실행하고 테스트해볼 수 있습니다.\n협업의 효율성 증대:\n내가 만든 애플리케이션을 동료에게 전달할 때, 소스 코드만 보내는 것이 아니라 실행 환경이 모두 담긴 도커 이미지를 전달할 수 있습니다. 동료는 복잡한 설치 과정 없이 즉시 애플리케이션을 실행해볼 수 있습니다.\n클라우드 네이티브 기술로의 확장:\n도커는 쿠버네티스(Kubernetes) 와 같은 컨테이너 오케스트레이션 도구의 가장 기본이 되는 기술입니다. 도커를 이해하는 것은 수많은 컨테이너를 효율적으로 관리하는 클라우드 네이티브 전문가로 성장하기 위한 첫걸음입니다.\n맺음말 # 지금까지 도커가 무엇인지, 왜 필요한지, 그리고 어디에 어떻게 활용할 수 있는지에 대한 기본적인 내용을 함께 살펴보았습니다. 오늘 실습한 내용은 도커가 가진 능력의 아주 작은 부분에 불과합니다. 하지만 이 첫걸음이 여러분이 앞으로 마주할 개발의 복잡성을 크게 줄여줄 단단한 초석이 되리라 믿습니다.\n처음에는 이미지, 컨테이너, 볼륨, 네트워크 등 낯선 용어들이 어렵게 느껴질 수 있습니다. 하지만, 하나씩 차근차근 시도하다 보면 어느새 도커와 친숙해진 자신을 발견하게 될 것입니다.\n두려워하지 마시고, 직접 부딪히며 경험을 쌓아나가시길 바랍니다. 기술은 결국 사람이 더 편하고 효율적으로 일하기 위해 만드는 도구일 뿐입니다. 이 글이 여러분의 첫걸음에 작은 도움이 되었기를 바랍니다.\n참조:\n도커 공식 문서 (Docker Documentation) ","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/what-is-docker/","section":"","summary":"","title":"개발자라면 반드시 알아야 할 Docker","type":"posts"},{"content":"Utterances는 GitHub의 이슈(Issues) 시스템을 활용하는 경량 댓글 위젯입니다. 광고나 추적 기능 없이 무료로 사용할 수 있으며, 모든 댓글 데이터는 여러분의 GitHub 저장소에 안전하게 보관됩니다. 그럼, 지금부터 설치를 시작하겠습니다.\nGitHub 저장소 설정 # Utterances는 댓글을 저장할 공간으로 공개(Public) GitHub 저장소를 사용합니다. 따라서 가장 먼저 댓글용 저장소를 준비해야 합니다.\nGitHub에 로그인한 후, 새로운 저장소(Repository)를 생성합니다. 저장소 이름을 정하고, 반드시 \u0026lsquo;Public\u0026rsquo; 으로 설정합니다. Private 저장소는 Utterances가 접근할 수 없습니다. 나머지 옵션은 기본값으로 두고 \u0026lsquo;Create repository\u0026rsquo; 버튼을 클릭하여 저장소를 생성합니다. Utterances 앱 설치 및 연동 # 다음으로, 생성한 저장소에 Utterances 앱을 설치하고 권한을 부여해야 합니다.\nGitHub Marketplace 로 이동합니다. \u0026lsquo;Install\u0026rsquo; 버튼을 누르면 권한 설정 페이지로 이동합니다.(저는 이미 설치된 상태라 Configure 버튼이 표시됩니다.) 여기서 \u0026lsquo;Only select repositories\u0026rsquo; 를 선택하고, 방금 생성한 댓글용 저장소를 지정해 주는 것이 좋습니다. 모든 저장소에 권한을 부여하는 것보다 보안상 안전한 방법입니다.\n\u0026lsquo;Install\u0026rsquo; 버튼을 클릭하여 설치를 완료합니다.\nBlowfish 테마 설정 파일 수정 # 이제 Hugo 프로젝트의 설정 파일을 수정하여 Utterances를 활성화할 차례입니다. Blowfish 테마는 hugo.toml 파일을 통해 댓글 기능을 손쉽게 설정할 수 있도록 지원합니다.\nHugo 프로젝트 폴더에서 layouts/partials/comments.html 파일을 생성합니다. 내용은 utterances 홈페이지 에서 저장소 위치와 테마를 선택하면 자동으로 생성됩니다. \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=[REPO_NAME] issue-term=\u0026#34;pathname\u0026#34; theme=[THEME] crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; Hugo 프로젝트 폴더에서 config/_default/params.toml 파일을 엽니다. 파일의 [article] 섹션 가장 아래에 다음과 같이 댓글 설정을 추가하거나 수정합니다. [article] ... showcomments = true 주의:\nrepo 항목에는 본인의 GitHub 사용자명과 댓글용 저장소 이름으로 정확하게 수정해야 합니다. (예: \u0026quot;Gatsby-Lee/my-blog-comments\u0026quot;) issueTerm은 각 게시물 페이지와 GitHub 이슈를 어떻게 연결할지 결정하는 중요한 설정입니다. 일반적으로 pathname을 사용하면 문제없이 작동합니다. theme은 블로그 디자인에 맞춰 \u0026lsquo;github-light\u0026rsquo;, \u0026lsquo;github-dark\u0026rsquo; 등 원하는 스타일로 변경할 수 있습니다. 확인 및 마무리 # 모든 설정을 마쳤습니다. 이제 로컬 서버를 실행하여 댓글 기능이 정상적으로 작동하는지 확인합니다.\nhugo server 웹 브라우저에서 http://localhost:1313/으로 접속한 후, 댓글 기능을 활성화한 게시물로 이동하여 페이지 하단에 Utterances 댓글 창이 나타나는지 확인하십시오. GitHub 계정으로 로그인하면 바로 댓글을 작성하고 테스트해 볼 수 있습니다.\n이것으로 Hugo Blowfish 테마에 Utterances 댓글 기능을 성공적으로 설치했습니다. 이제 방문자들과 더욱 활발하게 소통하며 블로그를 풍성하게 가꾸어 나가시길 바랍니다. 궁금한 점이 있다면 언제든지 질문해 주십시오.\n참고\nUtterances 공식 문서 Blowfish Comments ","date":"2 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-add-comments/","section":"","summary":"","title":"Blowfish 테마: Utterances 댓글 기능 설치하기","type":"posts"},{"content":"오늘은 Hugo 블로그를 더욱 돋보이게 만들어 줄 파비콘(Favicon) 설정 방법을 안내해 드리고자 합니다. 복잡해 보일 수 있지만, 차근차근 따라오시면 누구나 쉽게 웹사이트의 얼굴을 만드실 수 있을 것입니다.\n파비콘(Favicon)이란 무엇일까요? # 파비콘은 \u0026lsquo;Favorite icon\u0026rsquo;의 줄임말로, 웹사이트를 대표하는 작은 아이콘을 의미합니다. 웹 브라우저의 탭, 북마크 목록, 스마트폰 홈 화면 등에서 여러분의 사이트를 시각적으로 식별하는 중요한 역할을 합니다. 잘 만들어진 파비콘은 사용자가 여러 탭 중에서 여러분의 사이트를 쉽게 찾도록 도와주며, 전문적인 인상을 줍니다.\n설정 전 준비사항 # Blowfish 테마에서 파비콘을 설정하는 방법은 크게 두 가지입니다. 이 가이드에서는 초보자분들도 쉽게 따라 할 수 있는, 기본 제공 파일을 교체하는 방식을 중심으로 설명하겠습니다.\n가장 먼저, 여러분의 웹사이트를 대표할 파비콘 이미지를 준비해야 합니다. 일반적으로 다음과 같은 다양한 크기와 형식의 파일이 필요합니다.\nfavicon.ico favicon-16x16.png favicon-32x32.png apple-touch-icon.png (iOS 기기용) android-chrome-192x192.png (안드로이드 기기용) android-chrome-512x512.png (안드로이드 기기용) site.webmanifest (웹 앱 매니페스트 파일) 이 모든 파일을 직접 만드는 것은 번거로울 수 있습니다. 다행히 favicon.io 와 같은 온라인 파비콘 생성 서비스를 이용하면, 고화질 이미지 하나만으로 필요한 모든 형식의 파비콘 파일을 한 번에 만들고 내려받을 수 있습니다.\n파비콘 설정 방법 # 이제 준비된 파비콘 파일들을 여러분의 Hugo 프로젝트에 적용해 보겠습니다.\nstatic 폴더 확인 # 여러분의 Hugo 프로젝트 최상위 디렉터리(root)에서 static 이라는 이름의 폴더를 찾으십시오. 만약 해당 폴더가 없다면, 직접 생성해 주시면 됩니다. Hugo는 static 폴더 안의 모든 파일을 웹사이트의 루트 디렉터리로 복사하는 특징이 있습니다.\n파비콘 파일 복사 및 붙여넣기 # 앞서 준비한 파비콘 파일들(favicon.ico, apple-touch-icon.png 등)을 모두 static 폴더 안으로 복사하여 붙여넣습니다. Blowfish 테마에 기본으로 포함된 파비콘 파일들을 여러분의 파일로 덮어쓰게 됩니다.\n파비콘 파일들은 반드시 static 폴더 바로 아래에 위치해야 합니다. 다른 하위 폴더 안에 넣지 않도록 주의하십시오. 웹사이트 변경사항 확인 # 로컬 개발 서버를 실행 중이라면, 서버를 재시작하십시오. (hugo server 명령어를 다시 실행) 그리고 웹 브라우저를 열어 여러분의 사이트에 접속합니다. 브라우저 탭에 새로운 파비콘이 정상적으로 표시되는지 확인합니다.\n파비콘이 보이지 않는다면? # 파비콘 파일을 올바르게 교체했음에도 불구하고 이전의 Blowfish 테마 아이콘이 계속 표시될 수 있습니다. 이는 대부분 웹 브라우저에 저장된 캐시(Cache) 때문입니다.\n이러한 문제가 발생하면 다음과 같은 방법을 시도해 보시기 바랍니다.\n강력 새로고침(Hard Refresh): Ctrl + Shift + R (Windows/Linux) 또는 Cmd + Shift + R (Mac) 키를 눌러 브라우저 캐시를 무시하고 페이지를 새로고침합니다. 시크릿 모드/개인정보 보호 창 사용: 브라우저의 시크릿 모드(또는 개인정보 보호 창)에서 사이트에 접속하여 확인합니다. 시크릿 모드는 캐시나 확장 프로그램의 영향을 받지 않아 변경 사항을 정확하게 확인할 수 있습니다. 브라우저 캐시 삭제: 위의 방법으로도 해결되지 않으면, 브라우저 설정에서 직접 캐시 데이터를 삭제한 후 다시 확인해 보십시오. 마무리하며 # 지금까지 Hugo Blowfish 테마에서 파비콘을 설정하는 방법을 알아보았습니다. 이 가이드가 여러분의 웹사이트를 개성 있게 만드는 데 작은 보탬이 되기를 바랍니다. 기술적인 부분에서 어려움을 느끼시는 분들께 실질적인 도움이 되었으면 하는 바람입니다.\n","date":"1 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-favicon/","section":"","summary":"","title":"Blowfish 테마: 파비콘(Favicon) 설정하기","type":"posts"},{"content":"블로그 글이 길어질수록 독자는 원하는 정보를 찾기 어려워집니다. 이때 글의 구조를 한눈에 보여주는 TOC(Table of Contents, 목차) 는 매우 유용한 기능입니다. 독자는 목차를 통해 전체 내용을 빠르게 파악하고 원하는 섹션으로 즉시 이동할 수 있어 사용자 경험을 크게 향상시킬 수 있습니다.\nBlowfish 테마는 강력한 TOC 기능을 내장하고 있어, 간단한 설정만으로 블로그 글에 목차를 추가할 수 있습니다. 이 글에서는 Blowfish 테마의 기본 TOC 설정부터 사용자의 스크롤에 반응하는 동적 TOC 기능까지 설정하는 방법을 알아보겠습니다.\n전체 블로그에 TOC 기본 설정하기 # 가장 먼저, 블로그 전체에 TOC를 기본적으로 활성화하는 방법입니다. Hugo 프로젝트의 config/_default 디렉터리에 있는 params.toml 파일을 수정합니다.\n[params.article] 섹션에 다음 설정을 추가하거나 수정합니다. 만약 해당 섹션이 없다면 새로 만들어주면 됩니다.\n# config/_default/params.toml [article] # true로 설정하면 모든 글에 기본적으로 목차가 표시됩니다. showTableOfContents = true 이 설정 하나만으로 모든 게시물에 목차가 자동으로 생성됩니다.\nTOC 상세 설정 (표시할 제목 레벨 조정) # Blowfish 테마에서는 목차에 표시될 마크다운 제목(heading)의 레벨을 지정할 수 있습니다. 예를 들어, \u0026lt;h2\u0026gt;(##) 부터 \u0026lt;h4\u0026gt;(####) 까지의 제목만 목차에 포함하고 싶을 수 있습니다.\nmarkup.toml 파일의 [tableOfContents] 섹션에서 이를 제어할 수 있습니다.\n# config/_default/markup.toml [tableOfContents] # 목차 생성을 시작할 제목 레벨 (기본값: 2) # 2는 \u0026lt;h2\u0026gt;(##)를 의미합니다. startLevel = 2 # 목차 생성을 마칠 제목 레벨 (기본값: 3) # 3은 \u0026lt;h3\u0026gt;(###)를 의미합니다. endLevel = 3 # 목록 항목을 순서 있는 리스트(1., 2., ...)로 표시할지 여부 (기본값: false) ordered = false startLevel: 목차에 포함할 가장 상위 제목 레벨입니다. \u0026lt;h2\u0026gt;는 2, \u0026lt;h3\u0026gt;는 3으로 설정합니다. endLevel: 목차에 포함할 가장 하위 제목 레벨입니다. \u0026lt;h4\u0026gt;까지 포함하려면 4로 설정합니다. 이 설정을 통해 너무 상세하거나 불필요한 제목은 목차에서 제외하여 더 깔끔한 TOC를 구성할 수 있습니다.\n동적 TOC 기능 활성화하기 (smartTOC) # Blowfish 테마는 사용자의 스크롤 위치에 따라 현재 읽고 있는 부분의 목차를 하이라이트 해주는 스마트 TOC 기능을 제공합니다. 이는 독자에게 현재 위치를 시각적으로 알려주어 긴 글을 읽을 때 매우 유용합니다.\nparams.toml 파일의 smartTOC 항목을 확인합니다.\n# config/_default/params.toml # 스마트 TOC 기능 활성화 smartTOC = true 하위 목차 자동 숨기기 # smartTOC를 사용할 때, 글의 구조가 복잡하고 하위 목차가 많으면 TOC 자체가 너무 길어질 수 있습니다. 이때 smartTOCHideUnfocusedChildren 옵션을 사용하면 현재 보고 있는 섹션의 하위 목차만 펼쳐지고, 나머지 비활성 섹션의 하위 목차는 자동으로 접히게 됩니다.\nparams.toml 파일에 다음과 같이 설정을 추가합니다.\n# config/_default/params.toml smartTOC = true # 현재 위치가 아닌 다른 섹션의 하위 목차를 숨깁니다. smartTOCHideUnfocusedChildren = true 이 기능을 사용하면 매우 긴 글에서도 목차를 간결하고 집중도 있게 유지할 수 있습니다.\n특정 글에서만 TOC 설정 변경하기 (Front Matter 활용) # 전체 기본 설정을 따르지 않고, 특정 게시물에 대해서만 목차를 표시하거나 숨기고 싶을 때가 있습니다. 이 경우, 해당 마크다운 파일(.md)의 Front Matter 영역에서 개별적으로 제어할 수 있습니다.\nFront Matter는 마크다운 문서 최상단에 --- 또는 +++로 둘러싸인 메타데이터 영역을 말합니다.\n특정 글에서만 TOC 보이기 # hugo.toml에서 showTableOfContents = false로 설정했더라도, 특정 글에서만 목차를 표시하고 싶다면 해당 글의 Front Matter에 다음을 추가합니다.\n--- title: \u0026#34;특정 글 제목\u0026#34; date: 2025-06-29 showTableOfContents: true --- 여기에 글 내용이 들어갑니다... 특정 글에서만 TOC 숨기기 # 반대로 hugo.toml에서 showTableOfContents = true로 설정했지만, 짧은 공지사항과 같이 목차가 필요 없는 글에서는 개별적으로 숨길 수 있습니다.\n--- title: \u0026#34;공지사항\u0026#34; date: 2025-06-29 showTableOfContents: false --- 간단한 공지 내용입니다... 이처럼 Front Matter 설정은 params.toml의 전역 설정보다 우선 적용되므로, 글의 성격에 따라 유연하게 목차를 관리할 수 있습니다.\n※ 참조: TOC가 표시되지 않는 경우 # 설정을 완료했는데도 목차가 보이지 않는다면 다음을 확인해 보세요.\n게시물에 마크다운 제목이 있나요? 목차는 ##, ### 와 같은 마크다운 제목 태그를 기반으로 생성됩니다. 본문에 markup.toml 파일에서 [tableOfContents]에 설정된 레벨 범위(startLevel ~ endLevel)에 해당하는 제목이 하나도 없다면 TOC는 표시되지 않습니다. 간단한 설정으로 블로그의 가독성과 사용자 편의성을 크게 높일 수 있습니다. 지금 바로 여러분의 Hugo Blowfish 블로그에 동적 TOC 기능을 적용해 보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-toc/","section":"","summary":"","title":"Blowfish 테마: TOC(목차) 설정으로 블로그 가독성 높이기 ","type":"posts"},{"content":"오늘은 파일명 규칙 하나만으로 섬네일을 자동으로 설정하고, 간단한 옵션으로 히어로 이미지까지 제어하는 Blowfish 테마의 \u0026lsquo;컨벤션(Convention)\u0026rsquo; 기반 설정법을 완벽하게 알려드립니다.\n파일명 규칙과 Leaf Bundle # 이 스마트한 기능을 사용하기 위해서는 Leaf Bundle 방식으로 구성하고, 정해진 파일명 패턴을 사용하는 것입니다.\nLeaf Bundle 구조:\n이전과 동일하게, 각 게시물은 고유한 폴더를 갖고 그 안에 index.md 파일과 이미지들이 함께 위치해야 합니다.\n자동 감지 파일명:\nBlowfish 테마는 Leaf Bundle 폴더 안에서 아래 패턴과 일치하는 이미지 파일을 발견하면, 자동으로 해당 이미지를 포스트의 섬네일로 인식합니다.\nfeature* (예: featured.jpg, feature-image.png) 이 패턴과 일치하는 이미지가 있다면, Front Matter에 thumbnail 키를 추가하지 않아도 목록 페이지에 섬네일이 자동으로 표시됩니다.\n섬네일 설정하기 # 게시물 폴더(예: content/posts/my-smart-post/) 안에 featured.jpg 라는 이름으로 이미지를 추가합니다. 이것으로 끝입니다. index.md 파일의 Front Matter에는 아무것도 추가할 필요가 없습니다.\n단지 규격에 맞는 이름의 파일을 추가하는 것만으로, Blowfish는 이 이미지를 섬네일로 인식하고 홈페이지나 글 목록 페이지에 자동으로 보여줍니다.\n섬네일을 히어로 이미지로 사용하기 # 이제 이 섬네일을 포스트 본문의 배경(히어로 이미지)으로도 사용하고 싶다면, index.md의 Front Matter에 단 한 줄만 추가하면 됩니다.\n# content/posts/my-smart-post/index.md --- title: \u0026#34;자동으로 설정되는 이미지\u0026#34; date: 2025-06-29 showHero = true # 이 한 줄만 추가! --- showHero = true 옵션은 \u0026ldquo;이 페이지에 히어로 이미지 영역을 표시하라\u0026quot;는 명령어입니다. 이때 Blowfish는 자동으로 감지했던 featured.jpg 파일을 가져와 히어로 이미지로 사용합니다.\n마무리하며 # Blowfish 테마의 자동 감지 기능은 \u0026lsquo;설정보다 관례(Convention over Configuration)\u0026lsquo;라는 현대적인 개발 철학을 잘 보여주는 훌륭한 기능입니다. 이 스마트한 기능을 활용하면 Front Matter를 훨씬 더 간결하게 유지하면서도 블로그의 시각적 요소를 풍부하게 만들 수 있습니다.\n이제부터는 featured.jpg 파일 하나만 추가하는 간편한 방법으로 여러분의 콘텐츠를 더욱 돋보이게 만들어 보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-post-add-thumnail/","section":"","summary":"","title":"Blowfish 테마: 섬네일 \u0026 히어로 이미지 설정 방법","type":"posts"},{"content":"","date":"29 June 2025","externalUrl":null,"permalink":"/tags/post/","section":"Tags","summary":"","title":"Post","type":"tags"},{"content":"방문자가 내 블로그의 콘텐츠를 쉽게 탐색하도록 돕는 가장 중요한 요소는 바로 \u0026lsquo;메뉴\u0026rsquo;입니다. Blowfish 테마는 사이트 상단의 메인 메뉴(main)와 하단의 푸터 메뉴(footer), 그리고 드롭다운 형태의 서브메뉴까지 유연하게 지원합니다.\n오늘은 이 모든 종류의 메뉴를 설정하는 방법을 알아 보겠습니다.\n메뉴 설정의 핵심 파일: menus.xx.toml # Blowfish의 모든 메뉴는 config/_default/ 폴더 안에 있는 menus.xx.toml 파일 하나로 관리됩니다.\n파일 위치: config/_default/menus.en.toml (기본 설치 시) 한국어 설정: 만약 블로그의 주 언어가 한국어이고 다중어 설정이 필요하다면, 이 파일의 이름을 menus.ko.toml로 변경하여 사용하는 것이 좋습니다. 이렇게 하면 다국어 설정 시 언어별로 다른 메뉴를 구성할 수 있습니다. 이 파일 안에는 크게 [[main]] (메인 메뉴)과 [[footer]] (푸터 메뉴) 두 종류의 메뉴 아이템을 정의할 수 있습니다.\n기본 메뉴 아이템 추가하기 (내부 페이지 링크) # 가장 기본적인 메뉴 설정은 블로그의 특정 섹션(예: 글 목록)으로 연결하는 것입니다.\nmenus.en.toml 파일을 열고 아래와 같이 작성합니다.\n# config/_default/menus.en.toml # -- Main Menu -- # 사이트 헤더 상단에 표시되는 메인 메뉴 [[main]] # 메뉴에 표시될 이름 name = \u0026#34;Blog\u0026#34; # Hugo 콘텐츠 섹션과 연결합니다. # \u0026#39;content/posts\u0026#39; 폴더를 가리키며, URL이 변경되어도 깨지지 않는 가장 안정적인 방식입니다. pageRef = \u0026#34;posts\u0026#34; # 메뉴의 순서를 결정합니다. 숫자가 낮을수록 왼쪽에 표시됩니다. weight = 10 [[main]] name = \u0026#34;Categories\u0026#34; pageRef = \u0026#34;categories\u0026#34; weight = 20 name: 방문자에게 보여질 메뉴의 이름입니다. pageRef: content/ 폴더 안의 특정 폴더(섹션)나 파일을 가리킵니다. 예를 들어 posts는 /posts/ 페이지로 연결됩니다. weight: 메뉴의 순서를 정합니다. 숫자가 낮을수록 우선순위가 높습니다. 외부 링크와 아이콘 추가하기 # 내 GitHub나 다른 웹사이트로 연결되는 메뉴도 쉽게 추가할 수 있습니다.\n[[main]] name = \u0026#34;GitHub\u0026#34; # 외부 URL을 직접 지정합니다. pageRef와 함께 사용할 수 없습니다. url = \u0026#34;https://github.com/your-id\u0026#34; weight = 30 # 이름 앞에 아이콘을 추가합니다. # Blowfish는 \u0026#39;github\u0026#39;, \u0026#39;twitter\u0026#39; 등 몇 가지 아이콘을 내장하고 있습니다. pre = \u0026#34;github\u0026#34; url: 외부 링크를 걸 때 사용합니다. pre: 메뉴 이름 앞에 표시될 내용을 지정합니다. Blowfish는 몇 가지 소셜 아이콘 키워드를 지원하여, 위와 같이 설정하면 이름 앞에 GitHub 아이콘이 자동으로 나타납니다. 드롭다운 서브메뉴 만들기 # 관련 페이지들을 묶어 드롭다운 메뉴로 만들 수 있습니다. 이를 위해서는 identifier와 parent라는 두 가지 파라미터가 필요합니다.\n# 1. 부모 메뉴 아이템을 먼저 정의합니다. # 이 아이템은 드롭다운의 제목 역할을 하며, 보통 링크는 없습니다. [[main]] name = \u0026#34;더 보기\u0026#34; # 이 메뉴의 고유 ID를 지정합니다. 자식 메뉴들이 이 ID를 참조합니다. identifier = \u0026#34;more\u0026#34; weight = 40 # 2. 첫 번째 자식 메뉴를 정의합니다. [[main]] name = \u0026#34;About\u0026#34; pageRef = \u0026#34;about\u0026#34; # content/about.md 페이지로 연결 # 부모 메뉴의 identifier를 \u0026#39;parent\u0026#39;로 지정합니다. parent = \u0026#34;more\u0026#34; weight = 10 # 서브메뉴 안에서의 순서 # 3. 두 번째 자식 메뉴를 정의합니다. [[main]] name = \u0026#34;저자 소개\u0026#34; pageRef = \u0026#34;authors\u0026#34; # content/authors/ 섹션으로 연결 parent = \u0026#34;more\u0026#34; weight = 20 identifier: 부모가 될 메뉴 아이템에 부여하는 고유한 이름표입니다. parent: 자식 메뉴가 어떤 부모 메뉴 아래에 속할지를 identifier 값으로 지정합니다. 푸터(Footer) 메뉴 설정하기 # 사이트 하단에 표시되는 푸터 메뉴는 메인 메뉴와 설정 방식이 완전히 동일합니다. [[main]] 대신 [[footer]] 블록을 사용하기만 하면 됩니다.\n# -- Footer Menu -- # 사이트 하단에 표시되는 메뉴 [[footer]] name = \u0026#34;개인정보처리방침\u0026#34; pageRef = \u0026#34;privacy\u0026#34; weight = 10 마무리하며 # 지금까지 Hugo Blowfish 테마에서 메뉴를 설정하는 모든 방법을 알아보았습니다. menus.en.toml 파일 하나만 잘 이해하면, 블로그의 내비게이션을 원하는 대로 자유롭게 구성할 수 있습니다.\n내부 링크는 pageRef 외부 링크는 url 순서는 weight 드롭다운은 identifier와 parent 이 네 가지 핵심 규칙만 기억하시면 됩니다. 이제 여러분의 블로그에 방문자들이 길을 잃지 않도록 튼튼한 이정표를 세워보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-menu/","section":"","summary":"","title":"Blowfish 테마: 메뉴 설정 가이드 (Main, Footer, Dropdown)","type":"posts"},{"content":"Hugo와 Blowfish 테마를 사용하여 블로그를 만들 때, 가장 중요하면서도 처음에는 헷갈리는 부분이 바로 콘텐츠를 어떻게 구성하고 정리하는가입니다. 잘 정리된 콘텐츠 구조는 보기에도 좋을 뿐만 아니라, URL 경로, 메뉴 구성, 그리고 장기적인 유지보수에 직접적인 영향을 미칩니다.\n오늘은 Hugo의 공식적인 콘텐츠 조직 방법론을 바탕으로, Blowfish 테마에서 이를 어떻게 효과적으로 적용할 수 있는지에 대한 완벽한 가이드를 제시합니다.\nHugo 콘텐츠 구성의 핵심: 섹션(Sections) # Hugo는 매우 직관적인 방식으로 콘텐츠를 구성합니다. 프로젝트의 content/ 폴더 안에 만드는 최상위 폴더가 곧 사이트의 **섹션(Section)**이 됩니다.\n예를 들어, 아래와 같은 폴더 구조를 생각해 보세요.\ncontent/ ├── posts/ └── projects/ content/posts/ 폴더는 posts라는 섹션을 만듭니다. 이 섹션의 URL은 https://your-site.com/posts/가 됩니다. content/projects/ 폴더는 projects 섹션을 만듭니다. URL은 https://your-site.com/projects/가 됩니다. 이처럼 폴더 구조가 그대로 사이트의 URL 구조로 연결되는 것이 Hugo의 가장 큰 특징입니다. Blowfish 테마 역시 이 기본 구조를 그대로 따릅니다.\n두 종류의 index 파일: _index.md vs index.md # Hugo의 콘텐츠 구조를 이해하기 위한 가장 중요한 개념은 바로 _index.md와 index.md 파일의 차이를 아는 것입니다.\n_index.md: 섹션의 대표 페이지 (List Page) # _index.md 파일은 특정 폴더(섹션) 자체를 설명하는 대표 페이지를 만들 때 사용됩니다. 예를 들어, content/posts/_index.md 파일은 /posts라는 URL로 접속했을 때 보이는 게시글 목록 페이지의 제목이나 상단 소개글을 제어합니다.\n--- # content/posts/_index.md title: \u0026#34;나의 기술 블로그\u0026#34; description: \u0026#34;개발 과정에서 배운 점과 기술적인 고민을 공유합니다.\u0026#34; --- 이곳은 저의 개발 블로그입니다. 다양한 주제의 글들을 살펴보세요. 위 내용 중 Front Matter(\u0026mdash;로 둘러싸인 부분)는 페이지의 메타데이터를, 그 아래 내용은 게시글 목록 상단에 표시될 콘텐츠를 정의합니다.\nindex.md: 개별 페이지와 리소스 묶음 (Leaf Bundle) # index.md 파일은 하나의 완전한 개별 페이지를 만들 때 사용되며, 특히 해당 페이지에 사용되는 이미지 등의 리소스를 함께 묶어서 관리할 때 매우 유용합니다. 이를 Leaf Bundle 방식이라고 부릅니다.\n예를 들어, my-first-post라는 글을 작성한다고 가정해 봅시다.\ncontent/posts/ └── my-first-post/ ├── index.md \u0026lt;-- 글의 실제 내용 └── hero.png \u0026lt;-- 이 글에서 사용할 대표 이미지 이 구조의 가장 큰 장점은 index.md 파일 안에서 이미지를 ![대표 이미지](hero.png)처럼 매우 간단하게 참조할 수 있다는 것입니다. 경로가 복잡해지지 않아 관리가 매우 편리하며, 새로운 글을 작성할 때 가장 추천되는 방식입니다.\nBlowfish 테마 추천 콘텐츠 구조 # 위의 개념들을 바탕으로, 일반적인 Blowfish 블로그에 추천하는 전체적인 콘텐츠 구조는 다음과 같습니다.\n. ├── assets │ └── img │ └── author.jpg ├── config │ └── _default ├── content │ ├── _index.md # 🏠 사이트 전체의 홈페이지 콘텐츠 │ ├── about.md │ └── posts # 📝 \u0026#39;posts\u0026#39; 섹션 │ ├── _index.md # /posts/ 리스트 페이지의 제목/소개 │ ├── first-post.md # 첫 번째 글 (Page Bundle) │ └── another-post # 두 번째 글 (Leaf Bundle) │ ├── aardvark.jpg │ └── index.md └── themes └── blowfish content/_index.md: 사이트의 메인 홈페이지(https://your-site.com/) 내용을 제어합니다. Blowfish의 hero나 profile 레이아웃을 설정할 때 사용됩니다. content/posts/: 모든 블로그 게시글이 위치하는 곳입니다. content/authors/: Blowfish 테마의 저자별 페이지 기능을 위해 사용되는 특별한 섹션입니다. 각 저자별로 폴더를 만들고 그 안에 _index.md를 두어 저자 소개 페이지를 만들 수 있습니다. 마무리하며 # Hugo의 콘텐츠 구성 방식은 \u0026lsquo;폴더가 곧 섹션\u0026rsquo;이라는 간단한 규칙에서 시작합니다. 여기에 _index.md와 index.md의 역할을 정확히 이해하고, Blowfish 테마가 요구하는 Front Matter를 적절히 활용하면 매우 체계적이고 확장 가능한 블로그를 만들 수 있습니다.\n새로운 글을 작성하실 때는 가급적 폴더를 만들고 그 안에 index.md를 생성하는 Leaf Bundle 방식을 사용해 보세요. 이미지 관리가 훨씬 수월해져 콘텐츠 작성의 즐거움이 배가 될 것입니다.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-contents-organizing/","section":"","summary":"","title":"Blowfish 테마: 콘텐츠 구조화 가이드 ","type":"posts"},{"content":"Blowfish 테마 설치 후 가장 먼저 해야 할 일은 바로 블로그의 \u0026lsquo;얼굴\u0026rsquo;을 만드는 것입니다. 방문자가 사이트를 기억하게 만드는 가장 중요한 두 요소인 제목과 로고를 설정하는 방법을 알아보겠습니다.\n사이트 제목(Title) 설정하기 # 사이트 제목은 브라우저 탭, 검색 엔진 결과(SEO), 그리고 로고가 없을 때 표시되는 중요한 텍스트입니다. 설정은 매우 간단합니다.\n프로젝트의 config/_default/languages.en.toml 파일을 엽니다. 파일 내에서 title 변수를 찾아 원하는 사이트 제목으로 변경합니다.\n# config/_default/languages.en.toml title = \u0026#34;My awesome website\u0026#34; 로고(Logo) 설정하기 # 로고는 사이트의 시각적인 상징입니다. Blowfish 테마에서는 라이트 모드와 다크 모드에 따라 다른 로고를 표시하는 기능도 지원합니다.\n로고 파일 준비 및 배치 # 먼저 사용할 로고 이미지 파일을 준비해야 합니다.\n라이트 모드용 로고 (예: logo-light.png) 다크 모드용 로고 (예: logo-dark.png) - 배경이 어두울 때 잘 보이는 이미지로 준비하는 것이 좋습니다. assets 폴더에 배치: # 준비한 로고 파일들을 프로젝트의 assets/images/ 폴더 안에 넣습니다. assets 폴더나 images 폴더가 없다면 직접 생성해 주세요.\n. └── assets/ └── images/ ├── logo-light.png └── logo-dark.png 로고 설정 # 이제 Hugo에게 어떤 파일을 로고로 사용할지 알려줄 차례입니다.\nlanguages.en.toml 파일 열기 프로젝트의 config/_default/languages.en.toml 파일을 엽니다.\n[logo] 섹션 찾기 및 수정 파일 내에서 [params] 섹션을 찾아 아래와 같이 로고 파일 경로와 설정을 입력합니다.\n# config/_default/params.toml [params] displayName = \u0026#34;EN\u0026#34; isoCode = \u0026#34;en\u0026#34; rtl = false dateFormat = \u0026#34;2 January 2006\u0026#34; # 라이트 모드(기본)에서 표시될 로고 # assets 폴더를 기준으로 경로를 작성합니다. logo = \u0026#34;images/logo.png\u0026#34; # 다크 모드에서 표시될 로고 secondaryLogo = \u0026#34;images/logo-dark.png\u0026#34; # description = \u0026#34;My awesome website\u0026#34; # copyright = \u0026#34;Copy, _right?_ :thinking_face:\u0026#34; ... 설정 확인하기 # 제목과 로고 설정이 완료되었습니다. 아래 명령어로 로컬 서버를 실행하여 변경 사항이 잘 적용되었는지 확인하세요.\nhugo server 웹 브라우저에서 http://localhost:1313으로 접속한 뒤, 사이트 헤더의 왼쪽 상단에 새로운 로고가 보이는지, 브라우저 탭에 설정한 제목이 올바르게 표시되는지 확인합니다. 다크 모드/라이트 모드 전환 시 로고가 바뀌는지도 테스트해 보세요.\n이렇게 간단한 설정만으로도 사이트의 개성과 정체성을 명확하게 표현할 수 있습니다.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-title-and-logo/","section":"","summary":"","title":"Blowfish 테마: 사이트 제목과 로고 설정하기","type":"posts"},{"content":"저자 정보는 홈페이지의 프로필 레이아웃이나 각 게시글 하단의 저자 소개 카드에 표시됩니다. 설정은 config/_default/params.toml 파일에서 [author] 섹션을 수정하여 이루어집니다.\n설정 단계 # params.toml 파일 열기 # 프로젝트의 config/_default/languages.en.toml 파일을 엽니다.\n[author] 섹션 찾기 및 수정 # 파일 내에서 [author] 섹션을 찾아 아래와 같이 자신의 정보를 입력합니다. 주석 처리된(#) 부분을 해제하고 내용을 수정하세요.\n# config/_default/params.toml [author] # 저자 이름 name = \u0026#34;홍길동\u0026#34; # 프로필 이미지 경로. assets 폴더 기준입니다. # 예: assets/images/profile.jpg -\u0026gt; \u0026#34;images/profile.jpg\u0026#34; image = \u0026#34;images/profile.jpg\u0026#34; # 홈페이지 프로필 레이아웃에 표시될 짧은 소개 문구 headline = \u0026#34;더 나은 내일을 만드는 개발자\u0026#34; # 각 게시글 하단에 표시될 저자 소개 bio = \u0026#34;안녕하세요! 기술로 세상을 이롭게 만들고 싶은 개발자 홍길동입니다. 이 블로그에는 저의 성장 과정과 기술적인 고민을 담고 있습니다.\u0026#34; # 소셜 미디어 등 개인 링크 # 아이콘은 이름(github, linkedin 등)에 따라 자동으로 표시됩니다. links = [ { github = \u0026#34;https://github.com/your-id\u0026#34; }, { linkedin = \u0026#34;https://linkedin.com/in/your-id\u0026#34; }, { twitter = \u0026#34;https://twitter.com/your-id\u0026#34; }, # { email = \u0026#34;mailto:user@example.com\u0026#34; }, ] 항목별 상세 설명 # name: 저자의 이름입니다. image: 프로필 이미지 파일의 경로입니다. 이미지는 프로젝트의 assets/ 폴더 안에 위치해야 합니다. 예를 들어, assets/images/profile.jpg에 이미지를 두었다면, 값은 \u0026quot;images/profile.jpg\u0026quot;가 됩니다. headline: 홈페이지 레이아웃을 profile로 설정했을 때, 이름 아래에 표시되는 한 줄 소개입니다. bio: 각 게시글 하단에 표시되는 저자의 약력 또는 소개글입니다. links: GitHub, LinkedIn, Twitter, 이메일 등 외부 링크를 설정하는 곳입니다. 링크 이름(github, linkedin 등)에 맞춰 자동으로 아이콘이 생성됩니다. 설정 확인 # params.toml 파일 수정 후 hugo server 명령어로 로컬 서버를 실행하여 홈페이지나 게시글 제목 아래에 저자 정보가 올바르게 표시되는지 확인하세요.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-author/","section":"","summary":"","title":"Blowfish 테마: 기본 저자 정보 설정하기","type":"posts"},{"content":"","date":"28 June 2025","externalUrl":null,"permalink":"/tags/hextra/","section":"Tags","summary":"","title":"Hextra","type":"tags"},{"content":"Hugo 블로그에 새로운 디자인을 입히고 싶으신가요? Hextra 테마는 문서나 기술 블로그에 최적화된 깔끔하고 현대적인 디자인을 제공하여 많은 개발자에게 사랑받고 있습니다.\n오늘은 Hextra 테마를 가장 빠르고 안정적으로 적용하는 방법을 단계별로 알려드리겠습니다.\n기존 테마 제거 (선택사항) # 새로운 테마를 적용하기 전에, 기존 테마 폴더를 정리하는 것이 좋습니다. 이 과정은 필수는 아니지만, 프로젝트를 깨끗하게 유지하는 데 도움이 됩니다.\nGit 서브모듈로 설치된 경우: # # \u0026#39;old-theme\u0026#39;은 실제 이전 테마 폴더명으로 변경하세요. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 직접 다운로드한 경우: # # \u0026#39;old-theme\u0026#39;은 실제 이전 테마 폴더명으로 변경하세요. rm -rf themes/old-theme Hextra 테마 설치 # 가장 추천하는 방법은 Git Submodule을 사용하여 프로젝트에 테마를 추가하는 것입니다. 이 방법을 사용하면 나중에 테마가 업데이트되었을 때 간단한 명령어로 최신 버전을 적용할 수 있습니다.\n프로젝트의 최상위 폴더(루트)에서 아래 명령어를 실행하세요.\ngit submodule add https://github.com/imfing/hextra.git themes/hextra Hugo 설정 파일 수정 # 이제 Hugo에게 Hextra 테마를 사용하라고 알려줄 차례입니다. 블로그의 메인 설정 파일인 hugo.toml을 열어 theme 변수를 수정합니다.\n# hugo.toml 파일 예시 theme = \u0026#34;hextra\u0026#34; Hextra 테마는 다크 모드, 검색 기능, 메뉴 구성 등 다양한 사용자 설정 옵션을 제공합니다. 더 상세한 커스터마이징을 원하시면 공식 문서를 참고하여 params.toml 등을 설정해 보세요.\n로컬 서버에서 확인 # 모든 설정이 끝났습니다. 로컬 서버를 실행하여 변경 사항이 블로그에 잘 적용되었는지 확인합니다.\nhugo server 이제 웹 브라우저 주소창에 http://localhost:1313을 입력하고 접속해 보세요. 새로운 Hextra 테마가 적용된 블로그의 모습을 실시간으로 확인할 수 있습니다.\n변경사항 배포 # 로컬에서 보이는 모습에 만족했다면, 마지막으로 변경 사항을 원격 저장소에 푸시하여 실제 블로그에 반영합니다.\ngit add . git commit -m \u0026#34;Feat: Apply Hextra theme\u0026#34; git push 마무리하며 # 이것으로 모든 과정이 끝났습니다. 보시다시피 몇 가지 명령어만으로 기존 블로그의 분위기를 완전히 새롭게 바꿀 수 있습니다. Hextra 테마의 깔끔한 디자인과 편리한 기능들을 활용하여 여러분의 지식을 더 멋지게 공유해 보시길 바랍니다.\n참고:\nHextra 공식 사이트 ","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-hextra/","section":"","summary":"","title":"Hugo 블로그에 Hextra 테마 적용하는 가장 간단한 방법","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/gitignore/","section":"Tags","summary":"","title":"Gitignore","type":"tags"},{"content":"Hugo로 멋진 블로그나 웹사이트를 만들고, Git으로 소스 코드를 관리하는 것은 이제 많은 분들에게 익숙한 과정입니다. 하지만 git add .과 git commit을 실행하기 전에, 우리는 한 가지 중요한 질문을 스스로에게 던져봐야 합니다. \u0026ldquo;어떤 파일을 Git으로 관리하고, 어떤 파일은 무시해야 할까?\u0026rdquo;\n이 질문에 대한 해답을 주는 것이 바로 .gitignore 파일입니다. 잘 구성된 .gitignore 파일은 깨끗하고 효율적인 저장소 관리의 첫걸음이자, 개발자의 전문성을 보여주는 작지만 중요한 지표입니다.\n오늘은 어떤 Hugo 프로젝트에도 바로 적용할 수 있는 표준 .gitignore 템플릿을 제공하고, 각 항목을 왜 추가해야 하는지 그 이유까지 명확하게 설명해 드리겠습니다.\n왜 .gitignore 설정이 중요한가요? # Git 관리의 핵심 원칙은 \u0026ldquo;소스 코드는 추적하고, 자동으로 생성되는 파일이나 민감한 정보는 제외한다\u0026rdquo; 는 것입니다. 만약 이 원칙을 지키지 않으면 다음과 같은 문제들이 발생할 수 있습니다.\n저장소 용량 낭비 및 속도 저하: hugo 명령어를 실행하면 public 폴더에 수많은 HTML, CSS 파일들이 생성됩니다. 이 파일들을 모두 Git으로 관리하면 저장소 용량이 불필요하게 커지고, clone 이나 push/pull 속도가 느려집니다. 의미 없는 충돌(Conflict) 발생: 협업 시 각자 생성한 public 이나 resources 폴더 내용이 달라져 불필요한 병합 충돌이 발생합니다. 이는 해결하는 것 자체가 시간 낭비입니다. 보안 사고 발생: API 키나 비밀번호가 담긴 .env 파일이 실수로 GitHub Public 저장소에 올라가면, 심각한 보안 사고로 이어질 수 있습니다. 이 모든 문제를 예방하는 것이 바로 .gitignore의 역할입니다.\nHugo .gitignore 표준 템플릿 # 아래는 어떤 Hugo 프로젝트에도 적용할 수 있는 표준 템플릿입니다. 이 내용을 프로젝트 최상위 폴더에 있는 .gitignore 파일에 그대로 복사해서 사용하세요.\n코드 스니펫\n# ========================================= # Hugo 생성 파일 (Hugo Generated Files) # ========================================= # \u0026#39;hugo\u0026#39; 빌드 시 생성되는 최종 결과물 폴더. # 소스 코드만 있으면 언제든 재생성 가능하므로 반드시 제외. /public/ # 이미지 처리, 에셋 번들링 등 Hugo Pipes 결과물이 캐시되는 폴더. # 이 역시 소스로부터 재생성되므로 제외. /resources/ # Hugo 빌드 중 생성되는 임시 잠금 파일. .hugo_build.lock # ========================================= # Node.js 의존성 (Node.js Dependencies) # ========================================= # Tailwind CSS 등 Node.js 기반 도구 사용 시 생성되는 패키지 폴더. # \u0026#39;npm install\u0026#39; 명령어로 언제든 복구 가능하므로 제외. /node_modules/ # ========================================= # OS 및 시스템 파일 (OS \u0026amp; System Files) # ========================================= # macOS 시스템 파일 .DS_Store # Windows 시스템 파일 Thumbs.db # ========================================= # IDE 및 에디터 설정 (IDE \u0026amp; Editor Settings) # ========================================= # Visual Studio Code 에디터 설정 폴더 .vscode/ # JetBrains 계열 에디터(GoLand, WebStorm 등) 설정 폴더 .idea/ # ========================================= # 민감한 정보 및 로그 (Sensitive Info \u0026amp; Logs) # ========================================= # API 키, 비밀번호 등 민감한 정보를 담는 환경 변수 파일. # 보안을 위해 절대로 Git에 커밋 금지! .env # 각종 로그 파일 *.log 내 프로젝트에 적용하는 방법 # 적용 방법은 간단합니다. 하지만 이미 관련 파일들을 커밋한 이력이 있다면, 추가적인 명령어가 필요합니다.\n.gitignore 파일 생성 및 내용 붙여넣기 # 프로젝트 최상위 폴더에 .gitignore 파일이 없다면 생성하고, 위 템플릿 내용을 모두 복사하여 붙여넣습니다.\n이미 커밋된 파일들을 Git 추적에서 제외하기 # 만약 위 템플릿에 있는 파일이나 폴더(예: public, resources)를 이미 커밋한 적이 있다면, .gitignore에 추가해도 Git은 계속해서 해당 파일들을 추적합니다. 따라서 아래 명령어를 통해 Git의 추적 목록에서 명시적으로 제거해주어야 합니다.\n# Git의 추적 목록(Staging Area)에서만 제거합니다. # --cached 옵션 덕분에 내 컴퓨터에 있는 실제 폴더와 파일은 삭제되지 않습니다. git rm -r --cached public/ git rm -r --cached resources/ # 만약 다른 파일들도 이미 커밋했다면 같은 방식으로 추가합니다. # 예: git rm -r --cached .vscode/ # 이제 .gitignore 파일과 추적 제외 상태를 함께 커밋합니다. git add .gitignore git commit -m \u0026#34;Feat: Setup .gitignore and untrack generated files\u0026#34; git push 이 과정을 거치면 앞으로 해당 파일들은 git status에 나타나지 않으며, 여러분은 오직 중요한 소스 코드 변경에만 집중할 수 있게 됩니다.\n마무리하며 # .gitignore를 올바르게 설정하는 것은 단순히 몇 줄의 텍스트를 추가하는 행위가 아닙니다. 내 프로젝트의 무엇이 \u0026lsquo;소스\u0026rsquo;이고 무엇이 \u0026lsquo;결과물\u0026rsquo;인지를 명확히 정의하는 설계 과정의 일부이며, 깨끗하고 안전한 버전 관리를 위한 가장 기본적이고 중요한 습관입니다.\n지금 바로 여러분의 Hugo 프로젝트에 이 표준 .gitignore 템플릿을 적용하여, 보다 전문적인 개발 환경을 구축해 보세요.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/set-gitignore-for-hugo/","section":"","summary":"","title":"Hugo 프로젝트를 위한 완벽한 .gitignore 설정 가이드","type":"posts"},{"content":"오늘은 세련된 디자인과 강력한 커스터마이징 기능으로 많은 주목을 받고 있는 Blowfish 테마를 기존에 운영하던 Hugo 블로그에 적용하는 방법을 상세하게 안내해 드리겠습니다.\n이 글에서는 Blowfish 공식 문서가 권장하는 방식인 Git Submodule**을 사용하여, 가장 안정적이고 확실하게 테마를 설치하고 기본 설정을 완료하는 전 과정을 다룹니다. 차근차근 따라오시면 누구나 멋진 블로그를 완성할 수 있습니다.\n기존 테마 깔끔하게 제거하기 # 새로운 옷을 입기 전, 기존 옷을 먼저 정리해야겠죠. 현재 사용 중인 테마를 깔끔하게 제거하는 것부터 시작하겠습니다. 테마 설치 방식에 따라 아래 방법 중 하나를 선택하세요.\nGit 서브모듈로 설치된 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 단순히 폴더만 삭제하는 것을 넘어, Git의 추적 기록까지 완전히 정리해 주는 가장 깔끔한 방법입니다.\n직접 다운로드하여 설치한 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. rm -rf themes/old-theme 또는 파일 탐색기에서 직접 themes/old-theme 폴더를 삭제해도 됩니다.\nGit Submodule로 Blowfish 테마 설치 # 이제 Blowfish 테마를 내 프로젝트에 추가할 차례입니다. 프로젝트의 최상위 폴더(루트)에서 아래 명령어를 순서대로 실행합니다.\ncd my-blog git init git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 테마 설정 파일 구성하기 # Blowfish는 매우 상세한 설정 옵션을 제공합니다. 가장 쉽고 확실한 방법은 테마가 제공하는 기본 설정 파일들을 내 프로젝트로 복사한 뒤, 필요한 부분만 수정하는 것입니다.\n최상위 폴더(루트)에서의 hugo.toml는 더이상 사용하지 않으므로 삭제합니다.\nrm hugo.toml 아래 명령어를 실행하면, 프로젝트 루트에 config 폴더가 생성되고 그 안에 _default 폴더와 함께 hugo.toml, params.toml 등의 기본 설정 파일들이 복사됩니다.\ncp -r themes/blowfish/config . 이제 복사된 설정 파일을 Hugo가 인식하도록 config/_default/hugo.toml 파일을 열어, 파일 최상단에 아래 내용을 수정합니다.\n# config/_default/hugo.toml theme = \u0026#34;blowfish\u0026#34; # baseURL을 자신의 환경에 맞게 수정합니다. baseURL = \u0026#34;https://your_domain.com/\u0026#34; 로컬 확인 및 최종 배포 # 모든 준비가 끝났습니다. 로컬 서버를 실행하여 Blowfish 테마가 적용되었는지 최종 확인합니다.\n# -D 옵션은 draft(초안) 상태의 글도 함께 보여줍니다. hugo server -D 브라우저에서 http://localhost:1313 으로 접속하여 새로운 블로그의 모습을 확인하세요. 메인 페이지, 글 목록, 검색 기능이 모두 잘 작동한다면 성공입니다.\n마지막으로, 변경된 내용을 서버에 배포합니다.\n# 모든 변경사항 추가 git add . # 테마 변경을 알리는 커밋 메시지 작성 git commit -m \u0026#34;Feat: Apply Blowfish theme\u0026#34; # 원격 저장소에 푸시하여 배포 완료 git push 마무리하며 # 지금까지 기존 Hugo 블로그에 Blowfish 테마를 적용하고 기본적인 설정을 마치는 전 과정을 함께했습니다. Blowfish는 params.toml 파일에 수많은 커스터마이징 옵션을 제공하므로, 시간을 갖고 천천히 살펴보시면 라이트/다크 모드, 폰트, 아이콘 등 블로그의 거의 모든 요소를 원하는 대로 바꿀 수 있습니다.\n이 가이드를 시작으로 여러분만의 개성이 가득한 멋진 블로그를 완성하시길 바랍니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-blowfish/","section":"","summary":"","title":"Hugo 블로그에 Blowfish 테마 적용하기","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":" # 안드로이드 앱 개발 시 메모리 누수는 앱의 성능을 저하시키고, 심할 경우 ANR(Application Not Responding)이나 OOM(Out of Memory) 오류를 발생시키는 주범입니다. 이번 글에서는 강력한 메모리 분석 도구인 Memory Analyzer(MAT) 를 사용하여 안드로이드 앱의 Java Heap Dump 파일을 분석하고 메모리 누수를 찾아내는 과정을 상세히 안내하겠습니다.\nHeap Dump 파일 생성하기 # 가장 먼저 분석할 메모리 스냅샷, 즉 Heap Dump 파일이 필요합니다. 안드로이드 스튜디오에서 간단하게 생성할 수 있습니다.\nAndroid Studio Profiler 실행:\n앱을 디버그 모드로 실행합니다. 하단의 Profiler 탭을 엽니다. Memory 프로파일러를 선택합니다. Heap Dump 생성:\n메모리 사용량을 모니터링하다가 분석하고 싶은 시점에 \u0026lsquo;Dump Java heap\u0026rsquo; 버튼 (아래 이미지의 아이콘)을 클릭합니다. 덤프가 완료되면 Android Studio가 자동으로 .hprof 파일을 생성하고 목록에 표시해 줍니다. 이제 분석의 재료가 되는 .hprof 파일이 준비되었습니다.\nhprof 파일 변환하기 (가장 중요!) # 안드로이드 스튜디오에서 생성된 .hprof 파일은 안드로이드 환경에 최적화된 형식입니다. 이 파일을 MAT에서 바로 열면 오류가 발생합니다. 따라서 MAT가 인식할 수 있는 표준 Java hprof 형식으로 변환해야 합니다.\n이때 hprof-conv라는 변환 도구를 사용합니다.\nhprof-conv 위치:\nAndroid SDK 설치 경로 내의 platform-tools 폴더에 있습니다. 예: C:\\Users\\[사용자명]\\AppData\\Local\\Android\\Sdk\\platform-tools 변환 명령어: 터미널이나 명령 프롬프트를 열고 아래 명령어를 실행합니다.\nhprof-conv [입력 파일 경로] [출력 파일 경로] 실행 예시: 원본 파일을 옮겼다고 가정해 보겠습니다.\ncd C:\\Users\\[사용자명]\\AppData\\Local\\Android\\Sdk\\platform-tools ./hprof-conv.exe C:\\Users\\[사용자명]\\Desktop\\original.hprof C:\\Users\\[사용자명]\\Desktop\\converted.hprof 이제 converted.hprof 라는 새로운 파일이 생성되었습니다. 이 파일을 MAT에서 사용하게 됩니다. 이 변환 과정을 잊으면 분석을 시작할 수 없으니 꼭 기억하시기 바랍니다.\nMemory Analyzer (MAT) 설치 및 실행 # MAT는 이클립스 재단에서 제공하는 무료 오픈소스 도구입니다.\n설치:\nEclipse MAT 공식 다운로드 페이지 에 접속하여 본인의 운영체제에 맞는 버전을 다운로드합니다. 압축을 풀기만 하면 바로 실행할 수 있는 독립 실행형(Standalone) 버전입니다. 실행:\n압축 해제한 폴더에서 MemoryAnalyzer 또는 mat 실행 파일을 실행합니다. MAT 실행을 위해서는 Java Runtime(JRE)이 설치되어 있어야 합니다. MAT으로 Heap Dump 파일 분석하기 # 이제 모든 준비가 끝났습니다. 변환된 Heap Dump 파일을 MAT으로 분석해 보겠습니다.\n파일 열기 # MAT를 실행하고 File \u0026gt; Open Heap Dump... 메뉴를 통해 아까 변환했던 converted.hprof 파일을 엽니다. 파일 크기에 따라 로딩 시간이 다소 걸릴 수 있습니다. Leak Suspects Report (누수 의심 보고서) # 파일을 열면 가장 먼저 아래와 같은 팝업창이 나타납니다. **\u0026lsquo;Leak Suspects Report\u0026rsquo;**를 선택하고 Finish를 누르는 것을 강력히 권장합니다. MAT가 자동으로 메모리 누수가 의심되는 지점을 분석하여 리포트 형태로 보여주기 때문입니다. 리포트가 생성되면 파이 차트와 함께 메모리 누수의 원인으로 의심되는 객체(Problem Suspect)가 표시됩니다. 보통 이 리포트만 잘 확인해도 문제의 절반은 해결됩니다. 주요 분석 기능 # Leak Suspects 보고서로 문제가 해결되지 않았다면, 더 깊게 분석해야 합니다. MAT의 핵심 기능 두 가지만 기억하면 충분합니다.\nHistogram (히스토그램)\n기능: 메모리에 로드된 모든 객체를 클래스별로 목록화하여 보여줍니다. 각 클래스의 인스턴스 수(Objects), 인스턴스 자체가 차지하는 메모리(Shallow Heap), 그리고 해당 인스턴스가 참조하는 다른 모든 객체까지 포함한 메모리(Retained Heap)를 확인할 수 있습니다. 사용법: 상단 툴바에서 히스토그램 아이콘을 클릭합니다. Retained Heap을 기준으로 내림차순 정렬합니다. 가장 위에 있는 항목들이 메모리를 가장 많이 점유하는 객체들입니다. 불필요하게 많은 인스턴스가 존재하거나, 비정상적으로 큰 메모리를 차지하는 클래스가 있는지 확인합니다. Dominator Tree (도미네이터 트리)\n기능: 객체 간의 참조 관계를 트리 구조로 보여주어, 어떤 객체가 다른 객체들의 생명주기를 \u0026lsquo;지배(Dominate)\u0026lsquo;하고 있는지 명확하게 보여줍니다. 즉, 특정 객체 하나를 제거했을 때 연쇄적으로 메모리에서 해제될 수 있는 객체들의 집합을 파악하는 데 가장 유용한 기능입니다. 사용법: 상단 툴바에서 도미네이터 트리 아이콘을 클릭합니다. 마찬가지로 Retained Heap 기준으로 정렬하여 가장 큰 메모리 덩어리를 찾습니다. 트리를 확장하며 어떤 객체(예: Activity, Context)가 예상과 달리 수많은 다른 객체들을 참조하고 있는지 추적합니다. 실용적인 팁: GC Root 경로 추적\n누수가 의심되는 객체를 찾았다면, 왜 이 객체가 가비지 컬렉터(GC)에 의해 수거되지 않는지 알아야 합니다.\nHistogram이나 Dominator Tree에서 의심되는 객체를 마우스 오른쪽 버튼으로 클릭합니다. Path to GC Roots \u0026gt; exclude all phantom/weak/soft etc. references를 선택합니다. 이 객체를 메모리에서 계속 붙잡고 있는 참조 경로(Chain of References)가 나타납니다. 보통 static 필드나 백그라운드 스레드, 혹은 잘못 관리된 리스너 등이 원인인 경우가 많습니다. 이 경로를 따라가면 누수의 근본 원인을 찾을 수 있습니다. 마무리하며 # 메모리 누수는 잡기 어려운 버그일 수 있지만, MAT과 같은 강력한 도구를 활용하면 체계적으로 접근하여 해결할 수 있습니다.\n핵심 요약:\nHeap Dump 생성: 안드로이드 스튜디오 프로파일러 사용 hprof 변환: hprof-conv 도구로 표준 형식으로 변환 (필수!) MAT 분석: Leak Suspects로 자동 분석 후, Dominator Tree와 Histogram으로 상세 분석 이 가이드가 안드로이드 앱의 성능과 안정성을 높이는 데 실질적인 도움이 되기를 바랍니다. 꾸준한 메모리 관리는 고품질 앱의 기본입니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/develop/android/debug-analyze-java-heap-dump-using-mat/","section":"","summary":"","title":"Memory Analyzer(MAT)으로 Android 앱의 Java Heap Dump 완벽 분석 가이드","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/termux/","section":"Tags","summary":"","title":"Termux","type":"tags"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/vscode/","section":"Tags","summary":"","title":"Vscode","type":"tags"},{"content":"\u0026ldquo;카페에서 태블릿으로 코딩을 할 수 있다면?\u0026rdquo;, \u0026ldquo;여행 중에 급하게 스마트폰으로 코드를 수정해야 한다면?\u0026rdquo; 이런 상상, 한 번쯤 해보셨을 겁니다. 오늘은 그 상상을 현실로 만드는 방법을 소개해 드리고자 합니다.\n바로 안드로이드의 강력한 리눅스 환경인 Termux와 웹 기반 VS Code인 code-server를 조합하여, 언제 어디서든 웹 브라우저만 있으면 접속할 수 있는 나만의 개발 서버를 구축하는 방법입니다.\n이 글은 독자 여러분께서 Termux를 이미 설치하고 기본적인 pkg update \u0026amp;\u0026amp; pkg upgrade 명령어를 통해 시스템을 최신 상태로 유지하고 있다는 가정하에 진행됩니다.\nTermux 설치 부터 필요하신 분은\n글을 참고해 주세요\n필수 패키지 설치 # code-server 설치 및 원활한 사용을 위해 필요한 기본적인 도구들을 먼저 설치합니다. Termux를 실행하고 아래 명령어를 입력해 주세요.\npkg upgrade pkg install proot-distro -y proot: Termux의 가상 파일 시스템 환경에 도움을 주는 유틸리티입니다. code-server 설치하기 # 이제 본격적으로 code-server를 설치할 차례입니다.\nubuntu 설치하기 # Termux 에서 code-server 직접 실행할 수 없기 때문에, ubuntu 가상 환경을 먼저 구성하겠습니다.\nproot-distro install ubuntu 이제 ubuntu 가상 환경에 로그인 합니다.\nproot-distro login ubuntu 아래와 같이 root@ubuntu 로 ubuntu에 로그인 되었음을 확인할 수 있습니다. code-server 설치하기 # 안드로이드 기기는 대부분 ARM 기반의 aarch64 아키텍처를 사용하는데, 복잡한 설치 과정을 자동화해주는 공식 설치 스크립트가 있어 매우 편리합니다.\n아래 명령어를 Termux에 그대로 입력하고 실행하세요.\napt update apt upgrade apt install wget curl curl -fsSL https://code-server.dev/install.sh | sh 이 스크립트는 현재 사용 중인 기기의 운영체제와 아키텍처를 자동으로 감지하여, 그에 맞는 최신 버전의 code-server를 다운로드하고 실행 가능한 상태로 설치해 줍니다.\n![[install-code-server-on-ubuntu.webp]]\ncode-server 실행 및 접속 # 설치가 완료되었다면, 이제 서버를 실행하고 접속해 보겠습니다.\n최초 실행 및 비밀번호 확인 # 아래 명령어로 code-server를 실행합니다.\ncode-server 서버가 시작되면 터미널에 몇 가지 정보가 나타납니다. 여기서 우리가 주목해야 할 것은 두 가지입니다.\n접속 주소: HTTP server listening on http://127.0.0.1:8080 (내부 접속 주소) 비밀번호 위치: Password is in ~/.config/code-server/config.yaml 이제 아래 명령어로 설정 파일의 내용을 확인하여 자동으로 생성된 비밀번호를 확인합니다.\ncat ~/.config/code-server/config.yaml 출력된 내용 중 password: 항목에 있는 긴 문자열이 여러분의 초기 비밀번호입니다.\nbind-addr: 127.0.0.1:8080 auth: password password: \u0026lt;\u0026lt;password\u0026gt;\u0026gt; #need to be changed cert: false 보안 팁: password: 항목을 원하는 비밀번호로 수정하고 서버를 재시작하세요.\n웹 브라우저로 접속 # 안드로이드 기기에서 Chrome과 같은 웹 브라우저를 열고, 주소창에 http://127.0.0.1:8080 또는 localhost:8080 을 입력하세요.\n![[vs-code-login.webp]]\nVS Code 로그인 화면이 나타나면, 방금 확인한 비밀번호를 입력합니다.\n![[vs-code-run.webp]]\n성공입니다! 이제 여러분의 안드로이드 기기 안에서 완벽하게 동작하는 VS Code가 생겼습니다.\n외부 기기에서 접속하기 # 이 설정의 진정한 묘미는 PC나 노트북 등 다른 기기에서 접속하여 코딩하는 것입니다.\n서버 실행 옵션 변경: code-server를 종료(Ctrl + C)하고, 외부 접속을 허용하는 옵션을 추가하여 다시 실행합니다.\ncode-server --bind-addr 0.0.0.0:8080 0.0.0.0은 모든 네트워크 인터페이스로부터의 접속을 허용하겠다는 의미입니다.\n안드로이드 기기 IP 주소 확인: Termux에 ifconfig 또는 ip addr 명령어를 입력하거나, 안드로이드의 \u0026lsquo;설정 \u0026gt; Wi-Fi\u0026rsquo; 메뉴에서 현재 연결된 Wi-Fi의 상세 정보로 들어가 IP 주소를 확인합니다. (예: 192.168.1.10)\n외부 기기에서 접속: 이제 노트북이나 PC의 웹 브라우저 주소창에 http://\u0026lt;여러분의-안드로이드-IP\u0026gt;:8080 (예: http://192.168.1.10:8080)을 입력하여 접속합니다. 동일하게 비밀번호를 입력하면 바로 코딩을 시작할 수 있습니다.\n보안 팁: 외부 접속을 허용할 경우, 추측하기 어려운 비밀번호로 변경하는 것이 좋습니다. ~/.config/code-server/config.yaml 파일을 직접 열어 password: 항목을 원하는 비밀번호로 수정하고 서버를 재시작하세요.\n마무리 및 활용 팁 # 이제 여러분의 안드로이드 기기는 저전력으로 24시간 구동 가능한 개인 개발 서버가 되었습니다.\n백그라운드 실행 유지: termux-wake-lock 명령어를 실행해두면 화면이 꺼져도 Termux 세션이 종료되는 것을 방지할 수 있습니다.\nVS Code 확장 프로그램: 일반 VS Code와 마찬가지로 확장 프로그램(Extensions) 탭에서 원하는 플러그인을 검색하고 설치하여 사용할 수 있습니다.\n파일 접근: termux-setup-storage 명령어로 저장 공간 접근 권한을 허용한 뒤, ~/storage 폴더를 통해 스마트폰의 내부 저장소에 접근하여 파일을 수정할 수 있습니다.\n이 강력한 휴대용 개발 환경을 통해 여러분의 생산성을 한 단계 끌어올려 보시길 바랍니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/termux/termux-with-code-server/","section":"","summary":"","title":"안드로이드 폰을 코딩 머신으로! Termux와 code-server로 VS Code 환경 구축하기","type":"posts"},{"content":" # Obsidian(옵시디언)으로 노트를 작성하다 보면 이미지를 첨부할 일이 많습니다. 그런데 이미지를 붙여넣을 때마다 파일이 보관소(Vault) 최상위 폴더에 저장되어 파일 관리가 번거로워지는 경험, 다들 한 번쯤 있으실 겁니다. 노트 파일과 이미지 파일이 따로 놀면 나중에 파일을 찾거나 관리하기가 매우 까다롭습니다.\n오늘은 이 문제를 해결하기 위해 이미지를 현재 작성 중인 노트와 동일한 위치에 저장하는 방법을 알아보겠습니다. 설정 하나만 변경하면 되니, 차근차근 따라오시면 됩니다.\n왜 이미지 저장 위치를 변경해야 할까? # Obsidian은 기본적으로 이미지를 보관소(Vault)의 루트 폴더에 저장합니다. 노트('*.md') 파일은 특정 폴더 안에 있는데, 이미지는 밖에 있으니 연관성이 떨어져 보입니다.\n이렇게 되면 다음과 같은 문제점이 발생할 수 있습니다.\n파일 관리의 어려움: 어떤 이미지가 어떤 노트에 속하는지 파악하기 어렵습니다. 링크 깨짐 현상: 나중에 노트 파일을 다른 폴더로 옮길 때 이미지 링크가 깨질 가능성이 높아집니다. 구조의 복잡성: 파일 탐색기(File Explorer) 뷰가 지저분해져 노트 전체의 구조를 파악하기 힘들어집니다. 따라서 노트와 관련 이미지를 같은 폴더에 묶어두는 것은 효율적인 노트 관리를 위한 필수적인 과정입니다.\n이미지 저장 위치 변경 방법 (3단계) # Obsidian 설정에서 \u0026lsquo;첨부 파일(Attachment)\u0026rsquo; 관련 옵션을 변경하면 간단하게 해결할 수 있습니다.\n1. 설정(Settings) 메뉴 열기\nObsidian 좌측 하단에 있는 톱니바퀴 모양의 \u0026rsquo;⛭(설정)\u0026rsquo; 아이콘을 클릭합니다.\n2. \u0026lsquo;파일 및 링크(Files \u0026amp; Links)\u0026rsquo; 탭 이동\n설정 창이 열리면 왼쪽 메뉴에서 \u0026lsquo;파일 및 링크\u0026rsquo; 탭을 선택합니다. 파일 생성 및 링크 처리와 관련된 다양한 옵션을 이곳에서 관리할 수 있습니다.\n3. \u0026lsquo;새 첨부 파일을 만들 위치\u0026rsquo; 설정 변경\n\u0026lsquo;파일 및 링크\u0026rsquo; 설정 항목 중에서 \u0026lsquo;새 첨부 파일을 만들 위치(Default location for new attachments)\u0026rsquo; 라는 옵션을 찾습니다.\n이 옵션의 드롭다운 메뉴를 클릭하면 여러 선택지가 나타납니다. 여기서 \u0026lsquo;현재 파일과 같은 폴더(Same folder as current file)\u0026rsquo; 를 선택합니다.\n설정은 자동으로 저장됩니다. 이제 설정 창을 닫고 노트에 이미지를 붙여넣어 보세요.\nCtrl + V (Windows/Linux) 또는 Cmd + V (macOS)를 사용해 클립보드의 이미지를 붙여넣거나, 이미지를 노트 편집창으로 드래그 앤 드롭하면 해당 노트 파일이 있는 폴더에 이미지 파일('*.png' 또는 '*.jpg')이 함께 생성되는 것을 확인할 수 있습니다.\n추가 팁: 하위 폴더에 정리하기 # 만약 노트와 동일한 위치이지만, 이미지 파일들을 별도의 하위 폴더에 정리하고 싶다면 다음과 같이 설정할 수 있습니다.\n\u0026lsquo;새 첨부 파일을 만들 위치\u0026rsquo; 옵션에서 \u0026lsquo;현재 폴더 아래의 하위 폴더에(In subfolder under current folder)\u0026rsquo; 를 선택합니다. 바로 아래에 나타나는 \u0026lsquo;하위 폴더 이름(Subfolder name)\u0026rsquo; 입력란에 원하는 폴더 이름(예: images, assets)을 입력합니다. 이렇게 설정하면 이미지를 붙여넣을 때마다 현재 노트가 위치한 폴더 안에 지정한 이름의 하위 폴더가 자동으로 생성되고, 그 안에 이미지 파일이 저장됩니다. 이는 노트 하나에 많은 이미지가 첨부될 때 파일을 깔끔하게 관리하는 데 매우 유용합니다.\n마치며 # 오늘은 Obsidian에서 이미지 파일을 현재 노트와 동일한 위치에 저장하는 방법을 알아보았습니다. 아주 간단한 설정 변경만으로도 노트 관리의 효율성을 크게 높일 수 있습니다.\nIT 개발자에게 있어 체계적인 문서와 파일 관리는 필수적인 역량입니다. Obsidian을 사용하시는 모든 분이 오늘 알려드린 방법을 통해 조금 더 구조화된 방식으로 노트를 관리하고, 지식 자산을 효과적으로 쌓아나가시길 바랍니다.\n궁금한 점이 있다면 언제든지 댓글로 남겨주세요.\n참조:\nObsidian 공식 도움말 - Attachments: https://help.obsidian.md/Files+and+links/Attachments ","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/saving-contents-to-specific-folder/","section":"","summary":"","title":"Obsidian 이미지, 글과 함께 저장하는 가장 간단한 방법","type":"posts"},{"content":"오늘은 제가 유용하게 사용하고 있는 노트 앱, Obsidian에서 이미지 파일을 효율적으로 관리하는 방법을 공유하고자 합니다. 바로 이미지를 WebP 포맷으로 변환하여 사용하는 것입니다.\nObsidian에 이미지를 많이 첨부하다 보면 보관소(Vault)의 용량이 커지고, 동기화나 백업 시 부담이 될 수 있습니다. 특히 고화질의 스크린샷이나 PNG 파일을 그대로 사용하면 파일 하나당 수 메가바이트(MB)에 달하기도 합니다.\n이 문제를 해결하기 위해 저는 이미지 파일을 WebP 포맷으로 변환하는 방법을 사용하고 있으며, 이를 자동화해주는 Obsidian 커뮤니티 플러그인을 중심으로 실질적인 노하우를 알려드리겠습니다.\n왜 WebP를 사용해야 할까요? # WebP는 구글(Google)이 웹 환경의 이미지 최적화를 위해 개발한 이미지 포맷입니다. 기존에 널리 사용되던 JPG나 PNG에 비해 여러 장점을 가집니다.\n더 작은 파일 크기: WebP는 손실/비손실 압축 기술을 모두 지원하며, 동일한 이미지 품질을 유지하면서도 파일 크기를 현저히 줄일 수 있습니다. 일반적으로 JPG보다 약 25~35%, PNG보다는 약 26% 더 작습니다. 품질 유지: 파일 크기를 줄이면서도 시각적으로 인지하기 어려운 수준의 품질 저하만 발생시켜 원본과 거의 유사한 퀄리티를 보장합니다. 다양한 기능 지원: PNG처럼 투명한 배경(알파 채널)을 지원하고, GIF와 같이 움직이는 이미지(애니메이션)도 지원합니다. Obsidian에 적용하면 노트 용량을 획기적으로 줄여 보관소 관리를 용이하게 하고, 동기화 속도 향상 및 저장 공간 확보라는 실질적인 이점을 얻을 수 있습니다.\nObsidian에서 WebP 변환을 자동화하는 방법: \u0026lsquo;Image Converter\u0026rsquo; 플러그인 # Obsidian에서는 커뮤니티 플러그인을 활용하여 이미지 변환 과정을 매우 간단하게 처리할 수 있습니다. 여러 플러그인이 있지만, 가장 기능이 강력하고 설정이 편리한 \u0026lsquo;Image Converter\u0026rsquo; 플러그인을 추천합니다.\nImage Converter 플러그인 설치 # Obsidian 설정(Settings) 메뉴를 엽니다. (단축키: Ctrl/Cmd + ,) 왼쪽 탭에서 Community plugins를 선택합니다. Browse 버튼을 클릭하여 커뮤니티 플러그인 목록을 엽니다. 검색창에 Image Converter를 입력하여 해당 플러그인을 찾고 Install 버튼을 눌러 설치합니다. 설치가 완료되면 Enable 버튼을 눌러 플러그인을 활성화합니다. Image Converter 플러그인 설정 # 플러그인을 활성화했다면, 이제 자신의 작업 스타일에 맞게 설정을 변경할 차례입니다. 설정(Settings) \u0026gt; Community Plugins 탭 아래에 Image Converter 메뉴가 추가된 것을 확인할 수 있습니다.\n저장 폴더, 이미지 리사이징, 정렬 등 다양한 부가 기능이 있으니 필요에 따라 설정을 조정하시면 됩니다.\n사용 예시 및 실질적인 팁 # 설정을 마쳤다면 이제 실제로 사용해볼 차례입니다.\n웹 페이지의 이미지나 스크린샷 캡처 도구로 이미지를 복사합니다. Obsidian 노트 편집기에 그대로 붙여넣기(Ctrl/Cmd + V) 합니다. \u0026lsquo;Image Converter\u0026rsquo; 플러그인이 작동하면서 자동으로 이미지가 WebP 포맷으로 변환되고, 설정한 경로와 파일명 규칙에 따라 저장됩니다. 위 이미지에서 볼 수 있듯, 간단한 붙여넣기 동작만으로 PNG 파일이 훨씬 가벼운 WebP 파일로 변환되어 저장된 것을 확인할 수 있습니다.\n팁: 기존에 Markdown으로 작성된 다른 문서들을 Obsidian으로 가져올 때도 매우 유용합니다. 이미지 파일들을 Obsidian 보관소의 특정 폴더(예: \u0026lsquo;images\u0026rsquo; 폴더)에 옮겨두고, 노트에서 해당 이미지를 참조하도록 링크만 수정하면 됩니다. 이 과정에서 \u0026lsquo;Image Converter\u0026rsquo; 플러그인이 자동으로 WebP로 변환해주지는 않지만, 외부 변환 도구를 사용하여 일괄 변환 후 옮겨두면 보관소 용량을 크게 절약할 수 있습니다.\n마무리하며 # Obsidian은 단순한 노트 앱을 넘어, 지식과 정보를 체계적으로 관리하는 강력한 도구입니다. 여기에 \u0026lsquo;Image Converter\u0026rsquo;와 같은 플러그인을 활용하여 이미지 파일을 WebP로 자동 변환하는 워크플로우를 구축하면, 장기적으로 보관소의 용량을 효율적으로 관리하고 쾌적한 사용 환경을 유지할 수 있습니다.\n개발자로서 다양한 도구를 사용해봤지만, Obsidian만큼 확장성과 자율성을 보장하는 툴은 드뭅니다. 오늘 소개해드린 방법이 여러분의 Obsidian 라이프를 한 단계 더 발전시키는 데 도움이 되기를 바랍니다.\n참조:\nImage Converter Plugin - Obsidian.md WebP - Google Developers ","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/converting-image-to-webp/","section":"","summary":"","title":"Obsidian 이미지, WebP로 가볍게 관리하는 실용적인 방법","type":"posts"},{"content":"Git을 처음 설치했거나 새로운 환경에서 작업을 시작할 때, 가장 먼저 해야 할 일은 사용자 정보를 설정하는 것입니다. Git은 커밋(Commit)을 할 때마다 이 정보를 사용하여 누가 변경사항을 만들었는지 기록합니다. 이 가이드에서는 Git 사용자 이름과 이메일 주소를 설정하는 방법, 그리고 추가적인 유용한 설정들을 다룹니다.\n사용자 이름과 이메일 설정 # Git에서 커밋 기록에 사용될 이름과 이메일 주소를 설정하는 것은 필수적입니다. --global 옵션을 사용하면 현재 컴퓨터의 모든 Git 저장소에 동일한 설정을 적용할 수 있습니다.\n터미널 또는 Git Bash를 열고 다음 명령어를 입력하세요.\n이름 설정:\ngit config --global user.name \u0026#34;사용자 이름\u0026#34; 예시:\ngit config --global user.name \u0026#34;홍길동\u0026#34; 이메일 주소 설정:\ngit config --global user.email \u0026#34;이메일@주소.com\u0026#34; 예시:\ngit config --global user.email \u0026#34;honggildong@example.com\u0026#34; GitHub 또는 다른 Git 호스팅 서비스에서 사용하는 이메일 주소를 등록하는 것이 일반적입니다.\n설정 확인하기 # 설정이 올바르게 되었는지 확인하려면 다음 명령어를 사용합니다.\n전체 설정 목록 확인:\ngit config --list 특정 설정 확인:\ngit config user.name git config user.email 명령어를 실행했을 때 이전에 입력한 사용자 이름과 이메일 주소가 출력된다면 성공적으로 설정된 것입니다.\nGit 설정의 세 가지 수준 # Git은 세 가지 다른 수준의 설정 파일을 사용합니다. 각 설정은 서로 다른 범위에 적용되며, 충돌 시에는 더 좁은 범위의 설정이 우선적으로 적용됩니다.\nLocal (--local): # 특정 저장소에만 적용되는 설정입니다. 저장소 내의 .git/config 파일에 저장됩니다. --global이나 --system 옵션 없이 git config 명령어를 사용하면 기본적으로 이 수준에 적용됩니다.\n적용 방법: git config user.name \u0026quot;프로젝트용 이름\u0026quot; 우선순위: 1순위 (가장 높음) Global (--global): # 현재 컴퓨터 사용자에게 적용되는 설정입니다. 사용자의 홈 디렉터리(~/.gitconfig)에 저장됩니다. 시스템의 모든 저장소에 공통으로 적용하고 싶을 때 사용합니다.\n적용 방법: git config --global user.name \u0026quot;내 기본 이름\u0026quot; 우선순위: 2순위 System (--system): # 시스템의 모든 사용자와 모든 저장소에 적용되는 설정입니다. Git 설치 경로의 etc/gitconfig 파일에 저장되며, 시스템 관리자 권한이 필요할 수 있습니다. 거의 사용할 일이 없습니다.\n적용 방법: git config --system user.name \u0026quot;시스템 공용 이름\u0026quot; 우선순위: 3순위 (가장 낮음) 예를 들어, --global로 \u0026ldquo;홍길동\u0026quot;을 설정하고 특정 프로젝트 폴더 안에서 --local로 \u0026ldquo;프로젝트A-홍길동\u0026quot;을 설정하면, 해당 프로젝트에서는 \u0026ldquo;프로젝트A-홍길동\u0026quot;이라는 이름으로 커밋이 기록됩니다.\n기본 편집기 설정 # Git이 커밋 메시지 등을 입력받기 위해 실행하는 기본 텍스트 편집기를 설정할 수 있습니다. 기본 편집기는 보통 Vim 또는 Nano로 설정되어 있어 익숙하지 않은 사용자에게는 불편할 수 있습니다. Visual Studio Code, Sublime Text 등 선호하는 편집기로 변경할 수 있습니다.\nVisual Studio Code로 설정:\ngit config --global core.editor \u0026#34;code --wait\u0026#34; Sublime Text로 설정:\ngit config --global core.editor \u0026#34;subl -n -w\u0026#34; Vim으로 설정 (기본값으로 되돌리고 싶을 경우):\ngit config --global core.editor \u0026#34;vim\u0026#34; 이제 git commit과 같이 편집기가 필요한 명령어를 실행하면 설정한 편집기가 열립니다.\n이 가이드를 통해 Git 사용을 위한 기본적인 사용자 설정을 마칠 수 있습니다. 올바른 사용자 정보 설정은 협업과 프로젝트 관리의 첫걸음입니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/git/user-setting/","section":"","summary":"","title":"Git 사용자 설정하기","type":"posts"},{"content":"수많은 HUGO 테마 중에서도 압도적인 인기를 자랑하는 테마가 있습니다. 바로 PaperMod 입니다. 빠른 속도, 미니멀한 디자인, 강력한 기능(SEO, 다크 모드, 검색 등)을 모두 갖추고 있어 전 세계 수많은 블로거와 개발자들의 사랑을 받고 있습니다.\n오늘은 기존에 운영하던 Hugo 블로그에 바로 이 PaperMod 테마를 적용하는 방법을, 처음부터 끝까지 상세하게 안내해 드리겠습니다.\n기존 테마 깔끔하게 제거하기 # 새로운 옷을 입기 전, 기존 옷을 먼저 정리해야겠죠. 현재 사용 중인 테마를 깔끔하게 제거하는 것부터 시작하겠습니다. 테마 설치 방식에 따라 아래 방법 중 하나를 선택하세요.\nGit 서브모듈로 설치된 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 이 명령어들은 단순히 폴더를 지우는 것을 넘어, Git의 추적 기록까지 완전히 정리해 줍니다.\n직접 다운로드하여 설치한 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. rm -rf themes/old-theme 또는 파일 탐색기에서 직접 themes/old-theme 폴더를 삭제해도 됩니다.\nPaperMod 테마 설치하기 # 이제 오늘의 주인공, PaperMod 테마를 설치할 차례입니다. 추후 테마 관리를 위해 Git 서브모듈 방식을 사용하는 것이 가장 좋습니다.\nGit 서브모듈로 추가:\n프로젝트의 최상위 폴더에서 아래 명령어를 입력합니다.\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod themes 폴더 안에 PaperMod라는 이름으로 테마가 설치됩니다.\n팁: PaperMod 테마는 다른 복잡한 테마들과 달리 Hugo Extended 버전이 필요 없습니다. 일반 Hugo 버전으로도 모든 기능을 완벽하게 사용할 수 있어 설치가 더욱 간편합니다.\nhugo.toml 설정하기 # PaperMod의 기능을 활성화하기 위해 블로그의 메인 설정 파일인 config.toml을 수정해야 합니다. 아래는 가장 기본적인 설정 예시입니다. 기존 설정을 참고하여 내용을 수정하거나 추가하세요.\nIni, TOML\nbaseURL = \u0026#34;https://your-blog-url.com/\u0026#34; languageCode = \u0026#34;ko-kr\u0026#34; title = \u0026#34;나의 PaperMod 블로그\u0026#34; theme = \u0026#34;PaperMod\u0026#34; # 테마를 PaperMod로 지정 [params] author = \u0026#34;블로거 이름\u0026#34; description = \u0026#34;PaperMod 테마를 적용한 제 블로그입니다.\u0026#34; defaultTheme = \u0026#34;auto\u0026#34; # \u0026#34;auto\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34; 중 선택 ShowReadingTime = true # 글 읽는 시간 표시 ShowShareButtons = true # 공유 버튼 표시 ShowPostNavLinks = true # 이전/다음 글 링크 표시 # 메인 페이지 설정 [params.homeInfoParams] Title = \u0026#34;안녕하세요! 👋\u0026#34; Content = \u0026#34;이곳은 PaperMod 테마로 만든 블로그입니다. 깔끔하고 빠르죠.\u0026#34; # 소셜 아이콘 설정 (예시) [[params.socialIcons]] name = \u0026#34;github\u0026#34; url = \u0026#34;https://github.com/your-github-id\u0026#34; [[params.socialIcons]] name = \u0026#34;linkedin\u0026#34; url = \u0026#34;https://www.linkedin.com/in/your-linkedin-id/\u0026#34; # 메인 메뉴 설정 [menu] [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;글 목록\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 10 [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;검색\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 20 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;태그\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 30 PaperMod는 이 외에도 수많은 설정(파라미터)을 제공합니다. 더 상세한 커스터마이징을 원하시면 공식 문서를 꼭 참고하세요.\n참조: PaperMod 테마 공식 위키 - 설정 가이드 로컬 확인 및 최종 배포 # 모든 준비가 끝났습니다. 로컬 서버를 실행하여 디자인이 의도대로 적용되었는지 최종 확인합니다.\n# -D 옵션은 draft(초안) 상태의 글도 함께 보여줍니다. hugo server -D 브라우저에서 http://localhost:1313 으로 접속하여 새로운 블로그의 모습을 확인하세요. 메인 페이지, 글 목록, 검색 기능이 모두 잘 작동한다면 성공입니다.\n마지막으로, 변경된 내용을 서버에 배포합니다.\n# 모든 변경사항 추가 git add . # 테마 변경을 알리는 커밋 메시지 작성 git commit -m \u0026#34;Feat: Apply PaperMod theme\u0026#34; # 원격 저장소에 푸시하여 배포 완료 git push 마무리하며 # PaperMod 테마는 미니멀리즘과 강력한 기능 사이에서 완벽한 균형을 이룬, 그야말로 \u0026lsquo;정석\u0026rsquo;과도 같은 테마입니다. 직접 적용해보시면 왜 이 테마가 그토록 많은 사랑을 받는지 바로 체감하실 수 있을 겁니다.\n이제 여러분의 블로그는 더 빠르고, 더 읽기 편하고, 더 전문적인 모습으로 방문자들을 맞이할 준비를 마쳤습니다.\n","date":"25 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-papermod/","section":"","summary":"","title":"HUGO 블로그 최고 인기 테마, PaperMod 적용 완벽 가이드","type":"posts"},{"content":"오늘은 빠르고 간결하기로 소문난 정적 사이트 생성기(Static Site Generator, SSG), Hugo를 사용하여 macOS 환경에서 나만의 블로그를 만드는 방법을 알아보겠습니다. 워드프레스와 같은 동적 사이트와 달리, Hugo는 데이터베이스나 복잡한 서버 로직 없이 순수 HTML, CSS, JS 파일로 웹사이트를 생성합니다. 덕분에 비교할 수 없이 빠른 속도, 강력한 보안, 그리고 무료에 가까운 호스팅 비용이라는 엄청난 장점을 가집니다.\n본격적인 시작에 앞서 준비물 확인하기 # 딱 한 가지만 준비하면 됩니다. 바로 Homebrew입니다. Homebrew는 macOS용 패키지 관리자로, 터미널 명령 한 줄로 각종 소프트웨어를 간단하게 설치할 수 있게 해주는 필수 도구입니다. 터미널을 열고 아래 명령어를 입력해 Homebrew가 설치되어 있는지 확인해 보세요.\nbrew --version 만약 버전 정보가 출력된다면 이미 설치된 것입니다. command not found와 같은 메시지가 나온다면, 아래 명령어를 터미널에 붙여넣어 Homebrew를 설치해 주세요.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Hugo 설치하기 # Homebrew가 준비되었다면 Hugo 설치는 식은 죽 먹기입니다. 터미널에 다음 명령어를 입력하세요.\nbrew install hugo 설치가 완료되면 Homebrew 때와 마찬가지로 버전 확인 명령어로 제대로 설치되었는지 확인합니다.\nhugo version 버전 정보가 보인다면 성공입니다. 이제 블로그를 만들 모든 준비가 끝났습니다.\n내 블로그 사이트 생성하기 # 이제 Hugo를 이용해 블로그의 뼈대를 만들어 보겠습니다. 원하는 경로로 이동한 후, 다음 명령어를 실행하세요. my-blog 부분은 여러분이 원하는 폴더 이름으로 변경해도 좋습니다.\nhugo new site my-blog 명령을 실행하면 my-blog라는 폴더가 생성되고, 그 안에 Hugo 사이트를 구성하는 기본 폴더와 파일들이 자동으로 만들어집니다.\n생성된 my-blog 폴더로 이동해 볼까요?\ncd my-blog ls -l 명령어로 폴더 구조를 살펴보면 다음과 같은 폴더들이 보일 겁니다.\narchetypes: 새 콘텐츠 파일의 기본 양식을 정의합니다. content: 여러분이 작성할 블로그 글(마크다운 파일)이 저장되는 곳입니다. data: 사이트에서 사용할 수 있는 구조화된 데이터 파일(YAML, JSON, TOML)을 저장합니다. layouts: 웹사이트의 HTML 템플릿 파일이 위치합니다. static: 이미지, CSS, JavaScript 파일 등 정적 자원들을 저장합니다. themes: 블로그의 디자인을 담당하는 테마가 설치되는 폴더입니다. hugo.toml: 사이트의 전반적인 설정을 담당하는 가장 중요한 파일입니다. 블로그 디자인(테마) 입히기 # 뼈대만 있는 블로그는 의미가 없겠죠? 이제 디자인을 입힐 차례입니다. Hugo는 전 세계 개발자들이 만들어 공유하는 수많은 무료 테마를 제공합니다.\nHugo 공식 테마 사이트 에서 마음에 드는 테마를 골라보세요.\n이 가이드에서는 입문용으로 가장 많이 사용되는 Ananke 테마를 기준으로 설명하겠습니다.\n먼저, 방금 만든 내 블로그 폴더를 Git 저장소로 초기화해야 합니다. 테마는 보통 Git Submodule이라는 기능으로 관리하는 것이 가장 편리하기 때문입니다.\ngit init 이제 아래 명령어로 Ananke 테마를 themes 폴더 안에 설치합니다.\ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 테마 설치 후, Hugo에게 우리가 이 테마를 사용할 것이라고 알려줘야 합니다. hugo.toml 파일을 열어 다음 한 줄을 추가해 주세요.\ntheme = \u0026#39;ananke\u0026#39; 첫 번째 글 작성하기 # 드디어 첫 번째 글을 작성할 시간입니다. Hugo는 명령어를 통해 아주 쉽게 새 글의 초안 파일을 만들 수 있습니다.\nhugo new posts/my-first-post.md 이 명령은 content/posts 폴더 안에 my-first-post.md 라는 마크다운 파일을 생성합니다. 파일을 열어보면 상단에 다음과 같은 Front Matter가 자동으로 생성된 것을 볼 수 있습니다.\n+++ title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T16:29:43+09:00 draft: true +++ 여기서 가장 중요한 것은 draft: true 입니다. 이는 이 글이 아직 초안 상태임을 의미합니다. 글을 발행하려면 이 값을 false로 변경해야 합니다.\n이제 Front Matter 아래에 마크다운 문법으로 자유롭게 글을 작성해 보세요.\n+++ date = \u0026#39;2025-06-25T22:46:21+09:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ ## It is first post Hello world! 로컬 서버에서 블로그 확인하기 # 내가 작성한 글이 블로그에 어떻게 보이는지 확인해 볼까요? Hugo는 내 컴퓨터에서 바로 사이트를 확인해 볼 수 있는 강력한 로컬 서버 기능을 내장하고 있습니다.\n터미널에서 아래 명령어를 실행하세요.\nhugo server -D 여기서 -D 옵션은 draft: true 상태인 초안 글까지 모두 포함해서 보여달라는 의미입니다. 개발 중에는 아주 유용한 옵션이니 기억해 두세요.\n서버가 실행되면 터미널에 다음과 같은 메시지가 나타납니다.\nWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1) 이제 웹 브라우저를 열고 주소창에 http://localhost:1313 을 입력해 보세요.\nAnanke 테마가 적용된 여러분의 첫 블로그가 눈앞에 나타났을 겁니다! 방금 작성한 my-first-post를 클릭해서 들어가 보세요. 글의 내용을 수정하고 저장하면, 브라우저가 자동으로 새로고침되며 변경사항이 즉시 반영되는 것을 확인할 수 있습니다.\n마무리 # 축하합니다! 여러분은 이제 Hugo로 만든 자신만의 블로그를 갖게 되었습니다.\n오늘 우리는 macOS 환경에서 Hugo를 설치하고, 새 사이트를 만들고, 테마를 적용하고, 첫 글을 작성하여 로컬 서버에서 확인하는 전 과정을 함께했습니다.\n궁금한 점이 있다면 언제든지 댓글로 질문해 주세요.\n참조\nHugo 공식 사이트: https://gohugo.io/ Hugo 공식 테마: https://themes.gohugo.io/ Homebrew: https://brew.sh/ ","date":"25 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-mac-os/","section":"","summary":"","title":"MacOS에서 Hugo로 나만의 블로그 만들기","type":"posts"},{"content":"지난번에는 리눅스와 macOS 환경에 Hugo를 설치하는 과정을 다루었습니다. 성공적으로 Hugo를 설치하셨다면 이제 본격적으로 콘텐츠를 채워나갈 차례입니다.\n오늘은 Hugo 사이트에 새로운 글을 추가하는 가장 대표적인 두 가지 방법에 대해 알아보겠습니다. 바로 Hugo의 기본 명령어인 hugo new를 사용하는 방법과, 이미 작성된 마크다운(.md) 파일을 직접 가져와 추가하는 방법입니다.\n각 방법의 장단점과 사용법을 명확히 이해하면 콘텐츠를 훨씬 효율적으로 관리할 수 있습니다.\nhugo new 명령어 사용하기 # hugo new는 Hugo에서 새 콘텐츠를 생성하는 공식적이고 가장 권장되는 방법입니다. 이 명령어를 사용하면 단순한 파일 생성을 넘어, 미리 설정된 양식(Archetype)에 따라 글의 기본 구조를 자동으로 만들어주기 때문입니다.\nFront Matter란? # hugo new를 이해하려면 먼저 Front Matter라는 개념을 알아야 합니다.\nFront Matter는 마크다운 파일의 가장 윗부분에 위치하는 정보 덩어리로, 해당 콘텐츠의 데이터를 담고 있습니다. 예를 들어 글의 제목, 작성일, 초안(draft) 상태, 태그, 카테고리 등이 여기에 해당합니다. Hugo는 이 정보를 바탕으로 사이트를 생성하고 콘텐츠를 분류합니다.\n주로 YAML(---) 또는 TOML(+++) 형식을 사용합니다.\nhugo new 명령어 사용법 # 터미널에서 Hugo 프로젝트 폴더로 이동한 후, 아래 명령어를 실행합니다.\nhugo new [콘텐츠 섹션]/[파일이름].md 예를 들어 posts라는 섹션에 my-first-post라는 제목의 글을 작성하고 싶다면 다음과 같이 입력합니다.\nhugo new posts/my-first-post.md ![[Pasted image 20250625153225.jpg]]\n명령어를 실행하면 content/posts/ 폴더 안에 my-first-post.md 파일이 생성됩니다. 생성된 파일을 열어보면 다음과 같은 내용이 자동으로 채워져 있습니다.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T14:30:00+09:00 draft: true --- (여기에 글의 본문을 작성합니다.) title: 파일 이름을 기반으로 자동으로 생성됩니다. 큰따옴표 안의 내용을 수정하면 됩니다. date: 파일이 생성된 시점의 날짜와 시간이 자동으로 입력됩니다. draft: true로 설정되어 있습니다. 이는 해당 글이 아직 초안 상태이며, 최종 빌드 시 사이트에 포함되지 않음을 의미합니다. 글 작성을 마친 후 이 값을 false로 변경하거나 줄을 삭제하면 정식으로 발행됩니다. 팁: hugo server -D 명령어로 서버를 실행하면 draft: true 상태인 초안 글도 미리보기 화면에서 확인할 수 있습니다.\n외부 마크다운 파일 직접 가져오기 # 이미 다른 곳(Notion, Obsidian, Typora 등)에서 작성해 둔 마크다운 파일이 있다면 hugo new 명령어를 거치지 않고 직접 파일 시스템에 추가할 수 있습니다.\n이 방법은 매우 간단하지만, 한 가지 필수 작업이 있습니다.\n직접 추가하는 방법 # 가져올 마크다운 파일을 준비합니다. 파일 최상단에 직접 Front Matter를 추가해야 합니다. Hugo가 해당 파일을 인식하고 처리하려면 최소한 title과 date 정보가 필요합니다. Front Matter가 추가된 파일을 원하는 콘텐츠 섹션 폴더(예: content/posts/)로 복사하거나 이동시킵니다. 예를 들어, my-imported-post.md라는 파일을 가져온다고 가정해 보겠습니다.\n파일을 텍스트 편집기로 열어 아래와 같이 Front Matter를 직접 작성해 줍니다.\n--- title: \u0026#34;외부에서 가져온 나의 포스트\u0026#34; date: 2025-06-20T10:00:00+09:00 draft: false tags: [\u0026#34;hugo\u0026#34;, \u0026#34;markdown\u0026#34;] --- 이 글은 외부 마크다운 편집기에서 작성되었습니다. Front Matter만 정확하게 추가해주면 Hugo 사이트에서 문제 없이 인식됩니다. 이렇게 수정한 파일을 content/posts/ 폴더에 넣기만 하면 Hugo가 다음 빌드 시 자동으로 이 파일을 포함하여 사이트를 생성합니다.\n어떤 방법을 사용해야 할까? # 새로운 글을 작성할 때는 hugo new 사용을 권장합니다. 일관된 구조와 필수 정보(특히 draft: true)를 자동으로 생성해주어 실수를 줄여주고 콘텐츠 관리를 체계적으로 만들어주기 때문입니다.\n기존에 작성된 마크다운 파일을 옮겨오거나 다른 플랫폼에서 콘텐츠를 이전할 때는 파일을 직접 추가하는 방법이 효율적입니다. 이때 Front Matter를 정확히 추가하는 것만 잊지 않으면 됩니다.\n두 가지 방법을 모두 알아두고 상황에 맞게 활용하여 즐겁고 효율적인 Hugo 블로깅 라이프를 즐기시길 바랍니다.\n참조\nHugo 공식 문서: hugo new ","date":"24 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/post-create/","section":"","summary":"","title":"HUGO 새 글 작성하기","type":"posts"},{"content":"","date":"23 June 2025","externalUrl":null,"permalink":"/tags/actions/","section":"Tags","summary":"","title":"Actions","type":"tags"},{"content":"","date":"23 June 2025","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"Github","type":"tags"},{"content":"지난 글에서는 Hugo 설치 방법을 다루었습니다. 이번에는 많은 분이 최종 목표로 삼는, https://\u0026lt;내-GitHub계정\u0026gt;.github.io 주소로 접속되는 나만의 대표 블로그를 구축하는 방법을 상세히 알아보겠습니다.\n이것을 GitHub에서는 사용자 사이트(User Site) 라고 부릅니다. GitHub Pages가 제공하는 가장 기본적이면서도 강력한 기능이죠. 복잡한 과정 없이, 오직 여러분의 GitHub 계정만으로 세상에 단 하나뿐인 블로그 주소를 가질 수 있습니다.\nGitHub 저장소(Repository) 생성하기 # 가장 깔끔하고 권장되는 방법은 소스코드와 실제 웹사이트 결과물을 분리하여 관리하는 것입니다. 이를 위해 GitHub에 두 개의 저장소를 생성합니다.\n소스코드 저장소 (Private 권장) # 역할: 로컬에서 작업하는 Hugo 프로젝트 전체(마크다운 글, 설정 파일, 테마 등)를 관리합니다. 이름: 자유롭게 지정합니다. (예: my-tech-blog) 공개 범위: 소스코드는 굳이 공개할 필요가 없으므로 Private으로 설정하는 것을 권장합니다. 배포용 저장소 (Public 필수) # 역할: Hugo가 빌드하여 생성한 최종 HTML, CSS 파일이 올라가는 공간입니다. 실제 블로그 웹사이트가 됩니다. 이름: 반드시 \u0026lt;GitHub계정명\u0026gt;.github.io 형식이어야 합니다. 이 규칙을 지켜야 GitHub Pages가 정상적으로 동작합니다. 공개 범위: 웹사이트로 외부에 공개되어야 하므로 반드시 Public으로 설정해야 합니다. SSH Deploy Key 설정 # 아래의 명령으로 deploy key를 아래와 같이 생성합니다.\nssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; gh-pages.pub: public key gh-pages: private key 배포용 저장소의 Settings 로 이동 후, Deploy Keys 항목에 public key를 입력후 Allow write access 항목을 체크합니다.\n소스코드 저장소의 Settings 로 이동 후, Secrets에 private key를 ACTIONS_DEPLOY_KEY로 입력합니다. 로컬 Hugo 프로젝트와 GitHub 연동 # 이제 로컬 my-blog 프로젝트 폴더를 방금 만든 소스코드 저장소(my-blog)와 연결합니다.\n로컬 프로젝트 폴더의 터미널에서 다음 명령어를 실행합니다.\n# 1. Git 저장소로 초기화 (이미 실행했다면 생략) git init # 2. 모든 파일 추가 및 첫 커밋 git add . git commit -m \u0026#34;첫 블로그 설정 및 콘텐츠 초기화\u0026#34; git branch -M main # 3. 원격 저장소(소스코드용) 연결 # \u0026lt;GitHub계정명\u0026gt;과 \u0026lt;저장소이름\u0026gt;을 본인의 정보로 변경하세요. git remote add origin https://github.com/\u0026lt;GitHub계정명\u0026gt;/my-tech-blog.git # 4. main 브랜치로 푸시 git push -u origin main Hugo 설정 파일에 URL 업데이트 # 로컬 Hugo 프로젝트의 설정 파일(hugo.toml 또는 config.toml)을 열어 baseURL을 배포용 저장소 주소로 변경해야 합니다. 이 설정은 링크나 리소스 경로가 올바르게 생성되도록 하는 중요한 역할을 합니다.\nhugo.toml 예시\n# baseURL을 실제 서비스될 블로그 주소로 변경합니다. baseURL = \u0026#34;https://\u0026lt;GitHub계정명\u0026gt;.github.io/\u0026#34; languageCode = \u0026#34;ko-kr\u0026#34; title = \u0026#34;나의 개발 블로그\u0026#34; theme = \u0026#34;적용중인_테마이름\u0026#34; # 예: PaperMod GitHub Actions 워크플로우 설정 # 이 단계가 자동화의 심장부입니다. 로컬 소스코드를 push할 때마다 GitHub 서버가 알아서 Hugo 사이트를 빌드하고, \u0026lt;계정명\u0026gt;.github.io 저장소에 결과물을 배포하도록 설정하겠습니다.\n로컬 프로젝트 루트에 .github/workflows 폴더를 만들고, 그 안에 deploy-hugo.yml 같은 이름의 파일을 생성합니다.\n# 폴더 생성 mkdir -p .github/workflows # yml 파일 생성 (macOS/Linux) touch .github/workflows/deploy-hugo.yml deploy-hugo.yml 파일에 아래 내용을 그대로 복사해 붙여넣습니다.\n.github/workflows/deploy-hugo.yml\nname: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: \u0026lt;GitHub계정명\u0026gt;/\u0026lt;GitHub계정명\u0026gt;.github.io publish_branch: master # default: gh-pages publish_dir: ./public external_repository: \u0026lt;GitHub계정명\u0026gt;/\u0026lt;GitHub계정명\u0026gt;.github.io 배포용 저장소 작성한 deploy-hugo.yml 파일을 저장합니다.\n소스코드 Push 및 배포 최종 확인 # 이제 마지막입니다. 로컬에서 변경된 내용(워크플로우 파일 추가 등)을 다시 소스코드 저장소로 push합니다.\ngit add . git commit -m \u0026#34;Add GitHub Actions workflow for auto-deployment\u0026#34; git push push가 완료되면, GitHub의 소스코드 저장소(my-blog)로 이동하여 Actions 탭을 클릭합니다.\nDeploy Hugo site to GitHub Pages 워크플로우가 자동으로 실행되는 것을 볼 수 있습니다. build와 deploy 작업이 순서대로 진행되며, 몇 분 후 모두 녹색 체크 표시로 바뀌면 성공입니다.\n최종 확인:\n이제 웹 브라우저를 열고 https://\u0026lt;GitHub계정명\u0026gt;.github.io 로 접속해 보세요. 로컬에서 hugo server로 보던 것과 동일한 블로그가 온라인에 게시된 것을 확인할 수 있습니다.\nTrouble Shooting # deploy 동작이 정상적을 완료되었지만, 블로그가 정상적으로 표시되지 않을 수 있습니다. 이 경우 배포용 저장소의 배포 위치를 확인해 주세요\nSource: Deploy from a branch Branch: master(main) - /docs 정리하며 # 축하합니다! 이제 여러분은 git push 한 번으로 글을 발행할 수 있는 근사한 자동화 블로그를 소유하게 되었습니다. 여러분의 지식과 경험을 이 새로운 공간에 차곡차곡 쌓아나가시길 바랍니다.\n","date":"23 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/deploy-hugo-on-github-pages-with-actions/","section":"","summary":"","title":"Hugo 블로그, GitHub Actions로 자동 배포하기","type":"posts"},{"content":"코딩과 글쓰기를 좋아하시는 분들이라면, PC 앞에 앉아야만 작업할 수 있다는 점이 때로는 번거롭게 느껴지셨을 겁니다. 만약 스마트폰만으로 언제 어디서든 블로그 글을 작성하고, 빌드하고, 테스트까지 할 수 있다면 어떨까요?\n이 가이드에서는 여러분의 스마트폰을 강력한 개발 환경으로 만들어주는 Termux와, 빠르고 유연한 정적 사이트 생성기 Hugo를 이용해 나만의 블로그를 만드는 방법을 알아봅니다.\n시작하기 전에: Termux 설치 확인 # 본격적인 시작에 앞서, 가장 핵심적인 준비물인 Termux 앱이 스마트폰에 설치되어 있어야 합니다.\n✅ 아직 Termux를 설치하지 않으셨나요?\n괜찮습니다. Termux의 설치부터 기본 설정까지 자세히 다룬 제 이전 글이 있습니다. 아래 링크의 글을 먼저 따라 설치를 완료하신 후, 다시 이 글로 돌아와 다음 단계를 진행해 주세요.\n[➡️ 참조: Android Termux에서 Hugo 블로그 만들기 ]\nTermux가 준비되셨다면, 이제 Hugo 블로그를 만들 준비가 거의 끝났습니다.\nTermux 환경 준비 및 업데이트 # 가장 먼저, 기존에 설치된 Termux의 패키지를 최신 상태로 만들어 개발 환경을 깔끔하게 준비하겠습니다. 오래된 패키지와의 충돌을 방지하는 중요한 과정입니다.\nTermux를 실행하고 아래 명령어를 입력하세요. 패키지 목록을 갱신하고 설치된 패키지를 최신 버전으로 업그레이드합니다.\npkg update \u0026amp;\u0026amp; pkg upgrade 중간에 Do you want to continue? [Y/n] 와 같은 질문이 나오면 Y를 누르고 엔터를 입력하면 됩니다. 이 과정이 오류 없이 완료되었다면, 다음 단계로 넘어갈 준비가 된 것입니다.\nHugo와 Git 설치하기 # 블로그를 만들기 위해 필요한 핵심 도구들을 설치할 차례입니다.\nHugo: Go 언어로 만들어진 매우 빠른 정적 사이트 생성기(Static Site Generator, SSG)입니다. Git: 버전 관리 시스템입니다. Hugo 테마를 다운로드하거나, 나중에 블로그 코드를 GitHub 등에 백업할 때 필수적입니다. 아래 명령어로 두 패키지를 한 번에 설치합니다.\npkg install hugo git 설치가 잘 되었는지 확인해볼까요? 아래 명령어를 각각 입력하여 버전 정보가 나오면 성공입니다.\nhugo version git version Hugo 블로그 사이트 생성 # 이제 본격적으로 블로그의 뼈대를 만들어 보겠습니다.\n새 사이트 생성 hugo new site 명령어 뒤에 원하는 폴더 이름을 지정합니다. 여기서는 my-blog라는 이름으로 만들겠습니다.\nhugo new site my-blog 생성된 폴더로 이동 cd 명령어를 사용해 방금 만든 my-blog 폴더 안으로 들어갑니다.\ncd my-blog 테마 설치 및 적용 # 디자인 테마를 적용하여 블로그에 옷을 입혀야 합니다. 인기 있는 ananke 테마를 예시로 설치해 보겠습니다.\nGit으로 테마 추가 Git의 submodule 기능을 이용해 테마를 추가합니다.\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 설정 파일에 테마 적용 nano hugo.toml 명령어로 설정 파일을 열고, 아래 내용을 참고하여 수정하거나 추가합니다.\nbaseURL = \u0026#39;https://example.org/\u0026#39; languageCode = \u0026#39;ko-kr\u0026#39; title = \u0026#39;나의 첫 Hugo 블로그\u0026#39; theme = \u0026#39;ananke\u0026#39; 수정이 끝났으면 Ctrl + X, Y, Enter 순서로 눌러 저장하고 빠져나옵니다.\n첫 번째 글 작성하기 # hugo new content 명령어로 첫 글의 파일을 생성합니다.\nhugo new content posts/my-first-post.md nano content/posts/my-first-post.md 명령어로 파일을 열고, draft: true를 draft: false로 변경한 후 내용을 작성하세요.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T09:25:37+09:00 draft: false --- ## 안녕하세요! 여기는 제 첫 번째 Hugo 블로그 글입니다. **Termux**와 **Hugo**를 사용해서 만들었죠. - 정말 간편합니다. - 어디서든 작업할 수 있습니다. 로컬 서버 실행 및 확인 # 모든 준비가 끝났습니다. Hugo에 내장된 개발용 웹 서버를 실행하여 결과를 확인해 보겠습니다.\nmy-blog 폴더 안에서 아래 명령어를 실행하세요.\nhugo server 서버가 실행되면 Web Server is available at http://localhost:1313/ 메시지가 나타납니다. 스마트폰의 웹 브라우저를 열고 주소창에 http://localhost:1313을 입력해 보세요.\n여러분이 직접 만든 블로그가 눈앞에 나타날 것입니다.\n다음 단계는? # 축하합니다! 이제 여러분은 스마트폰만으로 Hugo 블로그를 만들고 관리할 수 있는 환경을 완벽하게 갖추었습니다.\n다음 목표는 이 블로그를 GitHub Pages나 Netlify 같은 서비스를 통해 웹에 **배포(Deploy)**하여 전 세계 누구나 접속할 수 있도록 만드는 것입니다. 이 과정은 다음 글에서 자세히 다루도록 하겠습니다.\n이제 여러분의 손안에 강력한 블로깅 도구가 생겼습니다. 언제 어디서든 떠오르는 영감을 놓치지 말고 기록하고, 여러분의 지식과 경험을 세상과 공유해 보세요.\n","date":"22 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-android-termux/","section":"","summary":"","title":"Android Termux에서 Hugo 블로그 만들기","type":"posts"},{"content":"오늘은 개발자들 사이에서 빠르고 강력하기로 정평이 난 정적 사이트 생성기(SSG), Hugo를 사용하여 Ubuntu 환경에서 나만의 블로그를 만드는 전체 과정을 안내해 드리겠습니다.\nWordPress와 같은 동적 CMS에 익숙하신 분들께 \u0026lsquo;정적 사이트\u0026rsquo;라는 개념이 낯설 수 있습니다. 간단히 설명하자면, 사용자가 요청할 때마다 데이터베이스를 거쳐 페이지를 만드는 동적 방식과 달리, 정적 사이트는 미리 완성된 HTML 파일을 서버에 올려두고 그대로 보여주는 방식입니다. 이 덕분에 로딩 속도가 매우 빠르고, 데이터베이스가 없어 보안에도 훨씬 유리합니다.\n이 가이드는 Ubuntu 환경과 터미널 사용에 어느 정도 익숙한 분들을 대상으로 합니다. 차근차근 따라오시면, 누구나 자신만의 빠르고 멋진 블로그를 가질 수 있습니다.\nHugo 설치하기 # 가장 먼저 할 일은 Hugo를 우리 Ubuntu 시스템에 설치하는 것입니다. 여러 방법이 있지만, 패키지 관리자인 snap을 이용하는 것이 가장 간단하고 최신 버전을 유지하기 좋습니다.\nsudo snap install hugo 설치가 완료되면, 버전 확인 명령어로 제대로 설치되었는지 확인합니다.\nhugo version 만약 hugo v0.127.0-... 와 같은 버전 정보가 출력된다면 성공적으로 설치된 것입니다.\n새 블로그 프로젝트 생성 # 이제 Hugo를 이용하여 블로그의 기본 뼈대를 만들 차례입니다. 원하는 경로로 이동한 후, 아래 명령어를 실행하여 my-blog라는 이름의 새 사이트를 생성합니다. (물론 my-blog는 원하는 이름으로 변경 가능합니다.)\nhugo new site my-blog 명령이 실행되면 my-blog라는 디렉토리가 생성되고, 그 안에는 다음과 같은 Hugo의 표준 디렉토리 구조가 만들어집니다.\nmy-blog/ ├── archetypes/ ├── content/ ├── data/ ├── layouts/ ├── public/ ├── static/ ├── themes/ └── hugo.toml 각 디렉토리의 역할은 간단히 다음과 같습니다.\ncontent/: 실제 블로그 글(마크다운 파일)이 저장되는 곳입니다. themes/: 블로그의 디자인을 담당하는 테마가 위치합니다. static/: 이미지, CSS, JavaScript 등 정적 파일들을 넣는 곳입니다. hugo.toml: 블로그의 제목, 언어, 테마 등 전반적인 설정을 담당하는 파일입니다. 테마 선택 및 적용 # 뼈대만 있는 블로그에 디자인 테마를 입혀야 합니다. Hugo는 전 세계 개발자들이 만들어 공유하는 수많은 테마를 자랑합니다.\nHugo 공식 테마 사이트 에서 마음에 드는 테마를 골라보세요.\n이 가이드에서는 \u0026lsquo;Ananke\u0026rsquo;라는 인기 있고 깔끔한 테마를 예시로 사용하겠습니다. my-blog 디렉토리 안에서 다음 명령어를 실행하여 테마를 설치합니다.\ncd my-blog git init # 아직 git 저장소가 아니라면 초기화합니다. git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke git submodule을 사용하는 이유는 테마의 원본 저장소와 연결을 유지하여, 나중에 테마가 업데이트되었을 때 쉽게 반영할 수 있기 때문입니다.\n이제 설치한 테마를 블로그에 적용할 차례입니다. hugo.toml 설정 파일을 열고 맨 아래에 다음 한 줄을 추가합니다.\ntheme = \u0026#39;ananke\u0026#39; 첫 번째 글 작성하기 # 블로그의 핵심은 콘텐츠입니다. Hugo는 마크다운(.md) 형식으로 글을 작성합니다. 터미널에서 아래 명령어로 첫 번째 글을 생성해 보겠습니다.\nhugo new content posts/my-first-post.md 이 명령은 content/posts/ 디렉토리 안에 my-first-post.md 파일을 생성합니다. 이제 텍스트 에디터로 이 파일을 열어보겠습니다.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T10:25:51+09:00 draft: true --- 여기에 본문 내용을 작성합니다. **안녕하세요, Hugo!** 파일 상단의 ---로 둘러싸인 부분을 Front Matter라고 부릅니다. 글의 제목, 작성일, 공개 여부 등 메타데이터를 정의하는 중요한 영역입니다.\n가장 중요한 점! draft: true는 이 글이 아직 초고 상태임을 의미합니다. 블로그에 정식으로 발행하려면 이 값을 draft: false로 변경하거나 이 줄을 삭제해야 합니다.\n이제 Front Matter 아래에 자유롭게 마크다운 문법으로 글을 작성하면 됩니다.\n로컬 서버에서 확인하기 # 작성한 글이 블로그에서 어떻게 보일지 궁금하실 겁니다. Hugo는 강력한 내장 웹 서버를 제공하여, 내 컴퓨터에서 실시간으로 변경사항을 확인하며 작업할 수 있습니다.\nmy-blog 디렉토리에서 아래 명령어를 실행하세요.\nhugo server -D 여기서 -D 옵션은 draft: true 상태인 초고 글까지 모두 포함해서 보여달라는 의미입니다. 개발 중에는 아주 유용한 옵션입니다.\n터미널에 다음과 같은 메시지가 나타날 것입니다.\nWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1) 이제 웹 브라우저를 열고 주소창에 http://localhost:1313을 입력해 보세요. 방금 설치한 Ananke 테마가 적용되고, 작성한 첫 번째 글이 목록에 나타나는 것을 확인할 수 있습니다.\n마치며 # 지금까지 Ubuntu 환경에서 Hugo를 설치하고, 블로그를 생성하여 첫 글을 작성하고, 서버에 배포할 파일을 만드는 전체 과정을 알아보았습니다.\nHugo는 처음에는 조금 낯설 수 있지만, 일단 익숙해지면 그 속도와 단순함, 그리고 강력한 기능에 매료될 것입니다. 오늘 만든 기본 블로그를 바탕으로 자신만의 테마를 만들거나, 다양한 설정을 변경하며 개성 있는 블로그로 발전시켜 나가시길 바랍니다.\n궁금한 점이 있다면 언제든 댓글로 질문해 주세요. 여러분의 성공적인 블로그 운영을 응원하겠습니다.\n참조:\nHugo 공식 문서: https://gohugo.io/documentation/ Hugo 테마 사이트: https://themes.gohugo.io/ ","date":"21 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-ubuntu/","section":"","summary":"","title":"Ubuntu에서 Hugo로 나만의 블로그 만들기","type":"posts"},{"content":"정적 사이트 생성기(Static Site Generator), 그중에서도 Go 언어로 작성되어 압도적인 빌드 속도를 자랑하는 Hugo에 대한 관심이 뜨겁습니다. 저 또한 Hugo를 활용하여 블로그를 구축하고 운영하면서 다양한 경험과 노하우를 글로 기록해왔습니다.\n그동안 작성했던 Hugo 관련 글들이 여러 곳에 흩어져 있어 정보를 찾아보기 불편하다는 의견이 있었습니다.\n그래서 오늘은 Hugo를 처음 시작하는 입문자부터, 테마를 직접 수정하고 배포 자동화를 고민하는 분들까지 모두를 위해 제가 작성한 모든 Hugo 관련 글을 한 페이지에서 쉽게 찾아볼 수 있도록 정리했습니다.\n이 글 하나만 북마크해두시면, Hugo 블로그 운영에 필요한 모든 정보를 얻어 가실 수 있을 겁니다.\nHugo 시작하기: 설치 및 기본 사이트 생성 # Hugo를 처음 접하는 분들을 위한 시리즈입니다. Hugo 설치부터 기본 사이트 생성 방법, Github Actions를 통해서 배포까지 안내합니다.\nUbuntu에서 Hugo로 나만의 블로그 만들기 21 June 2025\u0026middot;611 words\u0026middot;3 mins MacOS에서 Hugo로 나만의 블로그 만들기 25 June 2025\u0026middot;647 words\u0026middot;4 mins Android Termux에서 Hugo 블로그 만들기 22 June 2025\u0026middot;548 words\u0026middot;3 mins Hugo 프로젝트를 위한 완벽한 .gitignore 설정 가이드 27 June 2025\u0026middot;612 words\u0026middot;3 mins Hugo 블로그, GitHub Actions로 자동 배포하기 23 June 2025\u0026middot;651 words\u0026middot;4 mins 내 블로그가 세상과 만나는 주소, GitHub Pages에 커스텀 도메인 연결하기 8 July 2025\u0026middot;610 words\u0026middot;3 mins 휴고 블로그 커스텀 도메인이 자꾸 사라져요! CNAME 파일 유지 방법 (static 폴더 사용) 8 July 2025\u0026middot;404 words\u0026middot;2 mins Hugo Blowfish 테마: 내 사이트를 구글에 알리는 첫걸음, 서치 콘솔 등록 가이드 8 July 2025\u0026middot;668 words\u0026middot;4 mins Hugo Blowfish에 구글 애널리틱스 적용하기 10 July 2025\u0026middot;472 words\u0026middot;3 mins Hugo 테마: 커스터마이징과 나만의 기능 추가 # 미리 만들어진 테마를 설치하고, 내 입맛에 맞게 수정하는 방법을 다룹니다. HTML/CSS 기본 지식이 있다면 누구나 따라 할 수 있도록 쉬운 내용부터 고급 기법까지 차근차근 설명합니다.\n테마 설치하기 # HUGO 블로그 최고 인기 테마, PaperMod 적용 완벽 가이드 25 June 2025\u0026middot;523 words\u0026middot;3 mins Hugo 블로그에 Hextra 테마 적용하는 가장 간단한 방법 28 June 2025\u0026middot;285 words\u0026middot;2 mins Hugo 블로그에 Blowfish 테마 적용하기 27 June 2025\u0026middot;391 words\u0026middot;2 mins Blowfish 테마 설정하기 # Blowfish 테마: 기본 저자 정보 설정하기 28 June 2025\u0026middot;244 words\u0026middot;2 mins Blowfish 테마: 사이트 제목과 로고 설정하기 28 June 2025\u0026middot;293 words\u0026middot;2 mins Blowfish 테마: 메뉴 설정 가이드 (Main, Footer, Dropdown) 29 June 2025\u0026middot;532 words\u0026middot;3 mins Blowfish 테마: 파비콘(Favicon) 설정하기 1 July 2025\u0026middot;417 words\u0026middot;2 mins 콘텐츠 작성과 관리: 마크다운과 Frontmatter, Shortcode 활용법 # Hugo에서 콘텐츠를 어떻게 작성하고 관리하는지에 대한 글들입니다. 마크다운 문법을 기본으로, 콘텐츠의 메타 데이터를 관리하는 프론트매터(Frontmatter)와 콘텐츠 구조를 정의하는 아키타입(Archetypes) 활용법을 다룹니다. Frontmatter와 Shortcode 등의 특수한 기능은 특정 테마에서만 지원하는 경우가 많기에 이후에는 blowfish theme 기준으로 설명하겠습니다.\nBlowfish 테마: 콘텐츠 구조화 가이드 29 June 2025\u0026middot;508 words\u0026middot;3 mins HUGO 새 글 작성하기 24 June 2025\u0026middot;483 words\u0026middot;3 mins 앞으로도 Hugo와 관련된 유용한 팁과 정보가 생기면 이 글에 꾸준히 업데이트할 예정입니다. Hugo를 사용하시면서 궁금한 점이나 막히는 부분이 있다면 언제든지 댓글로 질문 남겨주시기 바랍니다.\n","date":"20 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/hugo-a-to-z/","section":"","summary":"","title":"Hugo 설치부터 배포까지 A to Z","type":"posts"},{"content":"우리가 매일 사용하는 스마트폰은 강력한 AP와 충분한 메모리를 갖춘 훌륭한 개발 및 서버 관리 도구가 될 수 있습니다. 그 중심에는 Termux라는 강력한 터미널 앱이 있습니다. 이번 글에서는 Termux를 \u0026lsquo;올바르게\u0026rsquo; 설치하고 개발에 필요한 기본 환경을 설정하는 방법을 2025년 최신 정보 기준으로 다시 한번 알려드립니다.\nPlay 스토어 vs F-Droid # 많은 분들이 습관적으로 구글 플레이 스토어에서 앱을 검색하고 설치합니다. 하지만 Termux의 경우, 이것이 가장 큰 실수를 유발하는 지점입니다.\n결론부터 말씀드리겠습니다. 2025년 현재, 구글 플레이 스토어에 등록된 Termux는 여전히 업데이트가 중단된 deprecated(사용 중단) 버전입니다.\n사용자분께서 Play 스토어에서 업데이트가 된다고 보셨다면, 이는 Termux의 플러그인(Add-on)이거나, 유사한 이름의 다른 앱일 가능성이 높습니다. 공식 com.termux 앱 패키지는 다음과 같은 이유로 Play 스토어에서 사용해서는 안 됩니다.\n업데이트 중단: 2020년 9월 이후로 메인 앱의 업데이트가 없습니다. 보안 취약점: 5년 가까이 업데이트되지 않은 패키지는 수많은 보안 취약점을 내포하고 있습니다. 저장소(Repository) 문제: 패키지를 다운로드하는 서버 주소가 변경되어 pkg update 같은 핵심 명령어가 정상적으로 동작하지 않습니다. Termux 개발팀은 이러한 문제 때문에 공식적으로 F-Droid 또는 GitHub를 통한 설치를 권장하고 있습니다.\n따라서, Termux의 모든 기능을 안전하고 정상적으로 사용하려면 반드시 F-Droid 또는 GitHub에서 직접 설치해야 합니다. 이 점을 다시 한번 강조합니다.\nTermux 설치하기 # F-Droid는 안드로이드용 자유-오픈 소스 소프트웨어(FOSS)를 제공하는 신뢰할 수 있는 저장소입니다.\nF-Droid 웹사이트 방문 아래 링크를 통해 F-Droid의 Termux 페이지로 이동합니다. https://f-droid.org/packages/com.termux/ APK 파일 다운로드 페이지를 아래로 스크롤하여 \u0026lsquo;Versions\u0026rsquo; 섹션을 찾고, 가장 최신 버전의 \u0026lsquo;Download APK\u0026rsquo; 버튼을 눌러 설치 파일을 다운로드합니다.\n설치 진행 다운로드한 APK 파일을 실행하여 설치합니다. \u0026lsquo;알 수 없는 출처의 앱 설치\u0026rsquo; 권한이 필요할 수 있습니다. 안드로이드 시스템의 안내에 따라 권한을 허용하고 설치를 완료합니다.\nTermux 초기 설정 # 설치를 완료하고 앱을 실행하면, 검은 화면에 커서가 깜빡이는 익숙한 터미널 환경을 마주하게 됩니다. 가장 먼저 패키지들을 최신 상태로 만들어야 합니다.\n아래 명령어를 입력하세요.\npkg update \u0026amp;\u0026amp; pkg upgrade pkg: Termux에서 사용하는 패키지 관리자입니다. Debian 계열 리눅스의 apt와 유사한 역할을 합니다. update: 설치 가능한 패키지 목록을 최신 정보로 갱신합니다. upgrade: 현재 설치된 패키지들을 최신 버전으로 업그레이드합니다. 중간에 몇 가지 질문이 나올 수 있는데, 기본값(Y 또는 N)을 선택하여 엔터를 누르면 무난하게 진행됩니다.\n필수 도구 설치하기 # 이제 개발에 필요한 핵심 도구들을 설치해 보겠습니다.\n저장소 접근 설정 # Termux가 스마트폰의 파일 시스템(다운로드, 사진 폴더 등)에 접근하려면 권한 설정이 필요합니다.\ntermux-setup-storage 위 명령어를 실행하면 저장 공간 접근 권한을 요청하는 팝업이 나타납니다. \u0026lsquo;허용\u0026rsquo; 을 선택하세요.\n이제 홈 디렉터리(~)에 storage라는 이름의 심볼릭 링크(바로가기)가 생성됩니다. 이 폴더를 통해 스마트폰 내부 저장소에 접근할 수 있습니다.\n텍스트 에디터 (nano) # 간단한 스크립트나 설정 파일을 수정하려면 텍스트 에디터가 필요합니다. nano는 사용법이 직관적이라 초심자에게 적합합니다.\npkg install nano SSH 클라이언트 (openssh) # 원격 서버에 접속하여 작업하는 것은 개발자의 기본 업무 중 하나입니다. openssh를 설치하여 SSH 클라이언트를 사용할 수 있습니다.\npkg install openssh 아래 명령을 통해서 ssh key를 생성합니다.\nssh keygen ~/.ssh 폴더 내부에, id_ed25519 , id_ed25519.pub 파일이 정상적으로 생성완료 되면, ssh 접속을 사용할 수 있습니다.\n버전 관리 시스템 (git) # 소스 코드 관리를 위해 Git은 필수입니다.\npkg install git 프로그래밍 언어 (Python) # 다양한 자동화 스크립트 및 개발에 널리 사용되는 Python을 설치해 보겠습니다.\npkg install python 마치며 # 정확한 정보를 바탕으로 올바른 도구를 사용하는 것이 안전하고 효율적인 개발의 첫걸음입니다. F-Droid를 통해 최신 버전의 Termux를 설치하여, 안전하고 강력한 휴대용 개발 환경을 구축하시길 바랍니다.\n이제 여러분의 안드로이드 기기는 언제 어디서든 사용할 수 있는 훌륭한 보조 개발 머신이 되었습니다.\n참조\nTermux 공식 웹사이트: https://termux.dev/en/ Termux F-Droid 페이지: https://f-droid.org/packages/com.termux/ ","date":"19 June 2025","externalUrl":null,"permalink":"/posts/apps/termux/termux-setup-on-android/","section":"","summary":"","title":"안드로이드, 리눅스 머신으로 변신시키기: Termux 설치와 기본 설정 가이드 (2025년 최신판)","type":"posts"},{"content":"Docker를 사용하면서 경험했던 내용을 모두 작성하고 있습니다.\n","date":"15 June 2025","externalUrl":null,"permalink":"/posts/develop/docker/","section":"","summary":"","title":"Docker 사용하기","type":"posts"},{"content":"Hugo 블로그를 운영하면서 경험했던 내용을 모두 작성하고 있습니다.\nHugo 설치부터 배포까지 A to Z 20 June 2025\u0026middot;431 words\u0026middot;3 mins ","date":"15 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/","section":"","summary":"","title":"Hugo 블로그 운영하기","type":"posts"},{"content":"여러가지 홈서버 관리와 관련된 경험과 노하우를 글로 기록해왔습니다.\n","date":"15 June 2025","externalUrl":null,"permalink":"/posts/hosting/server/","section":"","summary":"","title":"Server 관리하기","type":"posts"},{"content":"","date":"15 June 2025","externalUrl":null,"permalink":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/","section":"Tags","summary":"","title":"블로그","type":"tags"},{"content":"여러가지 Self Hosting 서비스를 사용해 보면서 겪은 경험과 노하우를 글로 기록해왔습니다.\n","date":"15 June 2025","externalUrl":null,"permalink":"/posts/hosting/services/","section":"","summary":"","title":"유용한 Self Hosting 서비스들","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]