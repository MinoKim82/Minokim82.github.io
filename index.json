[{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/","section":"My awesome blog","summary":"","title":"My awesome blog","type":"page"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/tags/obsidian/","section":"Tags","summary":"","title":"Obsidian","type":"tags"},{"content":"디지털 세상에서 정보는 흩어지기 쉽습니다. 특히 여러 장치에서 노트를 작성하고 관리하는 분들이라면, 모든 기기에서 최신 정보를 유지하는 것이 얼마나 중요한지 공감하실 것입니다. 오늘은 Obsidian 사용자를 위한 강력한 동기화 솔루션인 Self-hosted LiveSync 플러그인을 소개하고, CouchDB를 이용해 직접 동기화 환경을 구축하는 방법을 안내해 드리고자 합니다. 이 글은 공식적인 유료 서비스인 Obsidian Sync를 대체할 수 있는 방법을 찾는 분들을 위해 작성되었습니다. 조금은 기술적인 내용이 포함될 수 있지만, 차근차근 따라 하실 수 있도록 최대한 쉽고 명확하게 설명해 드리겠습니다.\nSelf-hosted LiveSync 플러그인이란? # Self-hosted LiveSync는 Obsidian의 커뮤니티 플러그인 중 하나로, 사용자가 직접 제어하는 서버를 통해 노트 데이터를 거의 실시간으로 동기화할 수 있게 해주는 도구입니다. 공식 서비스와 달리 월별 비용이 발생하지 않으며, 데이터의 소유권을 온전히 사용자에게 보장한다는 큰 장점이 있습니다.\n동기화 서버로는 CouchDB, IBM Cloudant 등 호환되는 데이터베이스를 사용할 수 있으며, 이 가이드에서는 널리 사용되고 비교적 설정이 용이한 CouchDB를 기준으로 설명하겠습니다.\nCouchDB란?\nApache 소프트웨어 재단에서 개발한 오픈소스 NoSQL 데이터베이스입니다. 문서 지향 데이터베이스로, JSON 형식으로 데이터를 저장하여 웹 및 모바일 애플리케이션에서 유연하게 사용될 수 있습니다. 특히, 여러 장치 간의 데이터 복제 및 동기화 기능이 강력하여 LiveSync 플러그인의 백엔드로 적합합니다.\n사용 전 준비사항 # 플러그인을 설정하기에 앞서, 노트를 저장하고 동기화할 중앙 저장소, 즉 CouchDB 서버가 준비되어 있어야 합니다. CouchDB를 구축하는 방법은 다양하지만, 대표적으로 다음과 같은 방법들이 있습니다.\nDocker를 이용한 설치: 개인 서버나 NAS(Network Attached Storage)가 있다면 Docker를 이용해 손쉽게 CouchDB 컨테이너를 실행할 수 있습니다. 가장 안정적이고 추천되는 방법입니다.\n클라우드 플랫폼 활용 (예: fly.io): 클라우드 호스팅 서비스를 이용하여 CouchDB 인스턴스를 생성하고 외부에서 접속할 수 있도록 설정하는 방법입니다. 비교적 간단하게 시작할 수 있습니다.\nCouchDB의 설치는 아래의 글을 참조해 주세요\nubuntu 서버에 CouchDB 설치하기 4 July 2025\u0026middot;510 words\u0026middot;3 mins 이 가이드에서는 CouchDB 서버가 이미 구축되어 있고, 접속에 필요한 정보(주소, 사용자 이름, 비밀번호)를 알고 있다는 가정하에 설명을 진행합니다. CouchDB 서버 구축 방법은 사용하시는 환경에 따라 상이하므로, 별도의 가이드를 참조하여 주시기 바랍니다.\n동기화 설정을 진행하기 전에, 만일의 사태에 대비하여 기존의 Obsidian Vault(노트 저장소)를 반드시 백업해두시길 바랍니다. 이제 본격적으로 Obsidian에 Self-hosted LiveSync 플러그인을 설치하고 CouchDB 서버와 연동하는 방법을 단계별로 알아보겠습니다.\nSelf-hosted LiveSync 플러그인 설치 및 활성화 # Obsidian을 실행하고, 좌측 하단의 \u0026lsquo;설정\u0026rsquo; (톱니바퀴 아이콘)을 클릭합니다. 설정 창에서 \u0026lsquo;커뮤니티 플러그인\u0026rsquo; 탭으로 이동합니다. \u0026lsquo;안전 모드\u0026rsquo;가 활성화되어 있다면, \u0026lsquo;안전 모드 끄기\u0026rsquo; 버튼을 클릭하여 비활성화합니다. \u0026lsquo;커뮤니티 플러그인 탐색\u0026rsquo; 버튼을 클릭합니다. 검색창에 Self-hosted LiveSync를 입력하여 플러그인을 찾은 뒤, \u0026lsquo;설치\u0026rsquo; 버튼을 누릅니다. 설치가 완료되면 \u0026lsquo;활성화\u0026rsquo; 버튼을 클릭하여 플러그인을 활성화합니다. LiveSync 설정 및 CouchDB 연동 # 플러그인 활성화 후, 설정 메뉴의 \u0026lsquo;커뮤니티 플러그인\u0026rsquo; 목록 아래에 새로 생긴 \u0026lsquo;Self-hosted LiveSync\u0026rsquo; 탭을 클릭하여 설정 창으로 이동합니다.\n설정 창 상단에 여러 아이콘이 표시됩니다. 가장 왼쪽에 있는 위성(🛰️) 아이콘이 선택되었는지 확인합니다.\nCouchDB 데이터베이스 설정 정보를 입력하는 항목들이 나타납니다. 준비해 둔 CouchDB 서버 접속 정보를 각 항목에 맞게 정확히 입력합니다.\nURI: CouchDB 서버의 전체 주소를 입력합니다. (예: http://127.0.0.1:5984 또는 https://your-domain.com/couchdb) ⚠️주소 마지막에 /가 포함되지 않도록 주의하세오. Username: CouchDB 접속 시 사용하는 사용자 이름을 입력합니다. Password: CouchDB 접속 시 사용하는 비밀번호를 입력합니다. ⚠️ 이 비밀번호는 Obsidian Vault 내 설정 파일에 일반 텍스트로 저장됩니다. 보안에 유의하시기 바랍니다. Database name: 동기화를 위해 사용할 데이터베이스의 이름을 지정합니다. 임의로 지정할 수 있지만, 다른 기기에서도 동일한 이름을 사용해야 하므로 기억하기 쉬운 이름으로 설정하는 것이 좋습니다. (예: obsidian-notes) 정보를 모두 입력한 후, \u0026lsquo;Test database connection\u0026rsquo; 버튼을 클릭하여 서버와 정상적으로 연결되는지 확인합니다. 모든 항목에 녹색 체크 표시가 나타나면 성공입니다.\n필요에 따라 \u0026lsquo;End-to-end encryption\u0026rsquo; (종단간 암호화) 설정을 할 수 있습니다. 암호화 사용 시, 데이터를 보호할 추가 비밀번호를 설정하게 됩니다. 이 비밀번호는 CouchDB 서버에도 저장되지 않으며, 분실 시 데이터를 복구할 수 없으므로 반드시 안전한 곳에 보관해야 합니다.\n동기화 설정하기 # LiveSync를 선택한 후 Apply를 눌러줍니다. 동시 접속 문제로 동기화가 원활하지 않을 때는 Sync Mode를 Periodic and On Events로 바꿔 사용하는 것도 좋습니다.\n동기화 시작 및 확인 # CouchDB 설정이 완료되면, 에디터 우측 하단 상태바에 LiveSync 상태 아이콘이 나타납니다. 아이콘의 모양으로 현재 동기화 상태를 파악할 수 있습니다.\n💤 (잠자기): 동기화가 활성화되었으며, 파일 변경을 기다리는 상태입니다. ⚡️ (번개): 현재 동기화가 진행 중인 상태입니다. ⏹️ (정지): 동기화가 중지된 상태입니다. ⚠️ (경고): 오류가 발생한 상태입니다. 다른 기기(PC, 모바일)에도 동일한 방법으로 Obsidian과 LiveSync 플러그인을 설치하고, 반드시 동일한 CouchDB 접속 정보와 데이터베이스 이름, 그리고 암호화 비밀번호를 입력하여 설정을 완료합니다.\n설정이 완료된 후, 한 기기에서 노트를 수정하거나 새로 생성하면 잠시 후 다른 기기에도 해당 내용이 자동으로 반영되는 것을 확인할 수 있습니다.\n마무리 # 지금까지 Self-hosted LiveSync 플러그인과 CouchDB를 이용하여 자신만의 Obsidian 동기화 환경을 구축하는 방법에 대해 알아보았습니다. 처음에는 다소 복잡하게 느껴질 수 있지만, 이 가이드를 차근차근 따라오셨다면 성공적으로 설정을 마치셨으리라 믿습니다.\n직접 동기화 서버를 운영하는 것은 자신의 소중한 지식 자산을 온전히 통제하고 관리한다는 점에서 큰 의미가 있습니다. 이제 여러 장치를 넘나들며 끊김 없이 아이디어를 기록하고 발전시켜 나가시길 바랍니다.\n궁금한 점이나 막히는 부분이 있다면, 언제든 관련 커뮤니티나 문서를 참조하여 해결해 나가실 수 있을 것입니다. 여러분의 지식 여정에 이 글이 실질적인 도움이 되었기를 바랍니다.\n참고\nSelf-hosted LiveSync Plugin (Official GitHub ) Apache CouchDB (Official Website ) ","date":"5 July 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/obsidian-plugin-self-hoted-live-sync/","section":"","summary":"","title":"Obsidian Self-hosted LiveSync 플러그인과 CouchDB를 이용한 동기화 가이드","type":"posts"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/tags/sync/","section":"Tags","summary":"","title":"Sync","type":"tags"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"5 July 2025","externalUrl":null,"permalink":"/categories/tools/","section":"Categories","summary":"","title":"Tools","type":"categories"},{"content":"수많은 데이터베이스 중에서도, 이번에는 특별한 매력을 가진 Apache CouchDB를 알아보고, 우리가 이전에 배운 도커 컴포즈를 이용해 가장 간편하고 현명한 방법으로 설치해 보겠습니다.\nCouchDB란 무엇이며, 왜 사용할까요? # CouchDB는 Apache Software Foundation에서 개발하는 NoSQL 데이터베이스입니다. NoSQL은 전통적인 관계형 데이터베이스(RDBMS, 예: MySQL)의 테이블 구조가 아닌, 보다 유연한 방식으로 데이터를 저장하는 데이터베이스를 말합니다. CouchDB는 데이터를 JSON 문서(Document) 형태로 저장하는데, 이는 마치 서류 캐비닛에 파일을 정리하는 것과 비슷합니다.\n그렇다면 수많은 데이터베이스 중에서 CouchDB를 주목하는 이유는 무엇일까요?\n독보적인 데이터 동기화 기능 (Multi-Master Replication)\nCouchDB의 가장 강력한 특징입니다. 여러 대의 CouchDB 서버 혹은 클라이언트(모바일 기기 등)가 있을 때, 네트워크 연결이 끊겼다가 다시 연결되어도 알아서 데이터를 서로 복제하고 동기화합니다. 오프라인 상태에서도 앱이 정상적으로 작동해야 하는 \u0026lsquo;오프라인 우선(Offline-First)\u0026rsquo; 모바일 앱이나, 전 세계에 분산된 서버들이 데이터를 공유해야 하는 서비스, IoT 기기 데이터 수집 등에서 막강한 성능을 발휘합니다.\n웹 친화적인 구조 (HTTP API)\nCouchDB는 모든 통신을 웹 표준인 HTTP 프로토콜 위에서 수행합니다. 즉, 웹 브라우저나 curl 같은 간단한 명령어로도 데이터의 조회, 입력, 수정, 삭제(CRUD)가 모두 가능합니다. 이는 웹 개발자에게 매우 직관적이고 다루기 쉬운 환경을 제공합니다.\n유연한 데이터 모델\n엄격한 스키마(데이터 구조)를 미리 정의할 필요가 없습니다. 프로젝트를 진행하면서 필요한 필드를 자유롭게 추가하거나 변경할 수 있어, 변화가 잦은 초기 스타트업이나 애자일 환경의 프로젝트에 적합합니다.\n뛰어난 안정성과 내구성\n데이터를 저장할 때마다 이전 버전을 남겨두는 방식을 사용하여, 데이터베이스 파일이 손상되더라도 복구할 수 있는 능력이 뛰어납니다.\n솔직히 말해, CouchDB가 MongoDB나 PostgreSQL처럼 시장을 지배하는 주류 데이터베이스는 아닐 수 있습니다. 하지만 위에서 언급한 독보적인 동기화 기능 덕분에, 특정 분야에서는 그 어떤 데이터베이스보다 뛰어난, \u0026lsquo;대체 불가능한 강력한 조연\u0026rsquo; 같은 역할을 톡톡히 해내고 있습니다.\nDocker Compose로 CouchDB 설치하기 # 이제 docker compose를 이용해 CouchDB를 1분 만에 설치해 보겠습니다. 이 방법은 여러분의 PC를 깨끗하게 유지하면서, 필요할 때마다 명령어 한 줄로 데이터베이스를 실행하고 중지할 수 있는 가장 효율적인 방법입니다.\ndocker-compose.yml 파일 작성하기 # 프로젝트 폴더를 하나 만들고, 그 안에 docker-compose.yml 이라는 이름의 파일을 생성한 후 아래 내용을 입력하십시오.\nversion: \u0026#39;3.8\u0026#39; services: couchdb: image: apache/couchdb:3.3.3 container_name: my-couchdb restart: always environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=password ports: - \u0026#34;5984:5984\u0026#34; volumes: - couchdb-data:/opt/couchdb/data volumes: couchdb-data: image: apache/couchdb:3.3.3: CouchDB 공식 이미지를 사용합니다. environment: CouchDB에 접속할 관리자 계정(admin)과 비밀번호(password)를 설정합니다. ports: - \u0026quot;5984:5984\u0026quot;: 내 컴퓨터의 5984번 포트를 컨테이너의 5984번 포트와 연결합니다. CouchDB는 5984 포트를 사용합니다. volumes: 컨테이너가 삭제되더라도 데이터베이스의 데이터는 사라지지 않도록 couchdb-data 라는 볼륨에 영구적으로 저장합니다. 이것은 매우 중요한 설정입니다. 실제 운영 환경에서는 절대 이렇게 간단한 비밀번호를 사용해서는 안 됩니다. CouchDB 실행하기 🚀 # docker-compose.yml 파일이 있는 폴더에서 터미널을 열고 다음 명령어를 입력하십시오.\ndocker compose up -d -d 옵션은 컨테이너를 백그라운드에서 조용히 실행하라는 의미입니다.\n설치 확인하기 # 이제 CouchDB가 정상적으로 실행되고 있는지 확인해볼 차례입니다.\n웹 관리 도구 접속\n웹 브라우저를 열고 http://localhost:5984/_utils/ 주소로 접속하십시오.\ndocker-compose.yml 파일에 설정했던 사용자 이름(admin)과 비밀번호(password)를 입력하고 로그인했을 때, 데이터베이스 관리 화면이 나타난다면 성공입니다.\n터미널에서 curl로 확인\n터미널에 다음 명령어를 입력해 보십시오.\ncurl http://admin:password@localhost:5984/ {\u0026quot;couchdb\u0026quot;:\u0026quot;Welcome\u0026quot;,\u0026quot;version\u0026quot;:\u0026quot;3.3.3\u0026quot;, ...} 와 같이 CouchDB의 환영 메시지가 JSON 형태로 출력된다면 성공적으로 설치되고 실행 중인 것입니다.\n맺음말 # 수고하셨습니다. 여러분은 이제 복잡한 설치 과정 없이, 단 하나의 설정 파일과 명령어 한 줄만으로 강력한 NoSQL 데이터베이스인 CouchDB를 여러분의 개발 환경에 구축했습니다.\n이제 여러분의 애플리케이션 컨테이너에서 이 CouchDB 컨테이너로 접속하여 데이터를 저장하고 조회하는 작업을 수행할 수 있습니다. 이것이 바로 여러 개의 컨테이너가 서로 협력하며 하나의 서비스를 만들어나가는, 도커 컴포즈의 진정한 힘입니다.\n","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/couchdb-service/","section":"","summary":"","title":"ubuntu 서버에 CouchDB 설치하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/%EC%84%9C%EB%B2%84/","section":"Tags","summary":"","title":"서버","type":"tags"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/categories/%ED%98%B8%EC%8A%A4%ED%8C%85/","section":"Categories","summary":"","title":"호스팅","type":"categories"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/%ED%99%88%EC%84%9C%EB%B2%84/","section":"Tags","summary":"","title":"홈서버","type":"tags"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/dlna/","section":"Tags","summary":"","title":"Dlna","type":"tags"},{"content":"집안의 다양한 기기, 예를 들어 스마트 TV, 게임 콘솔, 스마트폰에서 PC나 서버에 저장된 영상, 음악, 사진을 손쉽게 즐기고 싶을 때가 많습니다. 이번 글에서는 Ubuntu(우분투) 서버에 MiniDLNA를 설치하여 간단하면서도 강력한 DLNA(Digital Living Network Alliance) 미디어 서버를 구축하는 방법을 안내해 드리겠습니다.\nMiniDLNA란? # MiniDLNA(현재는 ReadyMedia라는 이름으로도 불립니다) 는 이름에서 알 수 있듯이 아주 가벼운 DLNA 서버 소프트웨어입니다. 복잡한 기능 없이 DLNA의 핵심 기능에만 충실하여 시스템 자원을 매우 적게 소모하는 것이 가장 큰 장점입니다. 저사양의 홈서버나 NAS(Network Attached Storage)에서도 부담 없이 운영할 수 있으며, 설정이 간단하여 초보자도 쉽게 미디어 서버를 구축할 수 있습니다.\nDLNA는 제조사가 다른 전자기기끼리도 미디어 콘텐츠를 자유롭게 공유할 수 있도록 만들어진 규격입니다. 따라서 MiniDLNA 서버를 구축해두면, 같은 네트워크에 연결된 대부분의 스마트 TV나 플레이스테이션 등에서 별도의 클라이언트 앱 설치 없이도 서버의 파일을 바로 재생할 수 있습니다.\nMiniDLNA 패키지 설치 # 이제 본격적으로 MiniDLNA 서버 구축을 시작하겠습니다. 먼저, Ubuntu 서버에 MiniDLNA 패키지를 설치합니다. 터미널을 열고 아래 명령어를 순서대로 입력하십시오.\nsudo apt update sudo apt install minidlna 설치가 끝나면 자동으로 MiniDLNA 서비스가 시작됩니다. 다음 명령어로 정상 실행 여부를 확인할 수 있습니다.\nsystemctl status minidlna 미디어 디렉터리 지정 # MiniDLNA가 어떤 폴더의 파일들을 공유할지 알려주어야 합니다. 설정 파일인 /etc/minidlna.conf를 수정하여 미디어 디렉터리를 지정합니다.\n수정하기에 앞서 원본 설정 파일을 백업해두는 것이 안전합니다.\nsudo cp /etc/minidlna.conf /etc/minidlna.conf.bak nano와 같은 텍스트 편집기로 설정 파일을 엽니다.\nsudo nano /etc/minidlna.conf 파일 내용 중에서 media_dir 항목을 찾습니다. 이 부분이 미디어 파일이 위치한 경로를 지정하는 곳입니다. 기본적으로 주석 처리( # 기호로 시작) 되어 있으니, 주석을 제거하고 경로를 수정해야 합니다.\n예를 들어, 영상은 /data/videos, 음악은 /data/music, 사진은 /data/pictures 폴더에 저장되어 있다면 다음과 같이 설정합니다.\n# Path to the directory you want scanned for media files. # # This option can be specified more than once if you want to scan # multiple directories. # # If you want to restrict a media_dir to a specific content type, you # can prepend the type (\u0026#39;A\u0026#39; for audio, \u0026#39;V\u0026#39; for video, \u0026#39;P\u0026#39; for # picture) followed by a comma to the directory (e.g. media_dir=V,/var/lib/video). media_dir=V,/data/videos media_dir=A,/data/music media_dir=P,/data/pictures V,는 비디오, A,는 오디오, P,는 사진 전용 폴더임을 명시하는 것입니다. 이렇게 타입을 지정하면 MiniDLNA가 더 효율적으로 파일을 분류합니다. 경로는 각자 미디어 파일을 저장해 둔 실제 경로로 변경해야 합니다. (선택 사항) 서버의 이름을 변경하고 싶다면 friendly_name 항목을 찾아 수정합니다. 이 이름이 클라이언트 기기에 표시됩니다.\n# Name that the DLNA server presents to clients. friendly_name=My Home Media 수정이 완료되면 Ctrl+X, Y, Enter를 차례로 눌러 저장하고 편집기를 종료합니다.\n방화벽 설정 # 서버에 UFW 방화벽이 활성화된 경우, DLNA 클라이언트가 서버를 찾고 접속할 수 있도록 관련 포트를 허용해야 합니다.\nsudo ufw allow 1900/udp sudo ufw allow 8200/tcp 1900/udp: 클라이언트가 네트워크에서 DLNA 서버를 발견(Discovery)하기 위해 사용하는 포트입니다. 8200/tcp: 발견된 서버의 파일 목록에 접근하고 스트리밍하기 위해 사용하는 포트입니다. 서비스 재시작 및 라이브러리 갱신 # 설정 변경 사항을 적용하고, 미디어 파일을 스캔하여 라이브러리를 구축하도록 서비스를 재시작합니다.\nsudo systemctl restart minidlna 만약 새로운 미디어 파일을 추가한 후 즉시 라이브러리에 반영하고 싶다면, 다음 명령어로 강제 갱신을 할 수 있습니다.\nsudo service minidlna force-reload 클라이언트에서 접속 확인 # 이제 서버 설정은 모두 끝났습니다. 스마트 TV나 스마트폰의 DLNA 지원 앱(예: VLC media player, BubbleUPnP 등)을 실행하여 미디어 서버를 검색해 보십시오.\nminidlna.conf 파일에서 설정한 friendly_name(예: My Home Media)을 가진 서버가 목록에 나타날 것입니다. 해당 서버를 선택하면 지정해 둔 비디오, 오디오, 사진 폴더에 접근하여 파일을 스트리밍으로 감상할 수 있습니다.\n마무리 # MiniDLNA는 복잡한 설정 없이도 누구나 손쉽게 개인 미디어 서버를 구축할 수 있게 해주는 훌륭한 도구입니다. 이 가이드를 통해 여러분의 홈 네트워크 환경이 더욱 풍요로워지기를 바랍니다. 서버에 새로운 영화나 음악을 추가하고, 거실 소파에 편히 앉아 TV로 바로 감상하는 편리함을 누려보십시오.\n궁금하신 점은 언제든 질문 주시면 제가 아는 선에서 최대한 도와드리겠습니다.\n참조\nReadyMedia (Formerly MiniDLNA) 프로젝트 페이지: https://sourceforge.net/projects/minidlna/ Ubuntu 공식 문서: https://help.ubuntu.com/community/MiniDLNA ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/dlna-server-using-minidlna/","section":"","summary":"","title":"Ubuntu 서버에 MiniDLNA로 미디어 서버 구축하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/samba/","section":"Tags","summary":"","title":"Samba","type":"tags"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/smb/","section":"Tags","summary":"","title":"Smb","type":"tags"},{"content":"여러 장치 간에 파일을 공유하는 가장 확실하고 안정적인 방법 중 하나는 파일 서버를 구축하는 것입니다. 이번 글에서는 Ubuntu(우분투) 환경에서 Samba(삼바)를 이용하여 윈도우, macOS, 리눅스 등 다양한 운영체제와 파일을 공유할 수 있는 서버를 구축하는 방법을 안내해 드리겠습니다.\nSamba(삼바)란? # Samba는 윈도우 운영체제에서 사용하는 파일 공유 프로토콜인 SMB/CIFS를 리눅스나 유닉스 계열 운영체제에서도 사용할 수 있도록 해주는 소프트웨어입니다. Samba를 이용하면 리눅스 서버에 공유 폴더를 만들어두고, 윈도우 탐색기에서 마치 로컬 드라이브처럼 접속하여 파일을 읽고 쓸 수 있게 됩니다. 홈서버나 사무실 환경에서 중앙 데이터 저장소로 활용하기에 매우 적합합니다.\nSamba 설치 및 설정 # Samba 패키지 설치 # 가장 먼저 할 일은 서버에 Samba 패키지를 설치하는 것입니다. 터미널에서 다음 명령어를 차례로 실행하여 패키지 목록을 최신화하고 Samba를 설치합니다.\nsudo apt update sudo apt install samba 설치가 완료되면 다음 명령어로 Samba 서비스의 상태를 확인하여 정상적으로 실행 중인지 점검합니다.\nsystemctl status smbd 공유할 디렉터리 생성 # 다음으로 클라이언트와 공유할 디렉터리를 생성합니다. 여기서는 예시로 /home/\u0026lt;user\u0026gt;/share 경로에 디렉터리를 만들겠습니다. \u0026lt;user\u0026gt; 실제 사용자의 계정으로 변경해주시면 됩니다.\nsudo mkdir -p /home/\u0026lt;user\u0026gt;/share Samba 설정 파일 수정 # Samba의 핵심 설정은 /etc/samba/smb.conf 파일에서 이루어집니다. 원본 설정을 보존하기 위해 파일을 백업한 후, 편집을 시작하겠습니다.\n사용자 추가\nsudo smbpasswd -a $USER 현재 사용자 계정으로 samba에 접속할 수 있도록 계정과 비밀번호를 설정해 줍니다.\n설정 파일 백업\nsudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak 설정 파일 편집 (nano 편집기 사용 예시)\nsudo nano /etc/samba/smb.conf smb.conf 파일의 가장 아래쪽에 다음 내용을 추가합니다. 이것이 우리가 생성한 공유 폴더에 대한 정의입니다.\n[share] comment = Samba Share path = /srv/samba/share read only = no browsable = yes guest ok = \bno [share]: 클라이언트에서 보이게 될 공유 폴더의 이름입니다. 원하는 이름으로 변경할 수 있습니다. comment: 공유 폴더에 대한 간단한 설명입니다. path: 2단계에서 생성한 실제 공유 디렉터리의 경로입니다. read only = no: \u0026lsquo;아니오\u0026rsquo;로 설정해야 파일을 쓸 수 있습니다. 읽기 전용으로 하려면 yes로 변경합니다. browsable = yes: 파일 탐색기에서 해당 공유 폴더가 보이도록 설정합니다. guest ok = no: 인증된 사용자만 접속하게 하려면 이 항목을 \bno로 설정합니다. yes인 경우 별도의 사용자 인증 없이 손님(guest) 계정으로 접근을 허용합니다. 설정 파일의 문법에 오류가 없는지 다음 명령어로 확인합니다.\ntestparm \u0026lsquo;Loaded services file OK.\u0026rsquo; 메시지가 나타나면 정상입니다.\n수정한 설정을 적용하기 위해 Samba 서비스를 재시작합니다.\nsudo systemctl restart smbd sudo systemctl restart nmbd 방화벽 설정 # Ubuntu에 UFW(Uncomplicated Firewall) 방화벽이 활성화되어 있다면 Samba가 사용하는 포트를 허용해 주어야 합니다.\nsudo ufw allow samba 이 명령어 하나로 Samba에 필요한 포트들이 자동으로 허용됩니다.\n클라이언트에서 접속하기 # 윈도우 PC에서 # 윈도우 PC에서 접속하여 파일이 정상적으로 공유되는지 확인해 보겠습니다.\n키보드에서 Win + R 키를 눌러 실행창을 엽니다. \\\\[서버 IP 주소]를 입력하고 \u0026lsquo;확인\u0026rsquo;을 누릅니다. 예를 들어 서버 IP가 192.168.0.10이라면 \\\\192.168.0.10을 입력합니다. 사용자의 계정과 설정한 비밀 번호를 입력합니다. 탐색기 창이 열리면서 앞서 smb.conf에서 설정한 share 폴더가 보일 것입니다. Mac OS에서 접속하기 # Mac OS에서 접속하여 파일이 정상적으로 공유되는지 확인해 보겠습니다.\nFinder나 바탕화면에서 Command(⌘) + K를 누릅니다. \\\\[서버 IP 주소]를 입력하고 \u0026lsquo;확인\u0026rsquo;을 누릅니다 사용자의 계정과 설정한 비밀 번호를 입력합니다. Finder 창이 열리면서 앞서 smb.conf에서 설정한 share 폴더가 보일 것입니다. 폴더에 들어가서 새 파일을 만들거나 파일을 복사하여 서버에 정상적으로 저장이 되는지 확인합니다.\n마무리 (사용자 인증 설정) # Samba를 이용하면 리눅스 환경에 익숙하지 않은 사용자도 윈도우 환경에서 손쉽게 서버의 파일에 접근할 수 있어 매우 유용합니다. 이 글이 여러분의 데이터 관리 환경을 개선하는 데 도움이 되기를 바랍니다.\n참조\nSamba 공식 위키: https://wiki.samba.org/ Ubuntu 공식 문서: https://ubuntu.com/server/docs/samba-file-server ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/smb-file-server/","section":"","summary":"","title":"Ubuntu에서 Samba 파일 서버 운영하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/%EC%82%BC%EB%B0%94/","section":"Tags","summary":"","title":"삼바","type":"tags"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/%ED%8C%8C%EC%9D%BC%EC%84%9C%EB%B2%84/","section":"Tags","summary":"","title":"파일서버","type":"tags"},{"content":"홈서버를 운영하며 Docker를 활용해 다양한 서비스를 구축하는 일은 이제 보편적인 일이 되었습니다. 이번 글에서는 여러 토렌트 클라이언트 중에서도 많은 분이 애용하시는 Transmission을 Docker 환경에 설치하는 방법을 안내해 드리고자 합니다.\nTransmission을 사용하는 이유 # Transmission은 다른 토렌트 클라이언트에 비해 여러 가지 장점을 가지고 있습니다.\n가볍고 빠른 속도\nTransmission은 시스템 자원을 적게 소모하여 저사양의 홈서버나 NAS(Network Attached Storage)에서도 부담 없이 운영할 수 있습니다. 불필요한 기능 없이 핵심적인 기능에 집중하여 가볍고 빠른 성능을 자랑합니다.\n직관적인 웹 인터페이스\n별도의 클라이언트 프로그램 설치 없이 웹 브라우저만으로 모든 기능을 제어할 수 있습니다. 스마트폰이나 태블릿 등 어떤 기기에서든 쉽게 접속하여 토렌트 파일을 추가하고 관리할 수 있어 편리합니다.\n뛰어난 안정성\n오랜 기간 개발되어 온 만큼 안정성이 매우 뛰어납니다. 예기치 않은 오류나 시스템 중단 없이 꾸준하게 파일을 주고받을 수 있습니다.\n이러한 장점들 덕분에 Transmission은 홈서버 환경에서 가장 선호되는 토렌트 클라이언트 중 하나로 자리 잡았습니다.\n설치 전 준비 사항 # 본격적인 설치에 앞서, 다음 사항이 준비되어 있어야 합니다.\nDocker가 설치된 환경\n여기서는 Docker가 이미 시스템에 설치되어 있다는 것을 전제로 진행합니다. Docker 설치 방법은 아래 포스트를 확인해 주세요.\nUbuntu에 Docker 설치하기 3 July 2025\u0026middot;550 words\u0026middot;3 mins 데이터를 저장할 디렉터리 생성\n다운로드한 파일과 설정 파일을 저장할 디렉터리를 미리 만들어 두어야 합니다. 이는 컨테이너가 삭제되더라도 데이터를 보존하기 위함입니다. 터미널에서 다음 명령어를 사용하여 디렉터리를 생성하는 것을 권장합니다.\nmkdir -p /path/to/your/storage/transmission/config mkdir -p /path/to/your/storage/transmission/downloads mkdir -p /path/to/your/storage/transmission/watch /path/to/your/storage/ 부분은 실제 데이터를 저장하고자 하는 경로로 변경해 주십시오. (예: /home/user/docker/transmission) config: Transmission의 설정 파일이 저장될 공간입니다. downloads: 다운로드가 완료된 파일이 저장될 공간입니다. watch: 이 디렉터리에 토렌트 파일을 넣어두면 Transmission이 자동으로 다운로드를 시작합니다. Docker를 이용한 Transmission 설치 # Docker를 이용하여 Transmission을 설치하는 방법은 docker run 명령어를 직접 사용하는 방법과 docker-compose를 이용하는 방법이 있습니다. 여기서는 두 가지 방법을 모두 안내해 드리겠습니다.\ndocker run 명령어를 이용한 설치 # 터미널을 열고 다음 명령어를 입력하여 Transmission 컨테이너를 생성하고 실행합니다.\ndocker run --name=transmission \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Asia/Seoul \\ -p 9091:9091 \\ -p 51413:51413 \\ -p 51413:51413/udp \\ -v /path/to/your/storage/transmission/config:/config \\ -v /path/to/your/storage/transmission/downloads:/downloads \\ -v /path/to/your/storage/transmission/watch:/watch \\ --restart unless-stopped \\ linuxserver/transmission 각 옵션의 의미를 정확히 이해하고 사용하시는 것이 중요합니다. --name=transmission: 컨테이너의 이름을 transmission으로 지정합니다. -e PUID=1000 / -e PGID=1000: 컨테이너 내에서 실행되는 프로세스의 사용자 ID와 그룹 ID를 지정합니다. id 명령어를 터미널에 입력하여 현재 사용자의 UID와 GID 값을 확인하고 그에 맞게 수정해 주십시오. 이는 파일 권한 문제 발생을 예방합니다. -e TZ=Asia/Seoul: 컨테이너의 시간대를 서울로 설정합니다. -p 9091:9091: 웹 인터페이스 접속을 위한 포트입니다. 외부 포트(왼쪽)와 내부 포트(오른쪽)를 연결합니다. -p 51413:51413 / -p 51413:51413/udp: 토렌트 데이터 교환을 위한 포트입니다. TCP와 UDP 프로토콜을 모두 열어줍니다. -v /path/to/your/storage/... : 앞서 생성한 호스트의 디렉터리와 컨테이너 내부의 디렉터리를 연결(마운트)합니다. --restart unless-stopped: 시스템이 재시작되더라도 사용자가 직접 정지시키지 않는 한 컨테이너가 자동으로 다시 시작되도록 설정합니다. linuxserver/transmission: 설치할 Docker 이미지의 이름입니다. linuxserver.io 그룹에서 제공하는 이미지는 안정성과 편의성이 높아 많은 사용자가 선호합니다. docker-compose를 이용한 설치 # docker-compose는 여러 컨테이너를 정의하고 실행하기 위한 도구로, 설정 파일을 통해 관리하므로 더 편리합니다.\n원하는 위치에 docker-compose.yml 파일을 생성하고 아래 내용을 입력합니다.\nversion: \u0026#34;2.1\u0026#34; services: transmission: image: lscr.io/linuxserver/transmission:latest container_name: transmission environment: - PUID=1000 - PGID=1000 - TZ=Asia/Seoul volumes: - /path/to/your/storage/transmission/config:/config - /path/to/your/storage/transmission/downloads:/downloads - /path/to/your/storage/transmission/watch:/watch ports: - 9091:9091 - 51413:51413 - 51413:51413/udp restart: unless-stopped docker-compose.yml 파일이 저장된 폴더에서 다음 명령어를 실행합니다.\ndocker compose up -d -d 옵션은 컨테이너를 백그라운드에서 실행하도록 합니다. Transmission 접속 및 초기 설정 # 컨테이너 실행이 완료되었다면 이제 웹 브라우저를 통해 Transmission에 접속할 수 있습니다.\n웹 브라우저 주소창에 http://[서버 IP 주소]:9091을 입력합니다. 최초 접속 시 인증을 요구하는 창이 나타날 수 있습니다. linuxserver/transmission 이미지의 경우, 초기 사용자 이름과 비밀번호는 대부분 transmission 입니다. 접속 후, 화면 하단의 설정(스패너 모양 아이콘) 버튼을 클릭하여 몇 가지 중요한 설정을 변경하는 것이 좋습니다. Peers 탭: Peer listening port가 51413으로 설정되어 있는지 확인하고, Use port forwarding from my router 옵션을 활성화하는 것이 좋습니다. 공유기를 사용하신다면 해당 포트에 대한 포트 포워딩 설정을 해주어야 원활한 속도를 확보할 수 있습니다. RPC 탭: 보안을 위해 Authentication required에 체크하고, Username과 Password를 자신만의 것으로 변경하십시오. 마무리 # 지금까지 Docker를 이용하여 Transmission 토렌트 클라이언트를 설치하고 기본적인 설정을 진행하는 방법에 대해 알아보았습니다. Docker를 활용하면 이처럼 복잡한 과정 없이 몇 가지 명령어만으로 강력한 서비스를 손쉽게 구축할 수 있습니다.\n이 글이 여러분의 성공적인 홈서버 운영에 작은 보탬이 되기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해 주십시오. 제가 아는 범위 내에서 성심껏 답변해 드리겠습니다.\n참조\nDocker Hub - linuxserver/transmission: https://hub.docker.com/r/linuxserver/transmission Transmission 공식 홈페이지: https://transmissionbt.com/ ","date":"4 July 2025","externalUrl":null,"permalink":"/posts/hosting/services/transmission-server/","section":"","summary":"","title":"Ubuntu 홈서버에 Docker로 Transmission 설치하기","type":"posts"},{"content":"","date":"4 July 2025","externalUrl":null,"permalink":"/tags/%ED%86%A0%EB%A0%8C%ED%8A%B8/","section":"Tags","summary":"","title":"토렌트","type":"tags"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/categories/develop/","section":"Categories","summary":"","title":"Develop","type":"categories"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":"아마 도커 명령어를 실행할 때마다 매번 sudo를 입력하는 것이 다소 번거롭게 느껴지셨을 겁니다. 이는 기본적으로 도커 데몬(Docker Daemon)이 루트(root) 권한으로 실행되기 때문에, 일반 사용자 계정으로 도커를 제어하려면 관리자 권한을 획득하는 sudo가 필요한 것입니다.\n이번 글에서는 docker 그룹에 현재 사용자를 추가하여 sudo 없이 도커 명령어를 실행하는 방법과, 이 작업이 가지는 보안상 의미에 대해 정확히 알려드리겠습니다.\n왜 sudo를 생략하고 싶을까요? # 가장 큰 이유는 \u0026lsquo;편의성\u0026rsquo; 입니다. 개발 과정에서 수없이 많은 docker 명령어를 입력하게 되는데, 이때마다 sudo를 붙이는 것은 번거로울 뿐만 아니라 비밀번호를 반복적으로 입력해야 할 수도 있습니다. docker 그룹에 사용자를 추가하면 이러한 불편함을 해소하고, 마치 일반 명령어처럼 docker ps, docker images 등을 바로 사용할 수 있습니다.\n하지만 편의성에는 항상 뒤따르는 책임이 있습니다. 이 점을 염두에 두시고 다음 단계를 진행해 주십시오.\ndocker 그룹에 현재 사용자 추가하기 # 리눅스에서 docker 그룹은 도커 엔진 설치 시 자동으로 생성됩니다. 우리는 이 그룹에 현재 로그인된 사용자를 포함시키기만 하면 됩니다.\ndocker 그룹에 사용자 추가 # 터미널을 열고 다음 명령어를 입력하십시오. 이 명령어는 docker라는 그룹(-G docker)에 현재 사용자($USER)를 추가(-a)하는 명령어입니다. $USER는 시스템에 현재 로그인된 사용자 이름으로 자동 치환되는 환경 변수입니다.\nsudo usermod -aG docker $USER 변경 사항 시스템에 적용하기 # 위 명령어를 실행했다고 해서 바로 sudo 없이 docker 명령어를 사용할 수 있는 것은 아닙니다. 그룹 변경 사항을 현재 사용자 세션에 적용하기 위해 시스템에서 로그아웃한 후 다시 로그인하거나, 시스템을 재부팅해야 합니다.\n또는, 다음 명령어를 사용하여 새 그룹 멤버십을 즉시 활성화할 수도 있습니다.\nnewgrp docker 하지만 가장 확실하고 권장되는 방법은 로그아웃 후 다시 로그인하는 것입니다.\n반드시 알아야 할 보안상 의미 # sudo를 생략하는 편리함을 얻는 대신, 우리는 보안 측면에서 매우 중요한 권한을 사용자 계정에 부여하게 됩니다.\ndocker 그룹의 멤버가 된다는 것은, 사실상 시스템의 루트(root) 권한을 직접 얻는 것과 동일한 수준의 권한을 갖게 됨을 의미합니다. 왜냐하면 도커는 호스트 시스템과 파일을 공유하거나(-v 옵션), 호스트의 네트워크를 직접 사용하는 등 시스템 깊숙한 영역을 제어할 수 있기 때문입니다.\n예를 들어, docker 그룹에 속한 사용자는 다음과 같은 명령어를 통해 호스트의 모든 파일에 접근할 수 있는 루트 셸(root shell)을 컨테이너 내부에 띄울 수 있습니다.\ndocker run -v /:/host -it --entrypoint /bin/bash ubuntu 이것이 의미하는 바는, 만약 여러분의 사용자 계정이 어떤 이유로든 탈취당한다면 공격자는 sudo 비밀번호 없이도 시스템 전체를 장악할 수 있다는 것입니다.\n따라서 이 방법은 개인 개발용 컴퓨터나 보안이 통제된 신뢰할 수 있는 환경에서만 사용하시기를 강력히 권고합니다. 여러 사람이 함께 사용하는 프로덕션 서버나 중요한 시스템에서는 각별한 주의가 필요하며, sudo를 사용하는 기본 정책을 유지하는 것이 더 안전할 수 있습니다.\n적용 결과 확인하기 # 시스템에 다시 로그인했다면, 이제 sudo 없이 도커 명령어가 잘 실행되는지 확인해볼 차례입니다. 터미널을 열고 다음 명령어를 입력해 보십시오.\ndocker ps 만약 \u0026ldquo;permission denied\u0026quot;와 같은 오류 메시지 없이 위와 같이 정상적으로 결과가 출력된다면, 모든 설정이 성공적으로 완료된 것입니다.\n맺음말 # 이제 여러분은 sudo의 번거로움에서 벗어나 훨씬 편리하게 도커를 사용하실 수 있게 되었습니다. 하지만 오늘 함께 알아본 보안상의 의미를 항상 기억해 주시길 바랍니다. 기술의 편리함을 누리는 만큼, 그 기술이 시스템에 미치는 영향을 이해하고 책임감 있게 사용하는 자세는 좋은 개발자에게 반드시 필요한 덕목입니다.\n","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/docker-without-sudo/","section":"","summary":"","title":"sudo 없이 Docker 명령어 사용하기","type":"posts"},{"content":"","date":"3 July 2025","externalUrl":null,"permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu","type":"tags"},{"content":"지난번에는 도커(Docker)가 무엇이고 왜 필요한지에 대해 알아보았습니다. 개념을 이해했다면 이제 직접 내 손으로 설치하고 실행해 볼 차례입니다.\n이번 글에서는 가장 널리 사용되는 리눅스 배포판 중 하나인 Ubuntu에 도커를 설치하는 과정을 안내해 드리고자 합니다. 처음 리눅스 환경에서 무언가를 설치하는 분들도 쉽게 따라 하실 수 있도록, 명령어 하나하나의 의미를 짚어가며 최대한 상세하게 설명하겠습니다. 저와 함께 차근차근 진행해 보십시오.\n기존 도커 패키지 정리하기 # 혹시라도 시스템에 예전에 설치되었거나 비공식적으로 설치된 도커 관련 패키지가 남아있다면, 충돌을 방지하기 위해 먼저 깨끗하게 삭제하는 것이 좋습니다. 아래 명령어를 터미널에 입력하여 관련 패키지들을 제거해 주십시오.\nfor pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done 이 명령어를 실행했을 때 \u0026ldquo;Package \u0026lsquo;xxx\u0026rsquo; is not installed, so not removed\u0026quot;는 메시지가 나와도 괜찮습니다. 시스템을 가장 깔끔한 상태에서 시작하기 위한 예방 조치이므로 안심하고 다음 단계로 넘어가시면 됩니다.\n※ 주의: 이 명령어는 /var/lib/docker/ 디렉터리에 저장된 기존의 이미지, 컨테이너, 볼륨 등은 삭제하지 않습니다. 도커 공식 GPG 키 추가하기 # 도커는 공식적으로 안전성이 검증된 패키지만 설치하도록 권장합니다. 이를 위해, 우리가 설치하려는 패키지가 도커에서 공식적으로 배포한 것이 맞는지 인증하는 과정을 거쳐야 합니다. GPG(GNU Privacy Guard) 키는 이 인증을 위한 \u0026lsquo;공식 인증서\u0026rsquo;와 같은 역할을 합니다.\n아래 명령어들을 순서대로 실행하여 도커의 공식 GPG 키를 다운로드하고 시스템에 등록하십시오.\n필수 패키지 설치 # GPG 키를 추가하고 APT 저장소를 HTTPS를 통해 사용할 수 있도록 관련 도구들을 설치합니다.\nsudo apt-get update sudo apt-get install ca-certificates curl GPG 키를 저장할 디렉터리 생성 # sudo install -m 0755 -d /etc/apt/keyrings 도커 공식 GPG 키 다운로드 # curl 명령어를 사용해 GPG 키를 다운로드한 후, 지정된 위치에 저장합니다.\nsudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc 도커 APT 저장소 설정하기 # 이제 우리 시스템의 패키지 관리자(APT)에게 \u0026ldquo;앞으로 도커는 이 공식 저장소에서 다운로드해줘\u0026quot;라고 알려줄 차례입니다. 다음 명령어를 실행하면, 시스템 아키텍처(예: amd64)에 맞는 도커 공식 저장소 주소가 sources.list 파일에 추가됩니다.\necho \\ \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;${UBUNTU_CODENAME:-$VERSION_CODENAME}\u0026#34;) stable\u0026#34; | \\ sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 이 복잡해 보이는 명령어는 현재 우분투 버전(예: jammy)에 맞는 안정적인(stable) 도커 버전을 다운로드하도록 설정하는 과정입니다.\n도커 엔진 설치하기 # 모든 사전 준비가 끝났습니다. 이제 정말로 도커를 설치할 시간입니다.\n패키지 목록 업데이트 # 방금 추가한 도커 공식 저장소의 정보를 시스템에 반영하기 위해 패키지 목록을 다시 한번 업데이트합니다.\nsudo apt-get update [이미지 설명: \u0026lsquo;apt-get update\u0026rsquo; 명령어 실행 후, 마지막 줄에 \u0026lsquo;https://www.google.com/search?q=download.docker.com\u0026rsquo; 주소가 보이는 터미널 화면. 새 저장소가 성공적으로 인식되었음을 보여줍니다.]\n최신 버전 도커 엔진 설치 # 아래 명령어를 통해 도커 엔진(Docker Engine)과 컨테이너 실행에 필요한 핵심 구성 요소들(containerd, Docker Compose)을 한번에 설치합니다.\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce: 도커 커뮤니티 에디션(Community Edition)의 약자로, 실제 도커 엔진입니다. docker-ce-cli: 도커 명령어를 입력할 수 있게 해주는 클라이언트 도구입니다. containerd.io: 컨테이너의 실행과 생명 주기를 관리하는 핵심 런타임입니다. docker-buildx-plugin, docker-compose-plugin: 도커의 추가 기능들(빌드, 다중 컨테이너 관리)을 사용하기 위한 플러그인입니다. 설치 과정에서 디스크 공간을 얼마나 사용할지 묻는 메시지가 나타나면, \u0026lsquo;Y\u0026rsquo; 를 입력하고 엔터를 눌러 계속 진행하십시오.\n설치 확인하기 # 설치가 올바르게 완료되었는지 확인하는 것은 매우 중요합니다. 다음 명령어를 입력하여 도커가 우리를 반겨주는지 확인해 보십시오.\nsudo docker run hello-world 이 명령어를 실행했을 때 터미널 화면에 \u0026ldquo;Hello from Docker!\u0026rdquo; 라는 메시지가 포함된 환영 문구가 나타난다면, 여러분의 Ubuntu 시스템에 도커가 성공적으로 설치된 것입니다!\n맺음말 # 수고하셨습니다. 다소 복잡해 보이는 과정이었을지 모르지만, 이 글을 차근차근 따라오셨다면 이제 여러분의 시스템은 도커 컨테이너를 실행할 모든 준비를 마쳤습니다. 공식적인 절차를 따라 안전하게 설치했으므로, 앞으로 안정적으로 도커를 사용하실 수 있을 겁니다.\n참조:\n도커 공식 문서 (Docker Documentation) Install Docker Engine on Ubuntu ","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/install-docker-on-ubuntu/","section":"","summary":"","title":"Ubuntu에 Docker 설치하기","type":"posts"},{"content":"이 글을 읽는 분들은 아마도 \u0026ldquo;도커가 도대체 뭐길래 다들 이야기하는 걸까?\u0026rdquo; 하는 궁금증을 갖고 계실 겁니다. 괜찮습니다. 누구나 처음은 있으니까요. 저 역시 수많은 기술을 처음 접하며 하나씩 익혔던 경험이 있습니다. 이 글에서는 도커가 무엇인지 쉽고 명확하게 안내해 드리겠습니다.\n도커(Docker)란 무엇일까요? # 가장 간단하게 설명하자면, 도커는 애플리케이션을 \u0026lsquo;컨테이너\u0026rsquo;라는 독립된 공간에 담아 어디서든 동일한 환경에서 실행할 수 있게 해주는 기술(플랫폼)입니다.\n혹시 이런 경험 없으신가요? 제 컴퓨터에서는 잘 작동하던 프로그램이 동료의 컴퓨터나 실제 서버에서는 오류를 일으키는 상황 말입니다. 이는 개발 환경과 운영 환경이 미세하게 달라서 발생하는 문제입니다. 운영체제 버전, 설치된 라이브러리, 각종 설정값의 차이가 원인이죠.\n도커는 바로 이 문제를 해결합니다. 애플리케이션 실행에 필요한 모든 것(코드, 라이브러리, 시스템 도구 등)을 하나의 \u0026lsquo;컨테이너\u0026rsquo;에 담아 패키징합니다. 이 컨테이너는 어느 컴퓨터로 옮기든 내용물이 변하지 않고 그대로 실행됩니다. 마치 해외로 물건을 보낼 때, 튼튼한 컨테이너에 담아 보내면 내용물이 파손되거나 변질될 걱정이 없는 것과 같은 원리입니다.\n왜 도커를 사용해야 할까요? # 도커를 사용하면 개발자와 시스템 관리자 모두에게 다음과 같은 실질적인 이점을 제공합니다.\n환경 통일로 인한 문제 해결: \u0026ldquo;제 컴퓨터에선 됐는데\u0026hellip;\u0026ldquo;라는 말이 사라집니다. 개발, 테스트, 운영 환경을 모두 동일하게 구성할 수 있어 환경 차이로 인한 오류를 원천적으로 방지합니다.\n빠르고 쉬운 배포: 잘 만들어진 컨테이너 이미지 하나만 있으면, 수십, 수백 대의 서버에도 몇 가지 명령어로 간단하게 애플리케이션을 배포할 수 있습니다.\n서버 자원의 효율적 사용: 기존의 가상 머신(VM) 방식보다 훨씬 가볍습니다. 가상 머신은 매번 게스트 운영체제(Guest OS)를 통째로 설치해야 해서 무겁고 느렸지만, 컨테이너는 호스트 컴퓨터의 운영체제 커널을 공유하며 최소한의 라이브러리와 파일만으로 실행되므로 훨씬 적은 자원으로 더 많은 애플리케이션을 실행할 수 있습니다.\n독립적인 실행 환경: 각 컨테이너는 서로 완전히 격리된 공간에서 실행됩니다. 따라서 하나의 컨테이너에서 문제가 발생하더라도 다른 컨테이너에 영향을 주지 않아 안정적인 서비스 운영이 가능합니다.\n도커는 어디서 활용될 수 있을까요? # 도커의 활용 범위는 매우 넓습니다. 대표적인 활용 분야는 다음과 같습니다.\n웹 애플리케이션 개발 및 배포\n개발자가 자신의 노트북에서 만든 애플리케이션을 도커 컨테이너에 담아 테스트팀에 전달하고, 테스트가 완료된 컨테이너를 그대로 운영 서버에 배포하는 것이 가능합니다. 모든 환경이 동일하므로 배포 과정의 예측 가능성과 안정성이 크게 향상됩니다.\n마이크로서비스 아키텍처 (MSA)\n거대한 하나의 서비스를 여러 개의 작은 기능 단위(마이크로서비스)로 쪼개어 개발하는 방식입니다. 도커는 각 서비스를 독립된 컨테이너로 만들어 개발하고 배포하는 데 최적의 환경을 제공합니다. 예를 들어 \u0026lsquo;사용자 인증 서비스\u0026rsquo;, \u0026lsquo;상품 서비스\u0026rsquo;, \u0026lsquo;결제 서비스\u0026rsquo;를 각각의 컨테이너로 분리하여 독립적으로 관리하고 확장할 수 있습니다.\n데이터 과학 및 머신러닝\n데이터 분석이나 머신러닝 모델 개발에는 수많은 라이브러리와 복잡한 설정이 필요합니다. 분석 환경 자체를 도커 이미지로 만들어두면, 누구나 동일한 환경에서 코드를 실행하고 연구 결과를 재현할 수 있어 협업과 검증이 매우 용이해집니다.\nCI/CD 파이프라인 자동화\nCI/CD는 \u0026lsquo;지속적 통합/지속적 배포\u0026rsquo;를 의미하며, 코드 변경 사항을 자동으로 빌드, 테스트, 배포하는 과정을 말합니다. 도커는 이 과정에서 매번 깨끗하고 일관된 테스트 환경을 즉시 생성하고 폐기하는 데 사용되어 자동화 파이프라인의 신뢰도를 높여줍니다.\n도커를 배우면 무엇을 할 수 있을까요? # 도커를 익히면 개발자로서 다음과 같은 역량을 갖추게 됩니다.\n나만의 독립된 개발 환경 구축:\n프로젝트마다 필요한 환경이 다를 때 유용합니다. 예를 들어, 한 프로젝트는 오래된 버전의 데이터베이스가 필요하고 다른 프로젝트는 최신 버전이 필요할 때, 각 프로젝트를 위한 컨테이너를 따로 만들어 충돌 없이 작업할 수 있습니다.\n복잡한 소프트웨어를 명령어 하나로 실행:\n데이터베이스(PostgreSQL, Redis 등)나 분석 도구(Elasticsearch)처럼 설치 과정이 까다로운 소프트웨어도, 공식 도커 이미지를 이용해 명령어 한 줄로 간단히 실행하고 테스트해볼 수 있습니다.\n협업의 효율성 증대:\n내가 만든 애플리케이션을 동료에게 전달할 때, 소스 코드만 보내는 것이 아니라 실행 환경이 모두 담긴 도커 이미지를 전달할 수 있습니다. 동료는 복잡한 설치 과정 없이 즉시 애플리케이션을 실행해볼 수 있습니다.\n클라우드 네이티브 기술로의 확장:\n도커는 쿠버네티스(Kubernetes) 와 같은 컨테이너 오케스트레이션 도구의 가장 기본이 되는 기술입니다. 도커를 이해하는 것은 수많은 컨테이너를 효율적으로 관리하는 클라우드 네이티브 전문가로 성장하기 위한 첫걸음입니다.\n맺음말 # 지금까지 도커가 무엇인지, 왜 필요한지, 그리고 어디에 어떻게 활용할 수 있는지에 대한 기본적인 내용을 함께 살펴보았습니다. 오늘 실습한 내용은 도커가 가진 능력의 아주 작은 부분에 불과합니다. 하지만 이 첫걸음이 여러분이 앞으로 마주할 개발의 복잡성을 크게 줄여줄 단단한 초석이 되리라 믿습니다.\n처음에는 이미지, 컨테이너, 볼륨, 네트워크 등 낯선 용어들이 어렵게 느껴질 수 있습니다. 하지만, 하나씩 차근차근 시도하다 보면 어느새 도커와 친숙해진 자신을 발견하게 될 것입니다.\n두려워하지 마시고, 직접 부딪히며 경험을 쌓아나가시길 바랍니다. 기술은 결국 사람이 더 편하고 효율적으로 일하기 위해 만드는 도구일 뿐입니다. 이 글이 여러분의 첫걸음에 작은 도움이 되었기를 바랍니다.\n참조:\n도커 공식 문서 (Docker Documentation) ","date":"3 July 2025","externalUrl":null,"permalink":"/posts/develop/docker/what-is-docker/","section":"","summary":"","title":"개발자라면 반드시 알아야 할 Docker","type":"posts"},{"content":"Utterances는 GitHub의 이슈(Issues) 시스템을 활용하는 경량 댓글 위젯입니다. 광고나 추적 기능 없이 무료로 사용할 수 있으며, 모든 댓글 데이터는 여러분의 GitHub 저장소에 안전하게 보관됩니다. 그럼, 지금부터 설치를 시작하겠습니다.\nGitHub 저장소 설정 # Utterances는 댓글을 저장할 공간으로 공개(Public) GitHub 저장소를 사용합니다. 따라서 가장 먼저 댓글용 저장소를 준비해야 합니다.\nGitHub에 로그인한 후, 새로운 저장소(Repository)를 생성합니다. 저장소 이름을 정하고, 반드시 \u0026lsquo;Public\u0026rsquo; 으로 설정합니다. Private 저장소는 Utterances가 접근할 수 없습니다. 나머지 옵션은 기본값으로 두고 \u0026lsquo;Create repository\u0026rsquo; 버튼을 클릭하여 저장소를 생성합니다. Utterances 앱 설치 및 연동 # 다음으로, 생성한 저장소에 Utterances 앱을 설치하고 권한을 부여해야 합니다.\nGitHub Marketplace 로 이동합니다. \u0026lsquo;Install\u0026rsquo; 버튼을 누르면 권한 설정 페이지로 이동합니다.(저는 이미 설치된 상태라 Configure 버튼이 표시됩니다.) 여기서 \u0026lsquo;Only select repositories\u0026rsquo; 를 선택하고, 방금 생성한 댓글용 저장소를 지정해 주는 것이 좋습니다. 모든 저장소에 권한을 부여하는 것보다 보안상 안전한 방법입니다.\n\u0026lsquo;Install\u0026rsquo; 버튼을 클릭하여 설치를 완료합니다.\nBlowfish 테마 설정 파일 수정 # 이제 Hugo 프로젝트의 설정 파일을 수정하여 Utterances를 활성화할 차례입니다. Blowfish 테마는 hugo.toml 파일을 통해 댓글 기능을 손쉽게 설정할 수 있도록 지원합니다.\nHugo 프로젝트 폴더에서 layouts/partials/comments.html 파일을 생성합니다. 내용은 utterances 홈페이지 에서 저장소 위치와 테마를 선택하면 자동으로 생성됩니다. \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=[REPO_NAME] issue-term=\u0026#34;pathname\u0026#34; theme=[THEME] crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; Hugo 프로젝트 폴더에서 config/_default/params.toml 파일을 엽니다. 파일의 [article] 섹션 가장 아래에 다음과 같이 댓글 설정을 추가하거나 수정합니다. [article] ... showcomments = true 주의:\nrepo 항목에는 본인의 GitHub 사용자명과 댓글용 저장소 이름으로 정확하게 수정해야 합니다. (예: \u0026quot;Gatsby-Lee/my-blog-comments\u0026quot;) issueTerm은 각 게시물 페이지와 GitHub 이슈를 어떻게 연결할지 결정하는 중요한 설정입니다. 일반적으로 pathname을 사용하면 문제없이 작동합니다. theme은 블로그 디자인에 맞춰 \u0026lsquo;github-light\u0026rsquo;, \u0026lsquo;github-dark\u0026rsquo; 등 원하는 스타일로 변경할 수 있습니다. 확인 및 마무리 # 모든 설정을 마쳤습니다. 이제 로컬 서버를 실행하여 댓글 기능이 정상적으로 작동하는지 확인합니다.\nhugo server 웹 브라우저에서 http://localhost:1313/으로 접속한 후, 댓글 기능을 활성화한 게시물로 이동하여 페이지 하단에 Utterances 댓글 창이 나타나는지 확인하십시오. GitHub 계정으로 로그인하면 바로 댓글을 작성하고 테스트해 볼 수 있습니다.\n이것으로 Hugo Blowfish 테마에 Utterances 댓글 기능을 성공적으로 설치했습니다. 이제 방문자들과 더욱 활발하게 소통하며 블로그를 풍성하게 가꾸어 나가시길 바랍니다. 궁금한 점이 있다면 언제든지 질문해 주십시오.\n참고\nUtterances 공식 문서 Blowfish Comments ","date":"2 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-add-comments/","section":"","summary":"","title":"Blowfish 테마: Utterances 댓글 기능 설치하기","type":"posts"},{"content":"","date":"2 July 2025","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"오늘은 Hugo 블로그를 더욱 돋보이게 만들어 줄 파비콘(Favicon) 설정 방법을 안내해 드리고자 합니다. 복잡해 보일 수 있지만, 차근차근 따라오시면 누구나 쉽게 웹사이트의 얼굴을 만드실 수 있을 것입니다.\n파비콘(Favicon)이란 무엇일까요? # 파비콘은 \u0026lsquo;Favorite icon\u0026rsquo;의 줄임말로, 웹사이트를 대표하는 작은 아이콘을 의미합니다. 웹 브라우저의 탭, 북마크 목록, 스마트폰 홈 화면 등에서 여러분의 사이트를 시각적으로 식별하는 중요한 역할을 합니다. 잘 만들어진 파비콘은 사용자가 여러 탭 중에서 여러분의 사이트를 쉽게 찾도록 도와주며, 전문적인 인상을 줍니다.\n설정 전 준비사항 # Blowfish 테마에서 파비콘을 설정하는 방법은 크게 두 가지입니다. 이 가이드에서는 초보자분들도 쉽게 따라 할 수 있는, 기본 제공 파일을 교체하는 방식을 중심으로 설명하겠습니다.\n가장 먼저, 여러분의 웹사이트를 대표할 파비콘 이미지를 준비해야 합니다. 일반적으로 다음과 같은 다양한 크기와 형식의 파일이 필요합니다.\nfavicon.ico favicon-16x16.png favicon-32x32.png apple-touch-icon.png (iOS 기기용) android-chrome-192x192.png (안드로이드 기기용) android-chrome-512x512.png (안드로이드 기기용) site.webmanifest (웹 앱 매니페스트 파일) 이 모든 파일을 직접 만드는 것은 번거로울 수 있습니다. 다행히 favicon.io 와 같은 온라인 파비콘 생성 서비스를 이용하면, 고화질 이미지 하나만으로 필요한 모든 형식의 파비콘 파일을 한 번에 만들고 내려받을 수 있습니다.\n파비콘 설정 방법 # 이제 준비된 파비콘 파일들을 여러분의 Hugo 프로젝트에 적용해 보겠습니다.\nstatic 폴더 확인 # 여러분의 Hugo 프로젝트 최상위 디렉터리(root)에서 static 이라는 이름의 폴더를 찾으십시오. 만약 해당 폴더가 없다면, 직접 생성해 주시면 됩니다. Hugo는 static 폴더 안의 모든 파일을 웹사이트의 루트 디렉터리로 복사하는 특징이 있습니다.\n파비콘 파일 복사 및 붙여넣기 # 앞서 준비한 파비콘 파일들(favicon.ico, apple-touch-icon.png 등)을 모두 static 폴더 안으로 복사하여 붙여넣습니다. Blowfish 테마에 기본으로 포함된 파비콘 파일들을 여러분의 파일로 덮어쓰게 됩니다.\n파비콘 파일들은 반드시 static 폴더 바로 아래에 위치해야 합니다. 다른 하위 폴더 안에 넣지 않도록 주의하십시오. 웹사이트 변경사항 확인 # 로컬 개발 서버를 실행 중이라면, 서버를 재시작하십시오. (hugo server 명령어를 다시 실행) 그리고 웹 브라우저를 열어 여러분의 사이트에 접속합니다. 브라우저 탭에 새로운 파비콘이 정상적으로 표시되는지 확인합니다.\n파비콘이 보이지 않는다면? # 파비콘 파일을 올바르게 교체했음에도 불구하고 이전의 Blowfish 테마 아이콘이 계속 표시될 수 있습니다. 이는 대부분 웹 브라우저에 저장된 캐시(Cache) 때문입니다.\n이러한 문제가 발생하면 다음과 같은 방법을 시도해 보시기 바랍니다.\n강력 새로고침(Hard Refresh): Ctrl + Shift + R (Windows/Linux) 또는 Cmd + Shift + R (Mac) 키를 눌러 브라우저 캐시를 무시하고 페이지를 새로고침합니다. 시크릿 모드/개인정보 보호 창 사용: 브라우저의 시크릿 모드(또는 개인정보 보호 창)에서 사이트에 접속하여 확인합니다. 시크릿 모드는 캐시나 확장 프로그램의 영향을 받지 않아 변경 사항을 정확하게 확인할 수 있습니다. 브라우저 캐시 삭제: 위의 방법으로도 해결되지 않으면, 브라우저 설정에서 직접 캐시 데이터를 삭제한 후 다시 확인해 보십시오. 마무리하며 # 지금까지 Hugo Blowfish 테마에서 파비콘을 설정하는 방법을 알아보았습니다. 이 가이드가 여러분의 웹사이트를 개성 있게 만드는 데 작은 보탬이 되기를 바랍니다. 기술적인 부분에서 어려움을 느끼시는 분들께 실질적인 도움이 되었으면 하는 바람입니다.\n","date":"1 July 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-favicon/","section":"","summary":"","title":"Blowfish 테마: 파비콘(Favicon) 설정하기","type":"posts"},{"content":"","date":"1 July 2025","externalUrl":null,"permalink":"/categories/hosting/","section":"Categories","summary":"","title":"Hosting","type":"categories"},{"content":"블로그 글이 길어질수록 독자는 원하는 정보를 찾기 어려워집니다. 이때 글의 구조를 한눈에 보여주는 TOC(Table of Contents, 목차) 는 매우 유용한 기능입니다. 독자는 목차를 통해 전체 내용을 빠르게 파악하고 원하는 섹션으로 즉시 이동할 수 있어 사용자 경험을 크게 향상시킬 수 있습니다.\nBlowfish 테마는 강력한 TOC 기능을 내장하고 있어, 간단한 설정만으로 블로그 글에 목차를 추가할 수 있습니다. 이 글에서는 Blowfish 테마의 기본 TOC 설정부터 사용자의 스크롤에 반응하는 동적 TOC 기능까지 설정하는 방법을 알아보겠습니다.\n전체 블로그에 TOC 기본 설정하기 # 가장 먼저, 블로그 전체에 TOC를 기본적으로 활성화하는 방법입니다. Hugo 프로젝트의 config/_default 디렉터리에 있는 params.toml 파일을 수정합니다.\n[params.article] 섹션에 다음 설정을 추가하거나 수정합니다. 만약 해당 섹션이 없다면 새로 만들어주면 됩니다.\n# config/_default/params.toml [article] # true로 설정하면 모든 글에 기본적으로 목차가 표시됩니다. showTableOfContents = true 이 설정 하나만으로 모든 게시물에 목차가 자동으로 생성됩니다.\nTOC 상세 설정 (표시할 제목 레벨 조정) # Blowfish 테마에서는 목차에 표시될 마크다운 제목(heading)의 레벨을 지정할 수 있습니다. 예를 들어, \u0026lt;h2\u0026gt;(##) 부터 \u0026lt;h4\u0026gt;(####) 까지의 제목만 목차에 포함하고 싶을 수 있습니다.\nmarkup.toml 파일의 [tableOfContents] 섹션에서 이를 제어할 수 있습니다.\n# config/_default/markup.toml [tableOfContents] # 목차 생성을 시작할 제목 레벨 (기본값: 2) # 2는 \u0026lt;h2\u0026gt;(##)를 의미합니다. startLevel = 2 # 목차 생성을 마칠 제목 레벨 (기본값: 3) # 3은 \u0026lt;h3\u0026gt;(###)를 의미합니다. endLevel = 3 # 목록 항목을 순서 있는 리스트(1., 2., ...)로 표시할지 여부 (기본값: false) ordered = false startLevel: 목차에 포함할 가장 상위 제목 레벨입니다. \u0026lt;h2\u0026gt;는 2, \u0026lt;h3\u0026gt;는 3으로 설정합니다. endLevel: 목차에 포함할 가장 하위 제목 레벨입니다. \u0026lt;h4\u0026gt;까지 포함하려면 4로 설정합니다. 이 설정을 통해 너무 상세하거나 불필요한 제목은 목차에서 제외하여 더 깔끔한 TOC를 구성할 수 있습니다.\n동적 TOC 기능 활성화하기 (smartTOC) # Blowfish 테마는 사용자의 스크롤 위치에 따라 현재 읽고 있는 부분의 목차를 하이라이트 해주는 스마트 TOC 기능을 제공합니다. 이는 독자에게 현재 위치를 시각적으로 알려주어 긴 글을 읽을 때 매우 유용합니다.\nparams.toml 파일의 smartTOC 항목을 확인합니다.\n# config/_default/params.toml # 스마트 TOC 기능 활성화 smartTOC = true 하위 목차 자동 숨기기 # smartTOC를 사용할 때, 글의 구조가 복잡하고 하위 목차가 많으면 TOC 자체가 너무 길어질 수 있습니다. 이때 smartTOCHideUnfocusedChildren 옵션을 사용하면 현재 보고 있는 섹션의 하위 목차만 펼쳐지고, 나머지 비활성 섹션의 하위 목차는 자동으로 접히게 됩니다.\nparams.toml 파일에 다음과 같이 설정을 추가합니다.\n# config/_default/params.toml smartTOC = true # 현재 위치가 아닌 다른 섹션의 하위 목차를 숨깁니다. smartTOCHideUnfocusedChildren = true 이 기능을 사용하면 매우 긴 글에서도 목차를 간결하고 집중도 있게 유지할 수 있습니다.\n특정 글에서만 TOC 설정 변경하기 (Front Matter 활용) # 전체 기본 설정을 따르지 않고, 특정 게시물에 대해서만 목차를 표시하거나 숨기고 싶을 때가 있습니다. 이 경우, 해당 마크다운 파일(.md)의 Front Matter 영역에서 개별적으로 제어할 수 있습니다.\nFront Matter는 마크다운 문서 최상단에 --- 또는 +++로 둘러싸인 메타데이터 영역을 말합니다.\n특정 글에서만 TOC 보이기 # hugo.toml에서 showTableOfContents = false로 설정했더라도, 특정 글에서만 목차를 표시하고 싶다면 해당 글의 Front Matter에 다음을 추가합니다.\n--- title: \u0026#34;특정 글 제목\u0026#34; date: 2025-06-29 showTableOfContents: true --- 여기에 글 내용이 들어갑니다... 특정 글에서만 TOC 숨기기 # 반대로 hugo.toml에서 showTableOfContents = true로 설정했지만, 짧은 공지사항과 같이 목차가 필요 없는 글에서는 개별적으로 숨길 수 있습니다.\n--- title: \u0026#34;공지사항\u0026#34; date: 2025-06-29 showTableOfContents: false --- 간단한 공지 내용입니다... 이처럼 Front Matter 설정은 params.toml의 전역 설정보다 우선 적용되므로, 글의 성격에 따라 유연하게 목차를 관리할 수 있습니다.\n※ 참조: TOC가 표시되지 않는 경우 # 설정을 완료했는데도 목차가 보이지 않는다면 다음을 확인해 보세요.\n게시물에 마크다운 제목이 있나요? 목차는 ##, ### 와 같은 마크다운 제목 태그를 기반으로 생성됩니다. 본문에 markup.toml 파일에서 [tableOfContents]에 설정된 레벨 범위(startLevel ~ endLevel)에 해당하는 제목이 하나도 없다면 TOC는 표시되지 않습니다. 간단한 설정으로 블로그의 가독성과 사용자 편의성을 크게 높일 수 있습니다. 지금 바로 여러분의 Hugo Blowfish 블로그에 동적 TOC 기능을 적용해 보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-toc/","section":"","summary":"","title":"Blowfish 테마: TOC(목차) 설정으로 블로그 가독성 높이기 ","type":"posts"},{"content":"오늘은 파일명 규칙 하나만으로 섬네일을 자동으로 설정하고, 간단한 옵션으로 히어로 이미지까지 제어하는 Blowfish 테마의 \u0026lsquo;컨벤션(Convention)\u0026rsquo; 기반 설정법을 완벽하게 알려드립니다.\n파일명 규칙과 Leaf Bundle # 이 스마트한 기능을 사용하기 위해서는 Leaf Bundle 방식으로 구성하고, 정해진 파일명 패턴을 사용하는 것입니다.\nLeaf Bundle 구조:\n이전과 동일하게, 각 게시물은 고유한 폴더를 갖고 그 안에 index.md 파일과 이미지들이 함께 위치해야 합니다.\n자동 감지 파일명:\nBlowfish 테마는 Leaf Bundle 폴더 안에서 아래 패턴과 일치하는 이미지 파일을 발견하면, 자동으로 해당 이미지를 포스트의 섬네일로 인식합니다.\nfeature* (예: featured.jpg, feature-image.png) 이 패턴과 일치하는 이미지가 있다면, Front Matter에 thumbnail 키를 추가하지 않아도 목록 페이지에 섬네일이 자동으로 표시됩니다.\n섬네일 설정하기 # 게시물 폴더(예: content/posts/my-smart-post/) 안에 featured.jpg 라는 이름으로 이미지를 추가합니다. 이것으로 끝입니다. index.md 파일의 Front Matter에는 아무것도 추가할 필요가 없습니다.\n단지 규격에 맞는 이름의 파일을 추가하는 것만으로, Blowfish는 이 이미지를 섬네일로 인식하고 홈페이지나 글 목록 페이지에 자동으로 보여줍니다.\n섬네일을 히어로 이미지로 사용하기 # 이제 이 섬네일을 포스트 본문의 배경(히어로 이미지)으로도 사용하고 싶다면, index.md의 Front Matter에 단 한 줄만 추가하면 됩니다.\n# content/posts/my-smart-post/index.md --- title: \u0026#34;자동으로 설정되는 이미지\u0026#34; date: 2025-06-29 showHero = true # 이 한 줄만 추가! --- showHero = true 옵션은 \u0026ldquo;이 페이지에 히어로 이미지 영역을 표시하라\u0026quot;는 명령어입니다. 이때 Blowfish는 자동으로 감지했던 featured.jpg 파일을 가져와 히어로 이미지로 사용합니다.\n마무리하며 # Blowfish 테마의 자동 감지 기능은 \u0026lsquo;설정보다 관례(Convention over Configuration)\u0026lsquo;라는 현대적인 개발 철학을 잘 보여주는 훌륭한 기능입니다. 이 스마트한 기능을 활용하면 Front Matter를 훨씬 더 간결하게 유지하면서도 블로그의 시각적 요소를 풍부하게 만들 수 있습니다.\n이제부터는 featured.jpg 파일 하나만 추가하는 간편한 방법으로 여러분의 콘텐츠를 더욱 돋보이게 만들어 보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/post-add-thumnail/","section":"","summary":"","title":"Blowfish 테마: 섬네일 \u0026 히어로 이미지 설정 방법","type":"posts"},{"content":"방문자가 내 블로그의 콘텐츠를 쉽게 탐색하도록 돕는 가장 중요한 요소는 바로 \u0026lsquo;메뉴\u0026rsquo;입니다. Blowfish 테마는 사이트 상단의 메인 메뉴(main)와 하단의 푸터 메뉴(footer), 그리고 드롭다운 형태의 서브메뉴까지 유연하게 지원합니다.\n오늘은 이 모든 종류의 메뉴를 설정하는 방법을 알아 보겠습니다.\n메뉴 설정의 핵심 파일: menus.xx.toml # Blowfish의 모든 메뉴는 config/_default/ 폴더 안에 있는 menus.xx.toml 파일 하나로 관리됩니다.\n파일 위치: config/_default/menus.en.toml (기본 설치 시) 한국어 설정: 만약 블로그의 주 언어가 한국어이고 다중어 설정이 필요하다면, 이 파일의 이름을 menus.ko.toml로 변경하여 사용하는 것이 좋습니다. 이렇게 하면 다국어 설정 시 언어별로 다른 메뉴를 구성할 수 있습니다. 이 파일 안에는 크게 [[main]] (메인 메뉴)과 [[footer]] (푸터 메뉴) 두 종류의 메뉴 아이템을 정의할 수 있습니다.\n기본 메뉴 아이템 추가하기 (내부 페이지 링크) # 가장 기본적인 메뉴 설정은 블로그의 특정 섹션(예: 글 목록)으로 연결하는 것입니다.\nmenus.en.toml 파일을 열고 아래와 같이 작성합니다.\n# config/_default/menus.en.toml # -- Main Menu -- # 사이트 헤더 상단에 표시되는 메인 메뉴 [[main]] # 메뉴에 표시될 이름 name = \u0026#34;Blog\u0026#34; # Hugo 콘텐츠 섹션과 연결합니다. # \u0026#39;content/posts\u0026#39; 폴더를 가리키며, URL이 변경되어도 깨지지 않는 가장 안정적인 방식입니다. pageRef = \u0026#34;posts\u0026#34; # 메뉴의 순서를 결정합니다. 숫자가 낮을수록 왼쪽에 표시됩니다. weight = 10 [[main]] name = \u0026#34;Categories\u0026#34; pageRef = \u0026#34;categories\u0026#34; weight = 20 name: 방문자에게 보여질 메뉴의 이름입니다. pageRef: content/ 폴더 안의 특정 폴더(섹션)나 파일을 가리킵니다. 예를 들어 posts는 /posts/ 페이지로 연결됩니다. weight: 메뉴의 순서를 정합니다. 숫자가 낮을수록 우선순위가 높습니다. 외부 링크와 아이콘 추가하기 # 내 GitHub나 다른 웹사이트로 연결되는 메뉴도 쉽게 추가할 수 있습니다.\n[[main]] name = \u0026#34;GitHub\u0026#34; # 외부 URL을 직접 지정합니다. pageRef와 함께 사용할 수 없습니다. url = \u0026#34;https://github.com/your-id\u0026#34; weight = 30 # 이름 앞에 아이콘을 추가합니다. # Blowfish는 \u0026#39;github\u0026#39;, \u0026#39;twitter\u0026#39; 등 몇 가지 아이콘을 내장하고 있습니다. pre = \u0026#34;github\u0026#34; url: 외부 링크를 걸 때 사용합니다. pre: 메뉴 이름 앞에 표시될 내용을 지정합니다. Blowfish는 몇 가지 소셜 아이콘 키워드를 지원하여, 위와 같이 설정하면 이름 앞에 GitHub 아이콘이 자동으로 나타납니다. 드롭다운 서브메뉴 만들기 # 관련 페이지들을 묶어 드롭다운 메뉴로 만들 수 있습니다. 이를 위해서는 identifier와 parent라는 두 가지 파라미터가 필요합니다.\n# 1. 부모 메뉴 아이템을 먼저 정의합니다. # 이 아이템은 드롭다운의 제목 역할을 하며, 보통 링크는 없습니다. [[main]] name = \u0026#34;더 보기\u0026#34; # 이 메뉴의 고유 ID를 지정합니다. 자식 메뉴들이 이 ID를 참조합니다. identifier = \u0026#34;more\u0026#34; weight = 40 # 2. 첫 번째 자식 메뉴를 정의합니다. [[main]] name = \u0026#34;About\u0026#34; pageRef = \u0026#34;about\u0026#34; # content/about.md 페이지로 연결 # 부모 메뉴의 identifier를 \u0026#39;parent\u0026#39;로 지정합니다. parent = \u0026#34;more\u0026#34; weight = 10 # 서브메뉴 안에서의 순서 # 3. 두 번째 자식 메뉴를 정의합니다. [[main]] name = \u0026#34;저자 소개\u0026#34; pageRef = \u0026#34;authors\u0026#34; # content/authors/ 섹션으로 연결 parent = \u0026#34;more\u0026#34; weight = 20 identifier: 부모가 될 메뉴 아이템에 부여하는 고유한 이름표입니다. parent: 자식 메뉴가 어떤 부모 메뉴 아래에 속할지를 identifier 값으로 지정합니다. 푸터(Footer) 메뉴 설정하기 # 사이트 하단에 표시되는 푸터 메뉴는 메인 메뉴와 설정 방식이 완전히 동일합니다. [[main]] 대신 [[footer]] 블록을 사용하기만 하면 됩니다.\n# -- Footer Menu -- # 사이트 하단에 표시되는 메뉴 [[footer]] name = \u0026#34;개인정보처리방침\u0026#34; pageRef = \u0026#34;privacy\u0026#34; weight = 10 마무리하며 # 지금까지 Hugo Blowfish 테마에서 메뉴를 설정하는 모든 방법을 알아보았습니다. menus.en.toml 파일 하나만 잘 이해하면, 블로그의 내비게이션을 원하는 대로 자유롭게 구성할 수 있습니다.\n내부 링크는 pageRef 외부 링크는 url 순서는 weight 드롭다운은 identifier와 parent 이 네 가지 핵심 규칙만 기억하시면 됩니다. 이제 여러분의 블로그에 방문자들이 길을 잃지 않도록 튼튼한 이정표를 세워보세요.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-menu/","section":"","summary":"","title":"Blowfish 테마: 메뉴 설정 가이드 (Main, Footer, Dropdown)","type":"posts"},{"content":"Hugo와 Blowfish 테마를 사용하여 블로그를 만들 때, 가장 중요하면서도 처음에는 헷갈리는 부분이 바로 콘텐츠를 어떻게 구성하고 정리하는가입니다. 잘 정리된 콘텐츠 구조는 보기에도 좋을 뿐만 아니라, URL 경로, 메뉴 구성, 그리고 장기적인 유지보수에 직접적인 영향을 미칩니다.\n오늘은 Hugo의 공식적인 콘텐츠 조직 방법론을 바탕으로, Blowfish 테마에서 이를 어떻게 효과적으로 적용할 수 있는지에 대한 완벽한 가이드를 제시합니다.\nHugo 콘텐츠 구성의 핵심: 섹션(Sections) # Hugo는 매우 직관적인 방식으로 콘텐츠를 구성합니다. 프로젝트의 content/ 폴더 안에 만드는 최상위 폴더가 곧 사이트의 **섹션(Section)**이 됩니다.\n예를 들어, 아래와 같은 폴더 구조를 생각해 보세요.\ncontent/ ├── posts/ └── projects/ content/posts/ 폴더는 posts라는 섹션을 만듭니다. 이 섹션의 URL은 https://your-site.com/posts/가 됩니다. content/projects/ 폴더는 projects 섹션을 만듭니다. URL은 https://your-site.com/projects/가 됩니다. 이처럼 폴더 구조가 그대로 사이트의 URL 구조로 연결되는 것이 Hugo의 가장 큰 특징입니다. Blowfish 테마 역시 이 기본 구조를 그대로 따릅니다.\n두 종류의 index 파일: _index.md vs index.md # Hugo의 콘텐츠 구조를 이해하기 위한 가장 중요한 개념은 바로 _index.md와 index.md 파일의 차이를 아는 것입니다.\n_index.md: 섹션의 대표 페이지 (List Page) # _index.md 파일은 특정 폴더(섹션) 자체를 설명하는 대표 페이지를 만들 때 사용됩니다. 예를 들어, content/posts/_index.md 파일은 /posts라는 URL로 접속했을 때 보이는 게시글 목록 페이지의 제목이나 상단 소개글을 제어합니다.\n--- # content/posts/_index.md title: \u0026#34;나의 기술 블로그\u0026#34; description: \u0026#34;개발 과정에서 배운 점과 기술적인 고민을 공유합니다.\u0026#34; --- 이곳은 저의 개발 블로그입니다. 다양한 주제의 글들을 살펴보세요. 위 내용 중 Front Matter(\u0026mdash;로 둘러싸인 부분)는 페이지의 메타데이터를, 그 아래 내용은 게시글 목록 상단에 표시될 콘텐츠를 정의합니다.\nindex.md: 개별 페이지와 리소스 묶음 (Leaf Bundle) # index.md 파일은 하나의 완전한 개별 페이지를 만들 때 사용되며, 특히 해당 페이지에 사용되는 이미지 등의 리소스를 함께 묶어서 관리할 때 매우 유용합니다. 이를 Leaf Bundle 방식이라고 부릅니다.\n예를 들어, my-first-post라는 글을 작성한다고 가정해 봅시다.\ncontent/posts/ └── my-first-post/ ├── index.md \u0026lt;-- 글의 실제 내용 └── hero.png \u0026lt;-- 이 글에서 사용할 대표 이미지 이 구조의 가장 큰 장점은 index.md 파일 안에서 이미지를 ![대표 이미지](hero.png)처럼 매우 간단하게 참조할 수 있다는 것입니다. 경로가 복잡해지지 않아 관리가 매우 편리하며, 새로운 글을 작성할 때 가장 추천되는 방식입니다.\nBlowfish 테마 추천 콘텐츠 구조 # 위의 개념들을 바탕으로, 일반적인 Blowfish 블로그에 추천하는 전체적인 콘텐츠 구조는 다음과 같습니다.\n. ├── assets │ └── img │ └── author.jpg ├── config │ └── _default ├── content │ ├── _index.md # 🏠 사이트 전체의 홈페이지 콘텐츠 │ ├── about.md │ └── posts # 📝 \u0026#39;posts\u0026#39; 섹션 │ ├── _index.md # /posts/ 리스트 페이지의 제목/소개 │ ├── first-post.md # 첫 번째 글 (Page Bundle) │ └── another-post # 두 번째 글 (Leaf Bundle) │ ├── aardvark.jpg │ └── index.md └── themes └── blowfish content/_index.md: 사이트의 메인 홈페이지(https://your-site.com/) 내용을 제어합니다. Blowfish의 hero나 profile 레이아웃을 설정할 때 사용됩니다. content/posts/: 모든 블로그 게시글이 위치하는 곳입니다. content/authors/: Blowfish 테마의 저자별 페이지 기능을 위해 사용되는 특별한 섹션입니다. 각 저자별로 폴더를 만들고 그 안에 _index.md를 두어 저자 소개 페이지를 만들 수 있습니다. 마무리하며 # Hugo의 콘텐츠 구성 방식은 \u0026lsquo;폴더가 곧 섹션\u0026rsquo;이라는 간단한 규칙에서 시작합니다. 여기에 _index.md와 index.md의 역할을 정확히 이해하고, Blowfish 테마가 요구하는 Front Matter를 적절히 활용하면 매우 체계적이고 확장 가능한 블로그를 만들 수 있습니다.\n새로운 글을 작성하실 때는 가급적 폴더를 만들고 그 안에 index.md를 생성하는 Leaf Bundle 방식을 사용해 보세요. 이미지 관리가 훨씬 수월해져 콘텐츠 작성의 즐거움이 배가 될 것입니다.\n","date":"29 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-contents-organizing/","section":"","summary":"","title":"Blowfish 테마: 콘텐츠 구조화 가이드 ","type":"posts"},{"content":"Blowfish 테마 설치 후 가장 먼저 해야 할 일은 바로 블로그의 \u0026lsquo;얼굴\u0026rsquo;을 만드는 것입니다. 방문자가 사이트를 기억하게 만드는 가장 중요한 두 요소인 제목과 로고를 설정하는 방법을 알아보겠습니다.\n사이트 제목(Title) 설정하기 # 사이트 제목은 브라우저 탭, 검색 엔진 결과(SEO), 그리고 로고가 없을 때 표시되는 중요한 텍스트입니다. 설정은 매우 간단합니다.\n프로젝트의 config/_default/languages.en.toml 파일을 엽니다. 파일 내에서 title 변수를 찾아 원하는 사이트 제목으로 변경합니다.\n# config/_default/languages.en.toml title = \u0026#34;My awesome website\u0026#34; 로고(Logo) 설정하기 # 로고는 사이트의 시각적인 상징입니다. Blowfish 테마에서는 라이트 모드와 다크 모드에 따라 다른 로고를 표시하는 기능도 지원합니다.\n로고 파일 준비 및 배치 # 먼저 사용할 로고 이미지 파일을 준비해야 합니다.\n라이트 모드용 로고 (예: logo-light.png) 다크 모드용 로고 (예: logo-dark.png) - 배경이 어두울 때 잘 보이는 이미지로 준비하는 것이 좋습니다. assets 폴더에 배치: # 준비한 로고 파일들을 프로젝트의 assets/images/ 폴더 안에 넣습니다. assets 폴더나 images 폴더가 없다면 직접 생성해 주세요.\n. └── assets/ └── images/ ├── logo-light.png └── logo-dark.png 로고 설정 # 이제 Hugo에게 어떤 파일을 로고로 사용할지 알려줄 차례입니다.\nlanguages.en.toml 파일 열기 프로젝트의 config/_default/languages.en.toml 파일을 엽니다.\n[logo] 섹션 찾기 및 수정 파일 내에서 [params] 섹션을 찾아 아래와 같이 로고 파일 경로와 설정을 입력합니다.\n# config/_default/params.toml [params] displayName = \u0026#34;EN\u0026#34; isoCode = \u0026#34;en\u0026#34; rtl = false dateFormat = \u0026#34;2 January 2006\u0026#34; # 라이트 모드(기본)에서 표시될 로고 # assets 폴더를 기준으로 경로를 작성합니다. logo = \u0026#34;images/logo.png\u0026#34; # 다크 모드에서 표시될 로고 secondaryLogo = \u0026#34;images/logo-dark.png\u0026#34; # description = \u0026#34;My awesome website\u0026#34; # copyright = \u0026#34;Copy, _right?_ :thinking_face:\u0026#34; ... 설정 확인하기 # 제목과 로고 설정이 완료되었습니다. 아래 명령어로 로컬 서버를 실행하여 변경 사항이 잘 적용되었는지 확인하세요.\nhugo server 웹 브라우저에서 http://localhost:1313으로 접속한 뒤, 사이트 헤더의 왼쪽 상단에 새로운 로고가 보이는지, 브라우저 탭에 설정한 제목이 올바르게 표시되는지 확인합니다. 다크 모드/라이트 모드 전환 시 로고가 바뀌는지도 테스트해 보세요.\n이렇게 간단한 설정만으로도 사이트의 개성과 정체성을 명확하게 표현할 수 있습니다.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-title-and-logo/","section":"","summary":"","title":"Blowfish 테마: 사이트 제목과 로고 설정하기","type":"posts"},{"content":"저자 정보는 홈페이지의 프로필 레이아웃이나 각 게시글 하단의 저자 소개 카드에 표시됩니다. 설정은 config/_default/params.toml 파일에서 [author] 섹션을 수정하여 이루어집니다.\n설정 단계 # params.toml 파일 열기 # 프로젝트의 config/_default/languages.en.toml 파일을 엽니다.\n[author] 섹션 찾기 및 수정 # 파일 내에서 [author] 섹션을 찾아 아래와 같이 자신의 정보를 입력합니다. 주석 처리된(#) 부분을 해제하고 내용을 수정하세요.\n# config/_default/params.toml [author] # 저자 이름 name = \u0026#34;홍길동\u0026#34; # 프로필 이미지 경로. assets 폴더 기준입니다. # 예: assets/images/profile.jpg -\u0026gt; \u0026#34;images/profile.jpg\u0026#34; image = \u0026#34;images/profile.jpg\u0026#34; # 홈페이지 프로필 레이아웃에 표시될 짧은 소개 문구 headline = \u0026#34;더 나은 내일을 만드는 개발자\u0026#34; # 각 게시글 하단에 표시될 저자 소개 bio = \u0026#34;안녕하세요! 기술로 세상을 이롭게 만들고 싶은 개발자 홍길동입니다. 이 블로그에는 저의 성장 과정과 기술적인 고민을 담고 있습니다.\u0026#34; # 소셜 미디어 등 개인 링크 # 아이콘은 이름(github, linkedin 등)에 따라 자동으로 표시됩니다. links = [ { github = \u0026#34;https://github.com/your-id\u0026#34; }, { linkedin = \u0026#34;https://linkedin.com/in/your-id\u0026#34; }, { twitter = \u0026#34;https://twitter.com/your-id\u0026#34; }, # { email = \u0026#34;mailto:user@example.com\u0026#34; }, ] 항목별 상세 설명 # name: 저자의 이름입니다. image: 프로필 이미지 파일의 경로입니다. 이미지는 프로젝트의 assets/ 폴더 안에 위치해야 합니다. 예를 들어, assets/images/profile.jpg에 이미지를 두었다면, 값은 \u0026quot;images/profile.jpg\u0026quot;가 됩니다. headline: 홈페이지 레이아웃을 profile로 설정했을 때, 이름 아래에 표시되는 한 줄 소개입니다. bio: 각 게시글 하단에 표시되는 저자의 약력 또는 소개글입니다. links: GitHub, LinkedIn, Twitter, 이메일 등 외부 링크를 설정하는 곳입니다. 링크 이름(github, linkedin 등)에 맞춰 자동으로 아이콘이 생성됩니다. 설정 확인 # params.toml 파일 수정 후 hugo server 명령어로 로컬 서버를 실행하여 홈페이지나 게시글 제목 아래에 저자 정보가 올바르게 표시되는지 확인하세요.\n","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/blowfish-set-author/","section":"","summary":"","title":"Blowfish 테마: 기본 저자 정보 설정하기","type":"posts"},{"content":"Hugo 블로그에 새로운 디자인을 입히고 싶으신가요? Hextra 테마는 문서나 기술 블로그에 최적화된 깔끔하고 현대적인 디자인을 제공하여 많은 개발자에게 사랑받고 있습니다.\n오늘은 Hextra 테마를 가장 빠르고 안정적으로 적용하는 방법을 단계별로 알려드리겠습니다.\n기존 테마 제거 (선택사항) # 새로운 테마를 적용하기 전에, 기존 테마 폴더를 정리하는 것이 좋습니다. 이 과정은 필수는 아니지만, 프로젝트를 깨끗하게 유지하는 데 도움이 됩니다.\nGit 서브모듈로 설치된 경우: # # \u0026#39;old-theme\u0026#39;은 실제 이전 테마 폴더명으로 변경하세요. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 직접 다운로드한 경우: # # \u0026#39;old-theme\u0026#39;은 실제 이전 테마 폴더명으로 변경하세요. rm -rf themes/old-theme Hextra 테마 설치 # 가장 추천하는 방법은 Git Submodule을 사용하여 프로젝트에 테마를 추가하는 것입니다. 이 방법을 사용하면 나중에 테마가 업데이트되었을 때 간단한 명령어로 최신 버전을 적용할 수 있습니다.\n프로젝트의 최상위 폴더(루트)에서 아래 명령어를 실행하세요.\ngit submodule add https://github.com/imfing/hextra.git themes/hextra Hugo 설정 파일 수정 # 이제 Hugo에게 Hextra 테마를 사용하라고 알려줄 차례입니다. 블로그의 메인 설정 파일인 hugo.toml을 열어 theme 변수를 수정합니다.\n# hugo.toml 파일 예시 theme = \u0026#34;hextra\u0026#34; Hextra 테마는 다크 모드, 검색 기능, 메뉴 구성 등 다양한 사용자 설정 옵션을 제공합니다. 더 상세한 커스터마이징을 원하시면 공식 문서를 참고하여 params.toml 등을 설정해 보세요.\n로컬 서버에서 확인 # 모든 설정이 끝났습니다. 로컬 서버를 실행하여 변경 사항이 블로그에 잘 적용되었는지 확인합니다.\nhugo server 이제 웹 브라우저 주소창에 http://localhost:1313을 입력하고 접속해 보세요. 새로운 Hextra 테마가 적용된 블로그의 모습을 실시간으로 확인할 수 있습니다.\n변경사항 배포 # 로컬에서 보이는 모습에 만족했다면, 마지막으로 변경 사항을 원격 저장소에 푸시하여 실제 블로그에 반영합니다.\ngit add . git commit -m \u0026#34;Feat: Apply Hextra theme\u0026#34; git push 마무리하며 # 이것으로 모든 과정이 끝났습니다. 보시다시피 몇 가지 명령어만으로 기존 블로그의 분위기를 완전히 새롭게 바꿀 수 있습니다. Hextra 테마의 깔끔한 디자인과 편리한 기능들을 활용하여 여러분의 지식을 더 멋지게 공유해 보시길 바랍니다.\n참고:\nHextra 공식 사이트 ","date":"28 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-hextra/","section":"","summary":"","title":"Hugo 블로그에 Hextra 테마 적용하는 가장 간단한 방법","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"Hugo로 멋진 블로그나 웹사이트를 만들고, Git으로 소스 코드를 관리하는 것은 이제 많은 분들에게 익숙한 과정입니다. 하지만 git add .과 git commit을 실행하기 전에, 우리는 한 가지 중요한 질문을 스스로에게 던져봐야 합니다. \u0026ldquo;어떤 파일을 Git으로 관리하고, 어떤 파일은 무시해야 할까?\u0026rdquo;\n이 질문에 대한 해답을 주는 것이 바로 .gitignore 파일입니다. 잘 구성된 .gitignore 파일은 깨끗하고 효율적인 저장소 관리의 첫걸음이자, 개발자의 전문성을 보여주는 작지만 중요한 지표입니다.\n오늘은 어떤 Hugo 프로젝트에도 바로 적용할 수 있는 표준 .gitignore 템플릿을 제공하고, 각 항목을 왜 추가해야 하는지 그 이유까지 명확하게 설명해 드리겠습니다.\n왜 .gitignore 설정이 중요한가요? # Git 관리의 핵심 원칙은 \u0026ldquo;소스 코드는 추적하고, 자동으로 생성되는 파일이나 민감한 정보는 제외한다\u0026rdquo; 는 것입니다. 만약 이 원칙을 지키지 않으면 다음과 같은 문제들이 발생할 수 있습니다.\n저장소 용량 낭비 및 속도 저하: hugo 명령어를 실행하면 public 폴더에 수많은 HTML, CSS 파일들이 생성됩니다. 이 파일들을 모두 Git으로 관리하면 저장소 용량이 불필요하게 커지고, clone 이나 push/pull 속도가 느려집니다. 의미 없는 충돌(Conflict) 발생: 협업 시 각자 생성한 public 이나 resources 폴더 내용이 달라져 불필요한 병합 충돌이 발생합니다. 이는 해결하는 것 자체가 시간 낭비입니다. 보안 사고 발생: API 키나 비밀번호가 담긴 .env 파일이 실수로 GitHub Public 저장소에 올라가면, 심각한 보안 사고로 이어질 수 있습니다. 이 모든 문제를 예방하는 것이 바로 .gitignore의 역할입니다.\nHugo .gitignore 표준 템플릿 # 아래는 어떤 Hugo 프로젝트에도 적용할 수 있는 표준 템플릿입니다. 이 내용을 프로젝트 최상위 폴더에 있는 .gitignore 파일에 그대로 복사해서 사용하세요.\n코드 스니펫\n# ========================================= # Hugo 생성 파일 (Hugo Generated Files) # ========================================= # \u0026#39;hugo\u0026#39; 빌드 시 생성되는 최종 결과물 폴더. # 소스 코드만 있으면 언제든 재생성 가능하므로 반드시 제외. /public/ # 이미지 처리, 에셋 번들링 등 Hugo Pipes 결과물이 캐시되는 폴더. # 이 역시 소스로부터 재생성되므로 제외. /resources/ # Hugo 빌드 중 생성되는 임시 잠금 파일. .hugo_build.lock # ========================================= # Node.js 의존성 (Node.js Dependencies) # ========================================= # Tailwind CSS 등 Node.js 기반 도구 사용 시 생성되는 패키지 폴더. # \u0026#39;npm install\u0026#39; 명령어로 언제든 복구 가능하므로 제외. /node_modules/ # ========================================= # OS 및 시스템 파일 (OS \u0026amp; System Files) # ========================================= # macOS 시스템 파일 .DS_Store # Windows 시스템 파일 Thumbs.db # ========================================= # IDE 및 에디터 설정 (IDE \u0026amp; Editor Settings) # ========================================= # Visual Studio Code 에디터 설정 폴더 .vscode/ # JetBrains 계열 에디터(GoLand, WebStorm 등) 설정 폴더 .idea/ # ========================================= # 민감한 정보 및 로그 (Sensitive Info \u0026amp; Logs) # ========================================= # API 키, 비밀번호 등 민감한 정보를 담는 환경 변수 파일. # 보안을 위해 절대로 Git에 커밋 금지! .env # 각종 로그 파일 *.log 내 프로젝트에 적용하는 방법 # 적용 방법은 간단합니다. 하지만 이미 관련 파일들을 커밋한 이력이 있다면, 추가적인 명령어가 필요합니다.\n.gitignore 파일 생성 및 내용 붙여넣기 # 프로젝트 최상위 폴더에 .gitignore 파일이 없다면 생성하고, 위 템플릿 내용을 모두 복사하여 붙여넣습니다.\n이미 커밋된 파일들을 Git 추적에서 제외하기 # 만약 위 템플릿에 있는 파일이나 폴더(예: public, resources)를 이미 커밋한 적이 있다면, .gitignore에 추가해도 Git은 계속해서 해당 파일들을 추적합니다. 따라서 아래 명령어를 통해 Git의 추적 목록에서 명시적으로 제거해주어야 합니다.\n# Git의 추적 목록(Staging Area)에서만 제거합니다. # --cached 옵션 덕분에 내 컴퓨터에 있는 실제 폴더와 파일은 삭제되지 않습니다. git rm -r --cached public/ git rm -r --cached resources/ # 만약 다른 파일들도 이미 커밋했다면 같은 방식으로 추가합니다. # 예: git rm -r --cached .vscode/ # 이제 .gitignore 파일과 추적 제외 상태를 함께 커밋합니다. git add .gitignore git commit -m \u0026#34;Feat: Setup .gitignore and untrack generated files\u0026#34; git push 이 과정을 거치면 앞으로 해당 파일들은 git status에 나타나지 않으며, 여러분은 오직 중요한 소스 코드 변경에만 집중할 수 있게 됩니다.\n마무리하며 # .gitignore를 올바르게 설정하는 것은 단순히 몇 줄의 텍스트를 추가하는 행위가 아닙니다. 내 프로젝트의 무엇이 \u0026lsquo;소스\u0026rsquo;이고 무엇이 \u0026lsquo;결과물\u0026rsquo;인지를 명확히 정의하는 설계 과정의 일부이며, 깨끗하고 안전한 버전 관리를 위한 가장 기본적이고 중요한 습관입니다.\n지금 바로 여러분의 Hugo 프로젝트에 이 표준 .gitignore 템플릿을 적용하여, 보다 전문적인 개발 환경을 구축해 보세요.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/set-gitignore-for-hugo/","section":"","summary":"","title":"Hugo 프로젝트를 위한 완벽한 .gitignore 설정 가이드","type":"posts"},{"content":"오늘은 세련된 디자인과 강력한 커스터마이징 기능으로 많은 주목을 받고 있는 Blowfish 테마를 기존에 운영하던 Hugo 블로그에 적용하는 방법을 상세하게 안내해 드리겠습니다.\n이 글에서는 Blowfish 공식 문서가 권장하는 방식인 Git Submodule**을 사용하여, 가장 안정적이고 확실하게 테마를 설치하고 기본 설정을 완료하는 전 과정을 다룹니다. 차근차근 따라오시면 누구나 멋진 블로그를 완성할 수 있습니다.\n기존 테마 깔끔하게 제거하기 # 새로운 옷을 입기 전, 기존 옷을 먼저 정리해야겠죠. 현재 사용 중인 테마를 깔끔하게 제거하는 것부터 시작하겠습니다. 테마 설치 방식에 따라 아래 방법 중 하나를 선택하세요.\nGit 서브모듈로 설치된 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 단순히 폴더만 삭제하는 것을 넘어, Git의 추적 기록까지 완전히 정리해 주는 가장 깔끔한 방법입니다.\n직접 다운로드하여 설치한 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. rm -rf themes/old-theme 또는 파일 탐색기에서 직접 themes/old-theme 폴더를 삭제해도 됩니다.\nGit Submodule로 Blowfish 테마 설치 # 이제 Blowfish 테마를 내 프로젝트에 추가할 차례입니다. 프로젝트의 최상위 폴더(루트)에서 아래 명령어를 순서대로 실행합니다.\ncd my-blog git init git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 테마 설정 파일 구성하기 # Blowfish는 매우 상세한 설정 옵션을 제공합니다. 가장 쉽고 확실한 방법은 테마가 제공하는 기본 설정 파일들을 내 프로젝트로 복사한 뒤, 필요한 부분만 수정하는 것입니다.\n최상위 폴더(루트)에서의 hugo.toml는 더이상 사용하지 않으므로 삭제합니다.\nrm hugo.toml 아래 명령어를 실행하면, 프로젝트 루트에 config 폴더가 생성되고 그 안에 _default 폴더와 함께 hugo.toml, params.toml 등의 기본 설정 파일들이 복사됩니다.\ncp -r themes/blowfish/config . 이제 복사된 설정 파일을 Hugo가 인식하도록 config/_default/hugo.toml 파일을 열어, 파일 최상단에 아래 내용을 수정합니다.\n# config/_default/hugo.toml theme = \u0026#34;blowfish\u0026#34; # baseURL을 자신의 환경에 맞게 수정합니다. baseURL = \u0026#34;https://your_domain.com/\u0026#34; 로컬 확인 및 최종 배포 # 모든 준비가 끝났습니다. 로컬 서버를 실행하여 Blowfish 테마가 적용되었는지 최종 확인합니다.\n# -D 옵션은 draft(초안) 상태의 글도 함께 보여줍니다. hugo server -D 브라우저에서 http://localhost:1313 으로 접속하여 새로운 블로그의 모습을 확인하세요. 메인 페이지, 글 목록, 검색 기능이 모두 잘 작동한다면 성공입니다.\n마지막으로, 변경된 내용을 서버에 배포합니다.\n# 모든 변경사항 추가 git add . # 테마 변경을 알리는 커밋 메시지 작성 git commit -m \u0026#34;Feat: Apply Blowfish theme\u0026#34; # 원격 저장소에 푸시하여 배포 완료 git push 마무리하며 # 지금까지 기존 Hugo 블로그에 Blowfish 테마를 적용하고 기본적인 설정을 마치는 전 과정을 함께했습니다. Blowfish는 params.toml 파일에 수많은 커스터마이징 옵션을 제공하므로, 시간을 갖고 천천히 살펴보시면 라이트/다크 모드, 폰트, 아이콘 등 블로그의 거의 모든 요소를 원하는 대로 바꿀 수 있습니다.\n이 가이드를 시작으로 여러분만의 개성이 가득한 멋진 블로그를 완성하시길 바랍니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-blowfish/","section":"","summary":"","title":"Hugo 블로그에 Blowfish 테마 적용하기","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":" # 안드로이드 앱 개발 시 메모리 누수는 앱의 성능을 저하시키고, 심할 경우 ANR(Application Not Responding)이나 OOM(Out of Memory) 오류를 발생시키는 주범입니다. 이번 글에서는 강력한 메모리 분석 도구인 Memory Analyzer(MAT) 를 사용하여 안드로이드 앱의 Java Heap Dump 파일을 분석하고 메모리 누수를 찾아내는 과정을 상세히 안내하겠습니다.\nHeap Dump 파일 생성하기 # 가장 먼저 분석할 메모리 스냅샷, 즉 Heap Dump 파일이 필요합니다. 안드로이드 스튜디오에서 간단하게 생성할 수 있습니다.\nAndroid Studio Profiler 실행:\n앱을 디버그 모드로 실행합니다. 하단의 Profiler 탭을 엽니다. Memory 프로파일러를 선택합니다. Heap Dump 생성:\n메모리 사용량을 모니터링하다가 분석하고 싶은 시점에 \u0026lsquo;Dump Java heap\u0026rsquo; 버튼 (아래 이미지의 아이콘)을 클릭합니다. 덤프가 완료되면 Android Studio가 자동으로 .hprof 파일을 생성하고 목록에 표시해 줍니다. 이제 분석의 재료가 되는 .hprof 파일이 준비되었습니다.\nhprof 파일 변환하기 (가장 중요!) # 안드로이드 스튜디오에서 생성된 .hprof 파일은 안드로이드 환경에 최적화된 형식입니다. 이 파일을 MAT에서 바로 열면 오류가 발생합니다. 따라서 MAT가 인식할 수 있는 표준 Java hprof 형식으로 변환해야 합니다.\n이때 hprof-conv라는 변환 도구를 사용합니다.\nhprof-conv 위치:\nAndroid SDK 설치 경로 내의 platform-tools 폴더에 있습니다. 예: C:\\Users\\[사용자명]\\AppData\\Local\\Android\\Sdk\\platform-tools 변환 명령어: 터미널이나 명령 프롬프트를 열고 아래 명령어를 실행합니다.\nhprof-conv [입력 파일 경로] [출력 파일 경로] 실행 예시: 원본 파일을 옮겼다고 가정해 보겠습니다.\ncd C:\\Users\\[사용자명]\\AppData\\Local\\Android\\Sdk\\platform-tools ./hprof-conv.exe C:\\Users\\[사용자명]\\Desktop\\original.hprof C:\\Users\\[사용자명]\\Desktop\\converted.hprof 이제 converted.hprof 라는 새로운 파일이 생성되었습니다. 이 파일을 MAT에서 사용하게 됩니다. 이 변환 과정을 잊으면 분석을 시작할 수 없으니 꼭 기억하시기 바랍니다.\nMemory Analyzer (MAT) 설치 및 실행 # MAT는 이클립스 재단에서 제공하는 무료 오픈소스 도구입니다.\n설치:\nEclipse MAT 공식 다운로드 페이지 에 접속하여 본인의 운영체제에 맞는 버전을 다운로드합니다. 압축을 풀기만 하면 바로 실행할 수 있는 독립 실행형(Standalone) 버전입니다. 실행:\n압축 해제한 폴더에서 MemoryAnalyzer 또는 mat 실행 파일을 실행합니다. MAT 실행을 위해서는 Java Runtime(JRE)이 설치되어 있어야 합니다. MAT으로 Heap Dump 파일 분석하기 # 이제 모든 준비가 끝났습니다. 변환된 Heap Dump 파일을 MAT으로 분석해 보겠습니다.\n파일 열기 # MAT를 실행하고 File \u0026gt; Open Heap Dump... 메뉴를 통해 아까 변환했던 converted.hprof 파일을 엽니다. 파일 크기에 따라 로딩 시간이 다소 걸릴 수 있습니다. Leak Suspects Report (누수 의심 보고서) # 파일을 열면 가장 먼저 아래와 같은 팝업창이 나타납니다. **\u0026lsquo;Leak Suspects Report\u0026rsquo;**를 선택하고 Finish를 누르는 것을 강력히 권장합니다. MAT가 자동으로 메모리 누수가 의심되는 지점을 분석하여 리포트 형태로 보여주기 때문입니다. 리포트가 생성되면 파이 차트와 함께 메모리 누수의 원인으로 의심되는 객체(Problem Suspect)가 표시됩니다. 보통 이 리포트만 잘 확인해도 문제의 절반은 해결됩니다. 주요 분석 기능 # Leak Suspects 보고서로 문제가 해결되지 않았다면, 더 깊게 분석해야 합니다. MAT의 핵심 기능 두 가지만 기억하면 충분합니다.\nHistogram (히스토그램)\n기능: 메모리에 로드된 모든 객체를 클래스별로 목록화하여 보여줍니다. 각 클래스의 인스턴스 수(Objects), 인스턴스 자체가 차지하는 메모리(Shallow Heap), 그리고 해당 인스턴스가 참조하는 다른 모든 객체까지 포함한 메모리(Retained Heap)를 확인할 수 있습니다. 사용법: 상단 툴바에서 히스토그램 아이콘을 클릭합니다. Retained Heap을 기준으로 내림차순 정렬합니다. 가장 위에 있는 항목들이 메모리를 가장 많이 점유하는 객체들입니다. 불필요하게 많은 인스턴스가 존재하거나, 비정상적으로 큰 메모리를 차지하는 클래스가 있는지 확인합니다. Dominator Tree (도미네이터 트리)\n기능: 객체 간의 참조 관계를 트리 구조로 보여주어, 어떤 객체가 다른 객체들의 생명주기를 \u0026lsquo;지배(Dominate)\u0026lsquo;하고 있는지 명확하게 보여줍니다. 즉, 특정 객체 하나를 제거했을 때 연쇄적으로 메모리에서 해제될 수 있는 객체들의 집합을 파악하는 데 가장 유용한 기능입니다. 사용법: 상단 툴바에서 도미네이터 트리 아이콘을 클릭합니다. 마찬가지로 Retained Heap 기준으로 정렬하여 가장 큰 메모리 덩어리를 찾습니다. 트리를 확장하며 어떤 객체(예: Activity, Context)가 예상과 달리 수많은 다른 객체들을 참조하고 있는지 추적합니다. 실용적인 팁: GC Root 경로 추적\n누수가 의심되는 객체를 찾았다면, 왜 이 객체가 가비지 컬렉터(GC)에 의해 수거되지 않는지 알아야 합니다.\nHistogram이나 Dominator Tree에서 의심되는 객체를 마우스 오른쪽 버튼으로 클릭합니다. Path to GC Roots \u0026gt; exclude all phantom/weak/soft etc. references를 선택합니다. 이 객체를 메모리에서 계속 붙잡고 있는 참조 경로(Chain of References)가 나타납니다. 보통 static 필드나 백그라운드 스레드, 혹은 잘못 관리된 리스너 등이 원인인 경우가 많습니다. 이 경로를 따라가면 누수의 근본 원인을 찾을 수 있습니다. 마무리하며 # 메모리 누수는 잡기 어려운 버그일 수 있지만, MAT과 같은 강력한 도구를 활용하면 체계적으로 접근하여 해결할 수 있습니다.\n핵심 요약:\nHeap Dump 생성: 안드로이드 스튜디오 프로파일러 사용 hprof 변환: hprof-conv 도구로 표준 형식으로 변환 (필수!) MAT 분석: Leak Suspects로 자동 분석 후, Dominator Tree와 Histogram으로 상세 분석 이 가이드가 안드로이드 앱의 성능과 안정성을 높이는 데 실질적인 도움이 되기를 바랍니다. 꾸준한 메모리 관리는 고품질 앱의 기본입니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/develop/android/debug-analyze-java-heap-dump-using-mat/","section":"","summary":"","title":"Memory Analyzer(MAT)으로 Android 앱의 Java Heap Dump 완벽 분석 가이드","type":"posts"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/termux/","section":"Tags","summary":"","title":"Termux","type":"tags"},{"content":"","date":"27 June 2025","externalUrl":null,"permalink":"/tags/vscode/","section":"Tags","summary":"","title":"Vscode","type":"tags"},{"content":"\u0026ldquo;카페에서 태블릿으로 코딩을 할 수 있다면?\u0026rdquo;, \u0026ldquo;여행 중에 급하게 스마트폰으로 코드를 수정해야 한다면?\u0026rdquo; 이런 상상, 한 번쯤 해보셨을 겁니다. 오늘은 그 상상을 현실로 만드는 방법을 소개해 드리고자 합니다.\n바로 안드로이드의 강력한 리눅스 환경인 Termux와 웹 기반 VS Code인 code-server를 조합하여, 언제 어디서든 웹 브라우저만 있으면 접속할 수 있는 나만의 개발 서버를 구축하는 방법입니다.\n이 글은 독자 여러분께서 Termux를 이미 설치하고 기본적인 pkg update \u0026amp;\u0026amp; pkg upgrade 명령어를 통해 시스템을 최신 상태로 유지하고 있다는 가정하에 진행됩니다.\nTermux 설치 부터 필요하신 분은\n글을 참고해 주세요\n필수 패키지 설치 # code-server 설치 및 원활한 사용을 위해 필요한 기본적인 도구들을 먼저 설치합니다. Termux를 실행하고 아래 명령어를 입력해 주세요.\npkg upgrade pkg install proot-distro -y proot: Termux의 가상 파일 시스템 환경에 도움을 주는 유틸리티입니다. code-server 설치하기 # 이제 본격적으로 code-server를 설치할 차례입니다.\nubuntu 설치하기 # Termux 에서 code-server 직접 실행할 수 없기 때문에, ubuntu 가상 환경을 먼저 구성하겠습니다.\nproot-distro install ubuntu 이제 ubuntu 가상 환경에 로그인 합니다.\nproot-distro login ubuntu 아래와 같이 root@ubuntu 로 ubuntu에 로그인 되었음을 확인할 수 있습니다. code-server 설치하기 # 안드로이드 기기는 대부분 ARM 기반의 aarch64 아키텍처를 사용하는데, 복잡한 설치 과정을 자동화해주는 공식 설치 스크립트가 있어 매우 편리합니다.\n아래 명령어를 Termux에 그대로 입력하고 실행하세요.\napt update apt upgrade apt install wget curl curl -fsSL https://code-server.dev/install.sh | sh 이 스크립트는 현재 사용 중인 기기의 운영체제와 아키텍처를 자동으로 감지하여, 그에 맞는 최신 버전의 code-server를 다운로드하고 실행 가능한 상태로 설치해 줍니다.\n![[install-code-server-on-ubuntu.webp]]\ncode-server 실행 및 접속 # 설치가 완료되었다면, 이제 서버를 실행하고 접속해 보겠습니다.\n최초 실행 및 비밀번호 확인 # 아래 명령어로 code-server를 실행합니다.\ncode-server 서버가 시작되면 터미널에 몇 가지 정보가 나타납니다. 여기서 우리가 주목해야 할 것은 두 가지입니다.\n접속 주소: HTTP server listening on http://127.0.0.1:8080 (내부 접속 주소) 비밀번호 위치: Password is in ~/.config/code-server/config.yaml 이제 아래 명령어로 설정 파일의 내용을 확인하여 자동으로 생성된 비밀번호를 확인합니다.\ncat ~/.config/code-server/config.yaml 출력된 내용 중 password: 항목에 있는 긴 문자열이 여러분의 초기 비밀번호입니다.\nbind-addr: 127.0.0.1:8080 auth: password password: \u0026lt;\u0026lt;password\u0026gt;\u0026gt; #need to be changed cert: false 보안 팁: password: 항목을 원하는 비밀번호로 수정하고 서버를 재시작하세요.\n웹 브라우저로 접속 # 안드로이드 기기에서 Chrome과 같은 웹 브라우저를 열고, 주소창에 http://127.0.0.1:8080 또는 localhost:8080 을 입력하세요.\n![[vs-code-login.webp]]\nVS Code 로그인 화면이 나타나면, 방금 확인한 비밀번호를 입력합니다.\n![[vs-code-run.webp]]\n성공입니다! 이제 여러분의 안드로이드 기기 안에서 완벽하게 동작하는 VS Code가 생겼습니다.\n외부 기기에서 접속하기 # 이 설정의 진정한 묘미는 PC나 노트북 등 다른 기기에서 접속하여 코딩하는 것입니다.\n서버 실행 옵션 변경: code-server를 종료(Ctrl + C)하고, 외부 접속을 허용하는 옵션을 추가하여 다시 실행합니다.\ncode-server --bind-addr 0.0.0.0:8080 0.0.0.0은 모든 네트워크 인터페이스로부터의 접속을 허용하겠다는 의미입니다.\n안드로이드 기기 IP 주소 확인: Termux에 ifconfig 또는 ip addr 명령어를 입력하거나, 안드로이드의 \u0026lsquo;설정 \u0026gt; Wi-Fi\u0026rsquo; 메뉴에서 현재 연결된 Wi-Fi의 상세 정보로 들어가 IP 주소를 확인합니다. (예: 192.168.1.10)\n외부 기기에서 접속: 이제 노트북이나 PC의 웹 브라우저 주소창에 http://\u0026lt;여러분의-안드로이드-IP\u0026gt;:8080 (예: http://192.168.1.10:8080)을 입력하여 접속합니다. 동일하게 비밀번호를 입력하면 바로 코딩을 시작할 수 있습니다.\n보안 팁: 외부 접속을 허용할 경우, 추측하기 어려운 비밀번호로 변경하는 것이 좋습니다. ~/.config/code-server/config.yaml 파일을 직접 열어 password: 항목을 원하는 비밀번호로 수정하고 서버를 재시작하세요.\n마무리 및 활용 팁 # 이제 여러분의 안드로이드 기기는 저전력으로 24시간 구동 가능한 개인 개발 서버가 되었습니다.\n백그라운드 실행 유지: termux-wake-lock 명령어를 실행해두면 화면이 꺼져도 Termux 세션이 종료되는 것을 방지할 수 있습니다.\nVS Code 확장 프로그램: 일반 VS Code와 마찬가지로 확장 프로그램(Extensions) 탭에서 원하는 플러그인을 검색하고 설치하여 사용할 수 있습니다.\n파일 접근: termux-setup-storage 명령어로 저장 공간 접근 권한을 허용한 뒤, ~/storage 폴더를 통해 스마트폰의 내부 저장소에 접근하여 파일을 수정할 수 있습니다.\n이 강력한 휴대용 개발 환경을 통해 여러분의 생산성을 한 단계 끌어올려 보시길 바랍니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/termux/termux-with-code-server/","section":"","summary":"","title":"안드로이드 폰을 코딩 머신으로! Termux와 code-server로 VS Code 환경 구축하기","type":"posts"},{"content":" # Obsidian(옵시디언)으로 노트를 작성하다 보면 이미지를 첨부할 일이 많습니다. 그런데 이미지를 붙여넣을 때마다 파일이 보관소(Vault) 최상위 폴더에 저장되어 파일 관리가 번거로워지는 경험, 다들 한 번쯤 있으실 겁니다. 노트 파일과 이미지 파일이 따로 놀면 나중에 파일을 찾거나 관리하기가 매우 까다롭습니다.\n오늘은 이 문제를 해결하기 위해 이미지를 현재 작성 중인 노트와 동일한 위치에 저장하는 방법을 알아보겠습니다. 설정 하나만 변경하면 되니, 차근차근 따라오시면 됩니다.\n왜 이미지 저장 위치를 변경해야 할까? # Obsidian은 기본적으로 이미지를 보관소(Vault)의 루트 폴더에 저장합니다. 노트('*.md') 파일은 특정 폴더 안에 있는데, 이미지는 밖에 있으니 연관성이 떨어져 보입니다.\n이렇게 되면 다음과 같은 문제점이 발생할 수 있습니다.\n파일 관리의 어려움: 어떤 이미지가 어떤 노트에 속하는지 파악하기 어렵습니다. 링크 깨짐 현상: 나중에 노트 파일을 다른 폴더로 옮길 때 이미지 링크가 깨질 가능성이 높아집니다. 구조의 복잡성: 파일 탐색기(File Explorer) 뷰가 지저분해져 노트 전체의 구조를 파악하기 힘들어집니다. 따라서 노트와 관련 이미지를 같은 폴더에 묶어두는 것은 효율적인 노트 관리를 위한 필수적인 과정입니다.\n이미지 저장 위치 변경 방법 (3단계) # Obsidian 설정에서 \u0026lsquo;첨부 파일(Attachment)\u0026rsquo; 관련 옵션을 변경하면 간단하게 해결할 수 있습니다.\n1. 설정(Settings) 메뉴 열기\nObsidian 좌측 하단에 있는 톱니바퀴 모양의 \u0026rsquo;⛭(설정)\u0026rsquo; 아이콘을 클릭합니다.\n2. \u0026lsquo;파일 및 링크(Files \u0026amp; Links)\u0026rsquo; 탭 이동\n설정 창이 열리면 왼쪽 메뉴에서 \u0026lsquo;파일 및 링크\u0026rsquo; 탭을 선택합니다. 파일 생성 및 링크 처리와 관련된 다양한 옵션을 이곳에서 관리할 수 있습니다.\n3. \u0026lsquo;새 첨부 파일을 만들 위치\u0026rsquo; 설정 변경\n\u0026lsquo;파일 및 링크\u0026rsquo; 설정 항목 중에서 \u0026lsquo;새 첨부 파일을 만들 위치(Default location for new attachments)\u0026rsquo; 라는 옵션을 찾습니다.\n이 옵션의 드롭다운 메뉴를 클릭하면 여러 선택지가 나타납니다. 여기서 \u0026lsquo;현재 파일과 같은 폴더(Same folder as current file)\u0026rsquo; 를 선택합니다.\n설정은 자동으로 저장됩니다. 이제 설정 창을 닫고 노트에 이미지를 붙여넣어 보세요.\nCtrl + V (Windows/Linux) 또는 Cmd + V (macOS)를 사용해 클립보드의 이미지를 붙여넣거나, 이미지를 노트 편집창으로 드래그 앤 드롭하면 해당 노트 파일이 있는 폴더에 이미지 파일('*.png' 또는 '*.jpg')이 함께 생성되는 것을 확인할 수 있습니다.\n추가 팁: 하위 폴더에 정리하기 # 만약 노트와 동일한 위치이지만, 이미지 파일들을 별도의 하위 폴더에 정리하고 싶다면 다음과 같이 설정할 수 있습니다.\n\u0026lsquo;새 첨부 파일을 만들 위치\u0026rsquo; 옵션에서 \u0026lsquo;현재 폴더 아래의 하위 폴더에(In subfolder under current folder)\u0026rsquo; 를 선택합니다. 바로 아래에 나타나는 \u0026lsquo;하위 폴더 이름(Subfolder name)\u0026rsquo; 입력란에 원하는 폴더 이름(예: images, assets)을 입력합니다. 이렇게 설정하면 이미지를 붙여넣을 때마다 현재 노트가 위치한 폴더 안에 지정한 이름의 하위 폴더가 자동으로 생성되고, 그 안에 이미지 파일이 저장됩니다. 이는 노트 하나에 많은 이미지가 첨부될 때 파일을 깔끔하게 관리하는 데 매우 유용합니다.\n마치며 # 오늘은 Obsidian에서 이미지 파일을 현재 노트와 동일한 위치에 저장하는 방법을 알아보았습니다. 아주 간단한 설정 변경만으로도 노트 관리의 효율성을 크게 높일 수 있습니다.\nIT 개발자에게 있어 체계적인 문서와 파일 관리는 필수적인 역량입니다. Obsidian을 사용하시는 모든 분이 오늘 알려드린 방법을 통해 조금 더 구조화된 방식으로 노트를 관리하고, 지식 자산을 효과적으로 쌓아나가시길 바랍니다.\n궁금한 점이 있다면 언제든지 댓글로 남겨주세요.\n참조:\nObsidian 공식 도움말 - Attachments: https://help.obsidian.md/Files+and+links/Attachments ","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/saving-contents-to-specific-folder/","section":"","summary":"","title":"Obsidian 이미지, 글과 함께 저장하는 가장 간단한 방법","type":"posts"},{"content":"오늘은 제가 유용하게 사용하고 있는 노트 앱, Obsidian에서 이미지 파일을 효율적으로 관리하는 방법을 공유하고자 합니다. 바로 이미지를 WebP 포맷으로 변환하여 사용하는 것입니다.\nObsidian에 이미지를 많이 첨부하다 보면 보관소(Vault)의 용량이 커지고, 동기화나 백업 시 부담이 될 수 있습니다. 특히 고화질의 스크린샷이나 PNG 파일을 그대로 사용하면 파일 하나당 수 메가바이트(MB)에 달하기도 합니다.\n이 문제를 해결하기 위해 저는 이미지 파일을 WebP 포맷으로 변환하는 방법을 사용하고 있으며, 이를 자동화해주는 Obsidian 커뮤니티 플러그인을 중심으로 실질적인 노하우를 알려드리겠습니다.\n왜 WebP를 사용해야 할까요? # WebP는 구글(Google)이 웹 환경의 이미지 최적화를 위해 개발한 이미지 포맷입니다. 기존에 널리 사용되던 JPG나 PNG에 비해 여러 장점을 가집니다.\n더 작은 파일 크기: WebP는 손실/비손실 압축 기술을 모두 지원하며, 동일한 이미지 품질을 유지하면서도 파일 크기를 현저히 줄일 수 있습니다. 일반적으로 JPG보다 약 25~35%, PNG보다는 약 26% 더 작습니다. 품질 유지: 파일 크기를 줄이면서도 시각적으로 인지하기 어려운 수준의 품질 저하만 발생시켜 원본과 거의 유사한 퀄리티를 보장합니다. 다양한 기능 지원: PNG처럼 투명한 배경(알파 채널)을 지원하고, GIF와 같이 움직이는 이미지(애니메이션)도 지원합니다. Obsidian에 적용하면 노트 용량을 획기적으로 줄여 보관소 관리를 용이하게 하고, 동기화 속도 향상 및 저장 공간 확보라는 실질적인 이점을 얻을 수 있습니다.\nObsidian에서 WebP 변환을 자동화하는 방법: \u0026lsquo;Image Converter\u0026rsquo; 플러그인 # Obsidian에서는 커뮤니티 플러그인을 활용하여 이미지 변환 과정을 매우 간단하게 처리할 수 있습니다. 여러 플러그인이 있지만, 가장 기능이 강력하고 설정이 편리한 \u0026lsquo;Image Converter\u0026rsquo; 플러그인을 추천합니다.\nImage Converter 플러그인 설치 # Obsidian 설정(Settings) 메뉴를 엽니다. (단축키: Ctrl/Cmd + ,) 왼쪽 탭에서 Community plugins를 선택합니다. Browse 버튼을 클릭하여 커뮤니티 플러그인 목록을 엽니다. 검색창에 Image Converter를 입력하여 해당 플러그인을 찾고 Install 버튼을 눌러 설치합니다. 설치가 완료되면 Enable 버튼을 눌러 플러그인을 활성화합니다. Image Converter 플러그인 설정 # 플러그인을 활성화했다면, 이제 자신의 작업 스타일에 맞게 설정을 변경할 차례입니다. 설정(Settings) \u0026gt; Community Plugins 탭 아래에 Image Converter 메뉴가 추가된 것을 확인할 수 있습니다.\n저장 폴더, 이미지 리사이징, 정렬 등 다양한 부가 기능이 있으니 필요에 따라 설정을 조정하시면 됩니다.\n사용 예시 및 실질적인 팁 # 설정을 마쳤다면 이제 실제로 사용해볼 차례입니다.\n웹 페이지의 이미지나 스크린샷 캡처 도구로 이미지를 복사합니다. Obsidian 노트 편집기에 그대로 붙여넣기(Ctrl/Cmd + V) 합니다. \u0026lsquo;Image Converter\u0026rsquo; 플러그인이 작동하면서 자동으로 이미지가 WebP 포맷으로 변환되고, 설정한 경로와 파일명 규칙에 따라 저장됩니다. 위 이미지에서 볼 수 있듯, 간단한 붙여넣기 동작만으로 PNG 파일이 훨씬 가벼운 WebP 파일로 변환되어 저장된 것을 확인할 수 있습니다.\n팁: 기존에 Markdown으로 작성된 다른 문서들을 Obsidian으로 가져올 때도 매우 유용합니다. 이미지 파일들을 Obsidian 보관소의 특정 폴더(예: \u0026lsquo;images\u0026rsquo; 폴더)에 옮겨두고, 노트에서 해당 이미지를 참조하도록 링크만 수정하면 됩니다. 이 과정에서 \u0026lsquo;Image Converter\u0026rsquo; 플러그인이 자동으로 WebP로 변환해주지는 않지만, 외부 변환 도구를 사용하여 일괄 변환 후 옮겨두면 보관소 용량을 크게 절약할 수 있습니다.\n마무리하며 # Obsidian은 단순한 노트 앱을 넘어, 지식과 정보를 체계적으로 관리하는 강력한 도구입니다. 여기에 \u0026lsquo;Image Converter\u0026rsquo;와 같은 플러그인을 활용하여 이미지 파일을 WebP로 자동 변환하는 워크플로우를 구축하면, 장기적으로 보관소의 용량을 효율적으로 관리하고 쾌적한 사용 환경을 유지할 수 있습니다.\n개발자로서 다양한 도구를 사용해봤지만, Obsidian만큼 확장성과 자율성을 보장하는 툴은 드뭅니다. 오늘 소개해드린 방법이 여러분의 Obsidian 라이프를 한 단계 더 발전시키는 데 도움이 되기를 바랍니다.\n참조:\nImage Converter Plugin - Obsidian.md WebP - Google Developers ","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/obsidian/converting-image-to-webp/","section":"","summary":"","title":"Obsidian 이미지, WebP로 가볍게 관리하는 실용적인 방법","type":"posts"},{"content":"Git을 처음 설치했거나 새로운 환경에서 작업을 시작할 때, 가장 먼저 해야 할 일은 사용자 정보를 설정하는 것입니다. Git은 커밋(Commit)을 할 때마다 이 정보를 사용하여 누가 변경사항을 만들었는지 기록합니다. 이 가이드에서는 Git 사용자 이름과 이메일 주소를 설정하는 방법, 그리고 추가적인 유용한 설정들을 다룹니다.\n사용자 이름과 이메일 설정 # Git에서 커밋 기록에 사용될 이름과 이메일 주소를 설정하는 것은 필수적입니다. --global 옵션을 사용하면 현재 컴퓨터의 모든 Git 저장소에 동일한 설정을 적용할 수 있습니다.\n터미널 또는 Git Bash를 열고 다음 명령어를 입력하세요.\n이름 설정:\ngit config --global user.name \u0026#34;사용자 이름\u0026#34; 예시:\ngit config --global user.name \u0026#34;홍길동\u0026#34; 이메일 주소 설정:\ngit config --global user.email \u0026#34;이메일@주소.com\u0026#34; 예시:\ngit config --global user.email \u0026#34;honggildong@example.com\u0026#34; GitHub 또는 다른 Git 호스팅 서비스에서 사용하는 이메일 주소를 등록하는 것이 일반적입니다.\n설정 확인하기 # 설정이 올바르게 되었는지 확인하려면 다음 명령어를 사용합니다.\n전체 설정 목록 확인:\ngit config --list 특정 설정 확인:\ngit config user.name git config user.email 명령어를 실행했을 때 이전에 입력한 사용자 이름과 이메일 주소가 출력된다면 성공적으로 설정된 것입니다.\nGit 설정의 세 가지 수준 # Git은 세 가지 다른 수준의 설정 파일을 사용합니다. 각 설정은 서로 다른 범위에 적용되며, 충돌 시에는 더 좁은 범위의 설정이 우선적으로 적용됩니다.\nLocal (--local): # 특정 저장소에만 적용되는 설정입니다. 저장소 내의 .git/config 파일에 저장됩니다. --global이나 --system 옵션 없이 git config 명령어를 사용하면 기본적으로 이 수준에 적용됩니다.\n적용 방법: git config user.name \u0026quot;프로젝트용 이름\u0026quot; 우선순위: 1순위 (가장 높음) Global (--global): # 현재 컴퓨터 사용자에게 적용되는 설정입니다. 사용자의 홈 디렉터리(~/.gitconfig)에 저장됩니다. 시스템의 모든 저장소에 공통으로 적용하고 싶을 때 사용합니다.\n적용 방법: git config --global user.name \u0026quot;내 기본 이름\u0026quot; 우선순위: 2순위 System (--system): # 시스템의 모든 사용자와 모든 저장소에 적용되는 설정입니다. Git 설치 경로의 etc/gitconfig 파일에 저장되며, 시스템 관리자 권한이 필요할 수 있습니다. 거의 사용할 일이 없습니다.\n적용 방법: git config --system user.name \u0026quot;시스템 공용 이름\u0026quot; 우선순위: 3순위 (가장 낮음) 예를 들어, --global로 \u0026ldquo;홍길동\u0026quot;을 설정하고 특정 프로젝트 폴더 안에서 --local로 \u0026ldquo;프로젝트A-홍길동\u0026quot;을 설정하면, 해당 프로젝트에서는 \u0026ldquo;프로젝트A-홍길동\u0026quot;이라는 이름으로 커밋이 기록됩니다.\n기본 편집기 설정 # Git이 커밋 메시지 등을 입력받기 위해 실행하는 기본 텍스트 편집기를 설정할 수 있습니다. 기본 편집기는 보통 Vim 또는 Nano로 설정되어 있어 익숙하지 않은 사용자에게는 불편할 수 있습니다. Visual Studio Code, Sublime Text 등 선호하는 편집기로 변경할 수 있습니다.\nVisual Studio Code로 설정:\ngit config --global core.editor \u0026#34;code --wait\u0026#34; Sublime Text로 설정:\ngit config --global core.editor \u0026#34;subl -n -w\u0026#34; Vim으로 설정 (기본값으로 되돌리고 싶을 경우):\ngit config --global core.editor \u0026#34;vim\u0026#34; 이제 git commit과 같이 편집기가 필요한 명령어를 실행하면 설정한 편집기가 열립니다.\n이 가이드를 통해 Git 사용을 위한 기본적인 사용자 설정을 마칠 수 있습니다. 올바른 사용자 정보 설정은 협업과 프로젝트 관리의 첫걸음입니다.\n","date":"27 June 2025","externalUrl":null,"permalink":"/posts/apps/git/user-setting/","section":"","summary":"","title":"Git 사용자 설정하기","type":"posts"},{"content":"수많은 HUGO 테마 중에서도 압도적인 인기를 자랑하는 테마가 있습니다. 바로 PaperMod 입니다. 빠른 속도, 미니멀한 디자인, 강력한 기능(SEO, 다크 모드, 검색 등)을 모두 갖추고 있어 전 세계 수많은 블로거와 개발자들의 사랑을 받고 있습니다.\n오늘은 기존에 운영하던 Hugo 블로그에 바로 이 PaperMod 테마를 적용하는 방법을, 처음부터 끝까지 상세하게 안내해 드리겠습니다.\n기존 테마 깔끔하게 제거하기 # 새로운 옷을 입기 전, 기존 옷을 먼저 정리해야겠죠. 현재 사용 중인 테마를 깔끔하게 제거하는 것부터 시작하겠습니다. 테마 설치 방식에 따라 아래 방법 중 하나를 선택하세요.\nGit 서브모듈로 설치된 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. git submodule deinit -f themes/old-theme git rm -f themes/old-theme rm -rf .git/modules/themes/old-theme 이 명령어들은 단순히 폴더를 지우는 것을 넘어, Git의 추적 기록까지 완전히 정리해 줍니다.\n직접 다운로드하여 설치한 경우: # # 이전 테마 폴더가 \u0026#39;themes/old-theme\u0026#39; 라고 가정합니다. rm -rf themes/old-theme 또는 파일 탐색기에서 직접 themes/old-theme 폴더를 삭제해도 됩니다.\nPaperMod 테마 설치하기 # 이제 오늘의 주인공, PaperMod 테마를 설치할 차례입니다. 추후 테마 관리를 위해 Git 서브모듈 방식을 사용하는 것이 가장 좋습니다.\nGit 서브모듈로 추가:\n프로젝트의 최상위 폴더에서 아래 명령어를 입력합니다.\ngit submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod themes 폴더 안에 PaperMod라는 이름으로 테마가 설치됩니다.\n팁: PaperMod 테마는 다른 복잡한 테마들과 달리 Hugo Extended 버전이 필요 없습니다. 일반 Hugo 버전으로도 모든 기능을 완벽하게 사용할 수 있어 설치가 더욱 간편합니다.\nhugo.toml 설정하기 # PaperMod의 기능을 활성화하기 위해 블로그의 메인 설정 파일인 config.toml을 수정해야 합니다. 아래는 가장 기본적인 설정 예시입니다. 기존 설정을 참고하여 내용을 수정하거나 추가하세요.\nIni, TOML\nbaseURL = \u0026#34;https://your-blog-url.com/\u0026#34; languageCode = \u0026#34;ko-kr\u0026#34; title = \u0026#34;나의 PaperMod 블로그\u0026#34; theme = \u0026#34;PaperMod\u0026#34; # 테마를 PaperMod로 지정 [params] author = \u0026#34;블로거 이름\u0026#34; description = \u0026#34;PaperMod 테마를 적용한 제 블로그입니다.\u0026#34; defaultTheme = \u0026#34;auto\u0026#34; # \u0026#34;auto\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;dark\u0026#34; 중 선택 ShowReadingTime = true # 글 읽는 시간 표시 ShowShareButtons = true # 공유 버튼 표시 ShowPostNavLinks = true # 이전/다음 글 링크 표시 # 메인 페이지 설정 [params.homeInfoParams] Title = \u0026#34;안녕하세요! 👋\u0026#34; Content = \u0026#34;이곳은 PaperMod 테마로 만든 블로그입니다. 깔끔하고 빠르죠.\u0026#34; # 소셜 아이콘 설정 (예시) [[params.socialIcons]] name = \u0026#34;github\u0026#34; url = \u0026#34;https://github.com/your-github-id\u0026#34; [[params.socialIcons]] name = \u0026#34;linkedin\u0026#34; url = \u0026#34;https://www.linkedin.com/in/your-linkedin-id/\u0026#34; # 메인 메뉴 설정 [menu] [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;글 목록\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 10 [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;검색\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 20 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;태그\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 30 PaperMod는 이 외에도 수많은 설정(파라미터)을 제공합니다. 더 상세한 커스터마이징을 원하시면 공식 문서를 꼭 참고하세요.\n참조: PaperMod 테마 공식 위키 - 설정 가이드 로컬 확인 및 최종 배포 # 모든 준비가 끝났습니다. 로컬 서버를 실행하여 디자인이 의도대로 적용되었는지 최종 확인합니다.\n# -D 옵션은 draft(초안) 상태의 글도 함께 보여줍니다. hugo server -D 브라우저에서 http://localhost:1313 으로 접속하여 새로운 블로그의 모습을 확인하세요. 메인 페이지, 글 목록, 검색 기능이 모두 잘 작동한다면 성공입니다.\n마지막으로, 변경된 내용을 서버에 배포합니다.\n# 모든 변경사항 추가 git add . # 테마 변경을 알리는 커밋 메시지 작성 git commit -m \u0026#34;Feat: Apply PaperMod theme\u0026#34; # 원격 저장소에 푸시하여 배포 완료 git push 마무리하며 # PaperMod 테마는 미니멀리즘과 강력한 기능 사이에서 완벽한 균형을 이룬, 그야말로 \u0026lsquo;정석\u0026rsquo;과도 같은 테마입니다. 직접 적용해보시면 왜 이 테마가 그토록 많은 사랑을 받는지 바로 체감하실 수 있을 겁니다.\n이제 여러분의 블로그는 더 빠르고, 더 읽기 편하고, 더 전문적인 모습으로 방문자들을 맞이할 준비를 마쳤습니다.\n","date":"25 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/change-theme-to-papermod/","section":"","summary":"","title":"HUGO 블로그 최고 인기 테마, PaperMod 적용 완벽 가이드","type":"posts"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"Mac","type":"tags"},{"content":"오늘은 빠르고 간결하기로 소문난 정적 사이트 생성기(Static Site Generator, SSG), Hugo를 사용하여 macOS 환경에서 나만의 블로그를 만드는 방법을 알아보겠습니다. 워드프레스와 같은 동적 사이트와 달리, Hugo는 데이터베이스나 복잡한 서버 로직 없이 순수 HTML, CSS, JS 파일로 웹사이트를 생성합니다. 덕분에 비교할 수 없이 빠른 속도, 강력한 보안, 그리고 무료에 가까운 호스팅 비용이라는 엄청난 장점을 가집니다.\n본격적인 시작에 앞서 준비물 확인하기 # 딱 한 가지만 준비하면 됩니다. 바로 Homebrew입니다. Homebrew는 macOS용 패키지 관리자로, 터미널 명령 한 줄로 각종 소프트웨어를 간단하게 설치할 수 있게 해주는 필수 도구입니다. 터미널을 열고 아래 명령어를 입력해 Homebrew가 설치되어 있는지 확인해 보세요.\nbrew --version 만약 버전 정보가 출력된다면 이미 설치된 것입니다. command not found와 같은 메시지가 나온다면, 아래 명령어를 터미널에 붙여넣어 Homebrew를 설치해 주세요.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; Hugo 설치하기 # Homebrew가 준비되었다면 Hugo 설치는 식은 죽 먹기입니다. 터미널에 다음 명령어를 입력하세요.\nbrew install hugo 설치가 완료되면 Homebrew 때와 마찬가지로 버전 확인 명령어로 제대로 설치되었는지 확인합니다.\nhugo version 버전 정보가 보인다면 성공입니다. 이제 블로그를 만들 모든 준비가 끝났습니다.\n내 블로그 사이트 생성하기 # 이제 Hugo를 이용해 블로그의 뼈대를 만들어 보겠습니다. 원하는 경로로 이동한 후, 다음 명령어를 실행하세요. my-blog 부분은 여러분이 원하는 폴더 이름으로 변경해도 좋습니다.\nhugo new site my-blog 명령을 실행하면 my-blog라는 폴더가 생성되고, 그 안에 Hugo 사이트를 구성하는 기본 폴더와 파일들이 자동으로 만들어집니다.\n생성된 my-blog 폴더로 이동해 볼까요?\ncd my-blog ls -l 명령어로 폴더 구조를 살펴보면 다음과 같은 폴더들이 보일 겁니다.\narchetypes: 새 콘텐츠 파일의 기본 양식을 정의합니다. content: 여러분이 작성할 블로그 글(마크다운 파일)이 저장되는 곳입니다. data: 사이트에서 사용할 수 있는 구조화된 데이터 파일(YAML, JSON, TOML)을 저장합니다. layouts: 웹사이트의 HTML 템플릿 파일이 위치합니다. static: 이미지, CSS, JavaScript 파일 등 정적 자원들을 저장합니다. themes: 블로그의 디자인을 담당하는 테마가 설치되는 폴더입니다. hugo.toml: 사이트의 전반적인 설정을 담당하는 가장 중요한 파일입니다. 블로그 디자인(테마) 입히기 # 뼈대만 있는 블로그는 의미가 없겠죠? 이제 디자인을 입힐 차례입니다. Hugo는 전 세계 개발자들이 만들어 공유하는 수많은 무료 테마를 제공합니다.\nHugo 공식 테마 사이트 에서 마음에 드는 테마를 골라보세요.\n이 가이드에서는 입문용으로 가장 많이 사용되는 Ananke 테마를 기준으로 설명하겠습니다.\n먼저, 방금 만든 내 블로그 폴더를 Git 저장소로 초기화해야 합니다. 테마는 보통 Git Submodule이라는 기능으로 관리하는 것이 가장 편리하기 때문입니다.\ngit init 이제 아래 명령어로 Ananke 테마를 themes 폴더 안에 설치합니다.\ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 테마 설치 후, Hugo에게 우리가 이 테마를 사용할 것이라고 알려줘야 합니다. hugo.toml 파일을 열어 다음 한 줄을 추가해 주세요.\ntheme = \u0026#39;ananke\u0026#39; 첫 번째 글 작성하기 # 드디어 첫 번째 글을 작성할 시간입니다. Hugo는 명령어를 통해 아주 쉽게 새 글의 초안 파일을 만들 수 있습니다.\nhugo new posts/my-first-post.md 이 명령은 content/posts 폴더 안에 my-first-post.md 라는 마크다운 파일을 생성합니다. 파일을 열어보면 상단에 다음과 같은 Front Matter가 자동으로 생성된 것을 볼 수 있습니다.\n+++ title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T16:29:43+09:00 draft: true +++ 여기서 가장 중요한 것은 draft: true 입니다. 이는 이 글이 아직 초안 상태임을 의미합니다. 글을 발행하려면 이 값을 false로 변경해야 합니다.\n이제 Front Matter 아래에 마크다운 문법으로 자유롭게 글을 작성해 보세요.\n+++ date = \u0026#39;2025-06-25T22:46:21+09:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ ## It is first post Hello world! 로컬 서버에서 블로그 확인하기 # 내가 작성한 글이 블로그에 어떻게 보이는지 확인해 볼까요? Hugo는 내 컴퓨터에서 바로 사이트를 확인해 볼 수 있는 강력한 로컬 서버 기능을 내장하고 있습니다.\n터미널에서 아래 명령어를 실행하세요.\nhugo server -D 여기서 -D 옵션은 draft: true 상태인 초안 글까지 모두 포함해서 보여달라는 의미입니다. 개발 중에는 아주 유용한 옵션이니 기억해 두세요.\n서버가 실행되면 터미널에 다음과 같은 메시지가 나타납니다.\nWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1) 이제 웹 브라우저를 열고 주소창에 http://localhost:1313 을 입력해 보세요.\nAnanke 테마가 적용된 여러분의 첫 블로그가 눈앞에 나타났을 겁니다! 방금 작성한 my-first-post를 클릭해서 들어가 보세요. 글의 내용을 수정하고 저장하면, 브라우저가 자동으로 새로고침되며 변경사항이 즉시 반영되는 것을 확인할 수 있습니다.\n마무리 # 축하합니다! 여러분은 이제 Hugo로 만든 자신만의 블로그를 갖게 되었습니다.\n오늘 우리는 macOS 환경에서 Hugo를 설치하고, 새 사이트를 만들고, 테마를 적용하고, 첫 글을 작성하여 로컬 서버에서 확인하는 전 과정을 함께했습니다.\n궁금한 점이 있다면 언제든지 댓글로 질문해 주세요.\n참조\nHugo 공식 사이트: https://gohugo.io/ Hugo 공식 테마: https://themes.gohugo.io/ Homebrew: https://brew.sh/ ","date":"25 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-mac-os/","section":"","summary":"","title":"MacOS에서 Hugo로 나만의 블로그 만들기","type":"posts"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/","section":"Tags","summary":"","title":"블로그","type":"tags"},{"content":"지난번에는 리눅스와 macOS 환경에 Hugo를 설치하는 과정을 다루었습니다. 성공적으로 Hugo를 설치하셨다면 이제 본격적으로 콘텐츠를 채워나갈 차례입니다.\n오늘은 Hugo 사이트에 새로운 글을 추가하는 가장 대표적인 두 가지 방법에 대해 알아보겠습니다. 바로 Hugo의 기본 명령어인 hugo new를 사용하는 방법과, 이미 작성된 마크다운(.md) 파일을 직접 가져와 추가하는 방법입니다.\n각 방법의 장단점과 사용법을 명확히 이해하면 콘텐츠를 훨씬 효율적으로 관리할 수 있습니다.\nhugo new 명령어 사용하기 # hugo new는 Hugo에서 새 콘텐츠를 생성하는 공식적이고 가장 권장되는 방법입니다. 이 명령어를 사용하면 단순한 파일 생성을 넘어, 미리 설정된 양식(Archetype)에 따라 글의 기본 구조를 자동으로 만들어주기 때문입니다.\nFront Matter란? # hugo new를 이해하려면 먼저 Front Matter라는 개념을 알아야 합니다.\nFront Matter는 마크다운 파일의 가장 윗부분에 위치하는 정보 덩어리로, 해당 콘텐츠의 데이터를 담고 있습니다. 예를 들어 글의 제목, 작성일, 초안(draft) 상태, 태그, 카테고리 등이 여기에 해당합니다. Hugo는 이 정보를 바탕으로 사이트를 생성하고 콘텐츠를 분류합니다.\n주로 YAML(---) 또는 TOML(+++) 형식을 사용합니다.\nhugo new 명령어 사용법 # 터미널에서 Hugo 프로젝트 폴더로 이동한 후, 아래 명령어를 실행합니다.\nhugo new [콘텐츠 섹션]/[파일이름].md 예를 들어 posts라는 섹션에 my-first-post라는 제목의 글을 작성하고 싶다면 다음과 같이 입력합니다.\nhugo new posts/my-first-post.md ![[Pasted image 20250625153225.jpg]]\n명령어를 실행하면 content/posts/ 폴더 안에 my-first-post.md 파일이 생성됩니다. 생성된 파일을 열어보면 다음과 같은 내용이 자동으로 채워져 있습니다.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T14:30:00+09:00 draft: true --- (여기에 글의 본문을 작성합니다.) title: 파일 이름을 기반으로 자동으로 생성됩니다. 큰따옴표 안의 내용을 수정하면 됩니다. date: 파일이 생성된 시점의 날짜와 시간이 자동으로 입력됩니다. draft: true로 설정되어 있습니다. 이는 해당 글이 아직 초안 상태이며, 최종 빌드 시 사이트에 포함되지 않음을 의미합니다. 글 작성을 마친 후 이 값을 false로 변경하거나 줄을 삭제하면 정식으로 발행됩니다. 팁: hugo server -D 명령어로 서버를 실행하면 draft: true 상태인 초안 글도 미리보기 화면에서 확인할 수 있습니다.\n외부 마크다운 파일 직접 가져오기 # 이미 다른 곳(Notion, Obsidian, Typora 등)에서 작성해 둔 마크다운 파일이 있다면 hugo new 명령어를 거치지 않고 직접 파일 시스템에 추가할 수 있습니다.\n이 방법은 매우 간단하지만, 한 가지 필수 작업이 있습니다.\n직접 추가하는 방법 # 가져올 마크다운 파일을 준비합니다. 파일 최상단에 직접 Front Matter를 추가해야 합니다. Hugo가 해당 파일을 인식하고 처리하려면 최소한 title과 date 정보가 필요합니다. Front Matter가 추가된 파일을 원하는 콘텐츠 섹션 폴더(예: content/posts/)로 복사하거나 이동시킵니다. 예를 들어, my-imported-post.md라는 파일을 가져온다고 가정해 보겠습니다.\n파일을 텍스트 편집기로 열어 아래와 같이 Front Matter를 직접 작성해 줍니다.\n--- title: \u0026#34;외부에서 가져온 나의 포스트\u0026#34; date: 2025-06-20T10:00:00+09:00 draft: false tags: [\u0026#34;hugo\u0026#34;, \u0026#34;markdown\u0026#34;] --- 이 글은 외부 마크다운 편집기에서 작성되었습니다. Front Matter만 정확하게 추가해주면 Hugo 사이트에서 문제 없이 인식됩니다. 이렇게 수정한 파일을 content/posts/ 폴더에 넣기만 하면 Hugo가 다음 빌드 시 자동으로 이 파일을 포함하여 사이트를 생성합니다.\n어떤 방법을 사용해야 할까? # 새로운 글을 작성할 때는 hugo new 사용을 권장합니다. 일관된 구조와 필수 정보(특히 draft: true)를 자동으로 생성해주어 실수를 줄여주고 콘텐츠 관리를 체계적으로 만들어주기 때문입니다.\n기존에 작성된 마크다운 파일을 옮겨오거나 다른 플랫폼에서 콘텐츠를 이전할 때는 파일을 직접 추가하는 방법이 효율적입니다. 이때 Front Matter를 정확히 추가하는 것만 잊지 않으면 됩니다.\n두 가지 방법을 모두 알아두고 상황에 맞게 활용하여 즐겁고 효율적인 Hugo 블로깅 라이프를 즐기시길 바랍니다.\n참조\nHugo 공식 문서: hugo new ","date":"24 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/post-create/","section":"","summary":"","title":"HUGO 새 글 작성하기","type":"posts"},{"content":"지난 글에서는 Hugo 설치 방법을 다루었습니다. 이번에는 많은 분이 최종 목표로 삼는, https://\u0026lt;내-GitHub계정\u0026gt;.github.io 주소로 접속되는 나만의 대표 블로그를 구축하는 방법을 상세히 알아보겠습니다.\n이것을 GitHub에서는 사용자 사이트(User Site) 라고 부릅니다. GitHub Pages가 제공하는 가장 기본적이면서도 강력한 기능이죠. 복잡한 과정 없이, 오직 여러분의 GitHub 계정만으로 세상에 단 하나뿐인 블로그 주소를 가질 수 있습니다.\nGitHub 저장소(Repository) 생성하기 # 가장 깔끔하고 권장되는 방법은 소스코드와 실제 웹사이트 결과물을 분리하여 관리하는 것입니다. 이를 위해 GitHub에 두 개의 저장소를 생성합니다.\n소스코드 저장소 (Private 권장) # 역할: 로컬에서 작업하는 Hugo 프로젝트 전체(마크다운 글, 설정 파일, 테마 등)를 관리합니다. 이름: 자유롭게 지정합니다. (예: my-tech-blog) 공개 범위: 소스코드는 굳이 공개할 필요가 없으므로 Private으로 설정하는 것을 권장합니다. 배포용 저장소 (Public 필수) # 역할: Hugo가 빌드하여 생성한 최종 HTML, CSS 파일이 올라가는 공간입니다. 실제 블로그 웹사이트가 됩니다. 이름: 반드시 \u0026lt;GitHub계정명\u0026gt;.github.io 형식이어야 합니다. 이 규칙을 지켜야 GitHub Pages가 정상적으로 동작합니다. 공개 범위: 웹사이트로 외부에 공개되어야 하므로 반드시 Public으로 설정해야 합니다. SSH Deploy Key 설정 # 아래의 명령으로 deploy key를 아래와 같이 생성합니다.\nssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; gh-pages.pub: public key gh-pages: private key 배포용 저장소의 Settings 로 이동 후, Deploy Keys 항목에 public key를 입력후 Allow write access 항목을 체크합니다.\n소스코드 저장소의 Settings 로 이동 후, Secrets에 private key를 ACTIONS_DEPLOY_KEY로 입력합니다. 로컬 Hugo 프로젝트와 GitHub 연동 # 이제 로컬 my-blog 프로젝트 폴더를 방금 만든 소스코드 저장소(my-blog)와 연결합니다.\n로컬 프로젝트 폴더의 터미널에서 다음 명령어를 실행합니다.\n# 1. Git 저장소로 초기화 (이미 실행했다면 생략) git init # 2. 모든 파일 추가 및 첫 커밋 git add . git commit -m \u0026#34;첫 블로그 설정 및 콘텐츠 초기화\u0026#34; git branch -M main # 3. 원격 저장소(소스코드용) 연결 # \u0026lt;GitHub계정명\u0026gt;과 \u0026lt;저장소이름\u0026gt;을 본인의 정보로 변경하세요. git remote add origin https://github.com/\u0026lt;GitHub계정명\u0026gt;/my-tech-blog.git # 4. main 브랜치로 푸시 git push -u origin main Hugo 설정 파일에 URL 업데이트 # 로컬 Hugo 프로젝트의 설정 파일(hugo.toml 또는 config.toml)을 열어 baseURL을 배포용 저장소 주소로 변경해야 합니다. 이 설정은 링크나 리소스 경로가 올바르게 생성되도록 하는 중요한 역할을 합니다.\nhugo.toml 예시\n# baseURL을 실제 서비스될 블로그 주소로 변경합니다. baseURL = \u0026#34;https://\u0026lt;GitHub계정명\u0026gt;.github.io/\u0026#34; languageCode = \u0026#34;ko-kr\u0026#34; title = \u0026#34;나의 개발 블로그\u0026#34; theme = \u0026#34;적용중인_테마이름\u0026#34; # 예: PaperMod GitHub Actions 워크플로우 설정 # 이 단계가 자동화의 심장부입니다. 로컬 소스코드를 push할 때마다 GitHub 서버가 알아서 Hugo 사이트를 빌드하고, \u0026lt;계정명\u0026gt;.github.io 저장소에 결과물을 배포하도록 설정하겠습니다.\n로컬 프로젝트 루트에 .github/workflows 폴더를 만들고, 그 안에 deploy-hugo.yml 같은 이름의 파일을 생성합니다.\n# 폴더 생성 mkdir -p .github/workflows # yml 파일 생성 (macOS/Linux) touch .github/workflows/deploy-hugo.yml deploy-hugo.yml 파일에 아래 내용을 그대로 복사해 붙여넣습니다.\n.github/workflows/deploy-hugo.yml\nname: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: \u0026lt;GitHub계정명\u0026gt;/\u0026lt;GitHub계정명\u0026gt;.github.io publish_branch: master # default: gh-pages publish_dir: ./public external_repository: \u0026lt;GitHub계정명\u0026gt;/\u0026lt;GitHub계정명\u0026gt;.github.io 배포용 저장소 작성한 deploy-hugo.yml 파일을 저장합니다.\n소스코드 Push 및 배포 최종 확인 # 이제 마지막입니다. 로컬에서 변경된 내용(워크플로우 파일 추가 등)을 다시 소스코드 저장소로 push합니다.\ngit add . git commit -m \u0026#34;Add GitHub Actions workflow for auto-deployment\u0026#34; git push push가 완료되면, GitHub의 소스코드 저장소(my-blog)로 이동하여 Actions 탭을 클릭합니다.\nDeploy Hugo site to GitHub Pages 워크플로우가 자동으로 실행되는 것을 볼 수 있습니다. build와 deploy 작업이 순서대로 진행되며, 몇 분 후 모두 녹색 체크 표시로 바뀌면 성공입니다.\n최종 확인:\n이제 웹 브라우저를 열고 https://\u0026lt;GitHub계정명\u0026gt;.github.io 로 접속해 보세요. 로컬에서 hugo server로 보던 것과 동일한 블로그가 온라인에 게시된 것을 확인할 수 있습니다.\nTrouble Shooting # deploy 동작이 정상적을 완료되었지만, 블로그가 정상적으로 표시되지 않을 수 있습니다. 이 경우 배포용 저장소의 배포 위치를 확인해 주세요\nSource: Deploy from a branch Branch: master(main) - /docs 정리하며 # 축하합니다! 이제 여러분은 git push 한 번으로 글을 발행할 수 있는 근사한 자동화 블로그를 소유하게 되었습니다. 여러분의 지식과 경험을 이 새로운 공간에 차곡차곡 쌓아나가시길 바랍니다.\n","date":"23 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/deploy-hugo-on-github-pages-with-actions/","section":"","summary":"","title":"Hugo 블로그, GitHub Actions로 자동 배포하기","type":"posts"},{"content":"코딩과 글쓰기를 좋아하시는 분들이라면, PC 앞에 앉아야만 작업할 수 있다는 점이 때로는 번거롭게 느껴지셨을 겁니다. 만약 스마트폰만으로 언제 어디서든 블로그 글을 작성하고, 빌드하고, 테스트까지 할 수 있다면 어떨까요?\n이 가이드에서는 여러분의 스마트폰을 강력한 개발 환경으로 만들어주는 Termux와, 빠르고 유연한 정적 사이트 생성기 Hugo를 이용해 나만의 블로그를 만드는 방법을 알아봅니다.\n시작하기 전에: Termux 설치 확인 # 본격적인 시작에 앞서, 가장 핵심적인 준비물인 Termux 앱이 스마트폰에 설치되어 있어야 합니다.\n✅ 아직 Termux를 설치하지 않으셨나요?\n괜찮습니다. Termux의 설치부터 기본 설정까지 자세히 다룬 제 이전 글이 있습니다. 아래 링크의 글을 먼저 따라 설치를 완료하신 후, 다시 이 글로 돌아와 다음 단계를 진행해 주세요.\n[➡️ 참조: Android Termux에서 Hugo 블로그 만들기 ]\nTermux가 준비되셨다면, 이제 Hugo 블로그를 만들 준비가 거의 끝났습니다.\nTermux 환경 준비 및 업데이트 # 가장 먼저, 기존에 설치된 Termux의 패키지를 최신 상태로 만들어 개발 환경을 깔끔하게 준비하겠습니다. 오래된 패키지와의 충돌을 방지하는 중요한 과정입니다.\nTermux를 실행하고 아래 명령어를 입력하세요. 패키지 목록을 갱신하고 설치된 패키지를 최신 버전으로 업그레이드합니다.\npkg update \u0026amp;\u0026amp; pkg upgrade 중간에 Do you want to continue? [Y/n] 와 같은 질문이 나오면 Y를 누르고 엔터를 입력하면 됩니다. 이 과정이 오류 없이 완료되었다면, 다음 단계로 넘어갈 준비가 된 것입니다.\nHugo와 Git 설치하기 # 블로그를 만들기 위해 필요한 핵심 도구들을 설치할 차례입니다.\nHugo: Go 언어로 만들어진 매우 빠른 정적 사이트 생성기(Static Site Generator, SSG)입니다. Git: 버전 관리 시스템입니다. Hugo 테마를 다운로드하거나, 나중에 블로그 코드를 GitHub 등에 백업할 때 필수적입니다. 아래 명령어로 두 패키지를 한 번에 설치합니다.\npkg install hugo git 설치가 잘 되었는지 확인해볼까요? 아래 명령어를 각각 입력하여 버전 정보가 나오면 성공입니다.\nhugo version git version Hugo 블로그 사이트 생성 # 이제 본격적으로 블로그의 뼈대를 만들어 보겠습니다.\n새 사이트 생성 hugo new site 명령어 뒤에 원하는 폴더 이름을 지정합니다. 여기서는 my-blog라는 이름으로 만들겠습니다.\nhugo new site my-blog 생성된 폴더로 이동 cd 명령어를 사용해 방금 만든 my-blog 폴더 안으로 들어갑니다.\ncd my-blog 테마 설치 및 적용 # 디자인 테마를 적용하여 블로그에 옷을 입혀야 합니다. 인기 있는 ananke 테마를 예시로 설치해 보겠습니다.\nGit으로 테마 추가 Git의 submodule 기능을 이용해 테마를 추가합니다.\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 설정 파일에 테마 적용 nano hugo.toml 명령어로 설정 파일을 열고, 아래 내용을 참고하여 수정하거나 추가합니다.\nbaseURL = \u0026#39;https://example.org/\u0026#39; languageCode = \u0026#39;ko-kr\u0026#39; title = \u0026#39;나의 첫 Hugo 블로그\u0026#39; theme = \u0026#39;ananke\u0026#39; 수정이 끝났으면 Ctrl + X, Y, Enter 순서로 눌러 저장하고 빠져나옵니다.\n첫 번째 글 작성하기 # hugo new content 명령어로 첫 글의 파일을 생성합니다.\nhugo new content posts/my-first-post.md nano content/posts/my-first-post.md 명령어로 파일을 열고, draft: true를 draft: false로 변경한 후 내용을 작성하세요.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T09:25:37+09:00 draft: false --- ## 안녕하세요! 여기는 제 첫 번째 Hugo 블로그 글입니다. **Termux**와 **Hugo**를 사용해서 만들었죠. - 정말 간편합니다. - 어디서든 작업할 수 있습니다. 로컬 서버 실행 및 확인 # 모든 준비가 끝났습니다. Hugo에 내장된 개발용 웹 서버를 실행하여 결과를 확인해 보겠습니다.\nmy-blog 폴더 안에서 아래 명령어를 실행하세요.\nhugo server 서버가 실행되면 Web Server is available at http://localhost:1313/ 메시지가 나타납니다. 스마트폰의 웹 브라우저를 열고 주소창에 http://localhost:1313을 입력해 보세요.\n여러분이 직접 만든 블로그가 눈앞에 나타날 것입니다.\n다음 단계는? # 축하합니다! 이제 여러분은 스마트폰만으로 Hugo 블로그를 만들고 관리할 수 있는 환경을 완벽하게 갖추었습니다.\n다음 목표는 이 블로그를 GitHub Pages나 Netlify 같은 서비스를 통해 웹에 **배포(Deploy)**하여 전 세계 누구나 접속할 수 있도록 만드는 것입니다. 이 과정은 다음 글에서 자세히 다루도록 하겠습니다.\n이제 여러분의 손안에 강력한 블로깅 도구가 생겼습니다. 언제 어디서든 떠오르는 영감을 놓치지 말고 기록하고, 여러분의 지식과 경험을 세상과 공유해 보세요.\n","date":"22 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-android-termux/","section":"","summary":"","title":"Android Termux에서 Hugo 블로그 만들기","type":"posts"},{"content":"오늘은 개발자들 사이에서 빠르고 강력하기로 정평이 난 정적 사이트 생성기(SSG), Hugo를 사용하여 Ubuntu 환경에서 나만의 블로그를 만드는 전체 과정을 안내해 드리겠습니다.\nWordPress와 같은 동적 CMS에 익숙하신 분들께 \u0026lsquo;정적 사이트\u0026rsquo;라는 개념이 낯설 수 있습니다. 간단히 설명하자면, 사용자가 요청할 때마다 데이터베이스를 거쳐 페이지를 만드는 동적 방식과 달리, 정적 사이트는 미리 완성된 HTML 파일을 서버에 올려두고 그대로 보여주는 방식입니다. 이 덕분에 로딩 속도가 매우 빠르고, 데이터베이스가 없어 보안에도 훨씬 유리합니다.\n이 가이드는 Ubuntu 환경과 터미널 사용에 어느 정도 익숙한 분들을 대상으로 합니다. 차근차근 따라오시면, 누구나 자신만의 빠르고 멋진 블로그를 가질 수 있습니다.\nHugo 설치하기 # 가장 먼저 할 일은 Hugo를 우리 Ubuntu 시스템에 설치하는 것입니다. 여러 방법이 있지만, 패키지 관리자인 snap을 이용하는 것이 가장 간단하고 최신 버전을 유지하기 좋습니다.\nsudo snap install hugo 설치가 완료되면, 버전 확인 명령어로 제대로 설치되었는지 확인합니다.\nhugo version 만약 hugo v0.127.0-... 와 같은 버전 정보가 출력된다면 성공적으로 설치된 것입니다.\n새 블로그 프로젝트 생성 # 이제 Hugo를 이용하여 블로그의 기본 뼈대를 만들 차례입니다. 원하는 경로로 이동한 후, 아래 명령어를 실행하여 my-blog라는 이름의 새 사이트를 생성합니다. (물론 my-blog는 원하는 이름으로 변경 가능합니다.)\nhugo new site my-blog 명령이 실행되면 my-blog라는 디렉토리가 생성되고, 그 안에는 다음과 같은 Hugo의 표준 디렉토리 구조가 만들어집니다.\nmy-blog/ ├── archetypes/ ├── content/ ├── data/ ├── layouts/ ├── public/ ├── static/ ├── themes/ └── hugo.toml 각 디렉토리의 역할은 간단히 다음과 같습니다.\ncontent/: 실제 블로그 글(마크다운 파일)이 저장되는 곳입니다. themes/: 블로그의 디자인을 담당하는 테마가 위치합니다. static/: 이미지, CSS, JavaScript 등 정적 파일들을 넣는 곳입니다. hugo.toml: 블로그의 제목, 언어, 테마 등 전반적인 설정을 담당하는 파일입니다. 테마 선택 및 적용 # 뼈대만 있는 블로그에 디자인 테마를 입혀야 합니다. Hugo는 전 세계 개발자들이 만들어 공유하는 수많은 테마를 자랑합니다.\nHugo 공식 테마 사이트 에서 마음에 드는 테마를 골라보세요.\n이 가이드에서는 \u0026lsquo;Ananke\u0026rsquo;라는 인기 있고 깔끔한 테마를 예시로 사용하겠습니다. my-blog 디렉토리 안에서 다음 명령어를 실행하여 테마를 설치합니다.\ncd my-blog git init # 아직 git 저장소가 아니라면 초기화합니다. git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke git submodule을 사용하는 이유는 테마의 원본 저장소와 연결을 유지하여, 나중에 테마가 업데이트되었을 때 쉽게 반영할 수 있기 때문입니다.\n이제 설치한 테마를 블로그에 적용할 차례입니다. hugo.toml 설정 파일을 열고 맨 아래에 다음 한 줄을 추가합니다.\ntheme = \u0026#39;ananke\u0026#39; 첫 번째 글 작성하기 # 블로그의 핵심은 콘텐츠입니다. Hugo는 마크다운(.md) 형식으로 글을 작성합니다. 터미널에서 아래 명령어로 첫 번째 글을 생성해 보겠습니다.\nhugo new content posts/my-first-post.md 이 명령은 content/posts/ 디렉토리 안에 my-first-post.md 파일을 생성합니다. 이제 텍스트 에디터로 이 파일을 열어보겠습니다.\n--- title: \u0026#34;My First Post\u0026#34; date: 2025-06-25T10:25:51+09:00 draft: true --- 여기에 본문 내용을 작성합니다. **안녕하세요, Hugo!** 파일 상단의 ---로 둘러싸인 부분을 Front Matter라고 부릅니다. 글의 제목, 작성일, 공개 여부 등 메타데이터를 정의하는 중요한 영역입니다.\n가장 중요한 점! draft: true는 이 글이 아직 초고 상태임을 의미합니다. 블로그에 정식으로 발행하려면 이 값을 draft: false로 변경하거나 이 줄을 삭제해야 합니다.\n이제 Front Matter 아래에 자유롭게 마크다운 문법으로 글을 작성하면 됩니다.\n로컬 서버에서 확인하기 # 작성한 글이 블로그에서 어떻게 보일지 궁금하실 겁니다. Hugo는 강력한 내장 웹 서버를 제공하여, 내 컴퓨터에서 실시간으로 변경사항을 확인하며 작업할 수 있습니다.\nmy-blog 디렉토리에서 아래 명령어를 실행하세요.\nhugo server -D 여기서 -D 옵션은 draft: true 상태인 초고 글까지 모두 포함해서 보여달라는 의미입니다. 개발 중에는 아주 유용한 옵션입니다.\n터미널에 다음과 같은 메시지가 나타날 것입니다.\nWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1) 이제 웹 브라우저를 열고 주소창에 http://localhost:1313을 입력해 보세요. 방금 설치한 Ananke 테마가 적용되고, 작성한 첫 번째 글이 목록에 나타나는 것을 확인할 수 있습니다.\n마치며 # 지금까지 Ubuntu 환경에서 Hugo를 설치하고, 블로그를 생성하여 첫 글을 작성하고, 서버에 배포할 파일을 만드는 전체 과정을 알아보았습니다.\nHugo는 처음에는 조금 낯설 수 있지만, 일단 익숙해지면 그 속도와 단순함, 그리고 강력한 기능에 매료될 것입니다. 오늘 만든 기본 블로그를 바탕으로 자신만의 테마를 만들거나, 다양한 설정을 변경하며 개성 있는 블로그로 발전시켜 나가시길 바랍니다.\n궁금한 점이 있다면 언제든 댓글로 질문해 주세요. 여러분의 성공적인 블로그 운영을 응원하겠습니다.\n참조:\nHugo 공식 문서: https://gohugo.io/documentation/ Hugo 테마 사이트: https://themes.gohugo.io/ ","date":"21 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/make-hugo-blog-on-ubuntu/","section":"","summary":"","title":"Ubuntu에서 Hugo로 나만의 블로그 만들기","type":"posts"},{"content":"정적 사이트 생성기(Static Site Generator), 그중에서도 Go 언어로 작성되어 압도적인 빌드 속도를 자랑하는 Hugo에 대한 관심이 뜨겁습니다. 저 또한 Hugo를 활용하여 블로그를 구축하고 운영하면서 다양한 경험과 노하우를 글로 기록해왔습니다.\n그동안 작성했던 Hugo 관련 글들이 여러 곳에 흩어져 있어 정보를 찾아보기 불편하다는 의견이 있었습니다.\n그래서 오늘은 Hugo를 처음 시작하는 입문자부터, 테마를 직접 수정하고 배포 자동화를 고민하는 분들까지 모두를 위해 제가 작성한 모든 Hugo 관련 글을 한 페이지에서 쉽게 찾아볼 수 있도록 정리했습니다.\n이 글 하나만 북마크해두시면, Hugo 블로그 운영에 필요한 모든 정보를 얻어 가실 수 있을 겁니다.\nHugo 시작하기: 설치 및 기본 사이트 생성 # Hugo를 처음 접하는 분들을 위한 시리즈입니다. Hugo 설치부터 기본 사이트 생성 방법, Github Actions를 통해서 배포까지 안내합니다.\nUbuntu에서 Hugo로 나만의 블로그 만들기 21 June 2025\u0026middot;611 words\u0026middot;3 mins MacOS에서 Hugo로 나만의 블로그 만들기 25 June 2025\u0026middot;647 words\u0026middot;4 mins Android Termux에서 Hugo 블로그 만들기 22 June 2025\u0026middot;548 words\u0026middot;3 mins Hugo 프로젝트를 위한 완벽한 .gitignore 설정 가이드 27 June 2025\u0026middot;612 words\u0026middot;3 mins Hugo 블로그, GitHub Actions로 자동 배포하기 23 June 2025\u0026middot;651 words\u0026middot;4 mins Hugo 테마: 커스터마이징과 나만의 기능 추가 # 미리 만들어진 테마를 설치하고, 내 입맛에 맞게 수정하는 방법을 다룹니다. HTML/CSS 기본 지식이 있다면 누구나 따라 할 수 있도록 쉬운 내용부터 고급 기법까지 차근차근 설명합니다.\n테마 설치하기 # HUGO 블로그 최고 인기 테마, PaperMod 적용 완벽 가이드 25 June 2025\u0026middot;523 words\u0026middot;3 mins Hugo 블로그에 Hextra 테마 적용하는 가장 간단한 방법 28 June 2025\u0026middot;285 words\u0026middot;2 mins Hugo 블로그에 Blowfish 테마 적용하기 27 June 2025\u0026middot;391 words\u0026middot;2 mins Blowfish 테마 설정하기 # Blowfish 테마: 기본 저자 정보 설정하기 28 June 2025\u0026middot;244 words\u0026middot;2 mins Blowfish 테마: 사이트 제목과 로고 설정하기 28 June 2025\u0026middot;293 words\u0026middot;2 mins Blowfish 테마: 메뉴 설정 가이드 (Main, Footer, Dropdown) 29 June 2025\u0026middot;532 words\u0026middot;3 mins Blowfish 테마: 파비콘(Favicon) 설정하기 1 July 2025\u0026middot;417 words\u0026middot;2 mins 콘텐츠 작성과 관리: 마크다운과 Frontmatter, Shortcode 활용법 # Hugo에서 콘텐츠를 어떻게 작성하고 관리하는지에 대한 글들입니다. 마크다운 문법을 기본으로, 콘텐츠의 메타 데이터를 관리하는 프론트매터(Frontmatter)와 콘텐츠 구조를 정의하는 아키타입(Archetypes) 활용법을 다룹니다. Frontmatter와 Shortcode 등의 특수한 기능은 특정 테마에서만 지원하는 경우가 많기에 이후에는 blowfish theme 기준으로 설명하겠습니다.\nBlowfish 테마: 콘텐츠 구조화 가이드 29 June 2025\u0026middot;508 words\u0026middot;3 mins HUGO 새 글 작성하기 24 June 2025\u0026middot;483 words\u0026middot;3 mins Blowfish 테마: 섬네일 \u0026 히어로 이미지 설정 방법 29 June 2025\u0026middot;246 words\u0026middot;2 mins 앞으로도 Hugo와 관련된 유용한 팁과 정보가 생기면 이 글에 꾸준히 업데이트할 예정입니다. Hugo를 사용하시면서 궁금한 점이나 막히는 부분이 있다면 언제든지 댓글로 질문 남겨주시기 바랍니다.\n","date":"20 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/hugo-a-to-z/","section":"","summary":"","title":"Hugo 설치부터 배포까지 A to Z","type":"posts"},{"content":"우리가 매일 사용하는 스마트폰은 강력한 AP와 충분한 메모리를 갖춘 훌륭한 개발 및 서버 관리 도구가 될 수 있습니다. 그 중심에는 Termux라는 강력한 터미널 앱이 있습니다. 이번 글에서는 Termux를 \u0026lsquo;올바르게\u0026rsquo; 설치하고 개발에 필요한 기본 환경을 설정하는 방법을 2025년 최신 정보 기준으로 다시 한번 알려드립니다.\nPlay 스토어 vs F-Droid # 많은 분들이 습관적으로 구글 플레이 스토어에서 앱을 검색하고 설치합니다. 하지만 Termux의 경우, 이것이 가장 큰 실수를 유발하는 지점입니다.\n결론부터 말씀드리겠습니다. 2025년 현재, 구글 플레이 스토어에 등록된 Termux는 여전히 업데이트가 중단된 deprecated(사용 중단) 버전입니다.\n사용자분께서 Play 스토어에서 업데이트가 된다고 보셨다면, 이는 Termux의 플러그인(Add-on)이거나, 유사한 이름의 다른 앱일 가능성이 높습니다. 공식 com.termux 앱 패키지는 다음과 같은 이유로 Play 스토어에서 사용해서는 안 됩니다.\n업데이트 중단: 2020년 9월 이후로 메인 앱의 업데이트가 없습니다. 보안 취약점: 5년 가까이 업데이트되지 않은 패키지는 수많은 보안 취약점을 내포하고 있습니다. 저장소(Repository) 문제: 패키지를 다운로드하는 서버 주소가 변경되어 pkg update 같은 핵심 명령어가 정상적으로 동작하지 않습니다. Termux 개발팀은 이러한 문제 때문에 공식적으로 F-Droid 또는 GitHub를 통한 설치를 권장하고 있습니다.\n따라서, Termux의 모든 기능을 안전하고 정상적으로 사용하려면 반드시 F-Droid 또는 GitHub에서 직접 설치해야 합니다. 이 점을 다시 한번 강조합니다.\nTermux 설치하기 # F-Droid는 안드로이드용 자유-오픈 소스 소프트웨어(FOSS)를 제공하는 신뢰할 수 있는 저장소입니다.\nF-Droid 웹사이트 방문 아래 링크를 통해 F-Droid의 Termux 페이지로 이동합니다. https://f-droid.org/packages/com.termux/ APK 파일 다운로드 페이지를 아래로 스크롤하여 \u0026lsquo;Versions\u0026rsquo; 섹션을 찾고, 가장 최신 버전의 \u0026lsquo;Download APK\u0026rsquo; 버튼을 눌러 설치 파일을 다운로드합니다.\n설치 진행 다운로드한 APK 파일을 실행하여 설치합니다. \u0026lsquo;알 수 없는 출처의 앱 설치\u0026rsquo; 권한이 필요할 수 있습니다. 안드로이드 시스템의 안내에 따라 권한을 허용하고 설치를 완료합니다.\nTermux 초기 설정 # 설치를 완료하고 앱을 실행하면, 검은 화면에 커서가 깜빡이는 익숙한 터미널 환경을 마주하게 됩니다. 가장 먼저 패키지들을 최신 상태로 만들어야 합니다.\n아래 명령어를 입력하세요.\npkg update \u0026amp;\u0026amp; pkg upgrade pkg: Termux에서 사용하는 패키지 관리자입니다. Debian 계열 리눅스의 apt와 유사한 역할을 합니다. update: 설치 가능한 패키지 목록을 최신 정보로 갱신합니다. upgrade: 현재 설치된 패키지들을 최신 버전으로 업그레이드합니다. 중간에 몇 가지 질문이 나올 수 있는데, 기본값(Y 또는 N)을 선택하여 엔터를 누르면 무난하게 진행됩니다.\n필수 도구 설치하기 # 이제 개발에 필요한 핵심 도구들을 설치해 보겠습니다.\n저장소 접근 설정 # Termux가 스마트폰의 파일 시스템(다운로드, 사진 폴더 등)에 접근하려면 권한 설정이 필요합니다.\ntermux-setup-storage 위 명령어를 실행하면 저장 공간 접근 권한을 요청하는 팝업이 나타납니다. \u0026lsquo;허용\u0026rsquo; 을 선택하세요.\n이제 홈 디렉터리(~)에 storage라는 이름의 심볼릭 링크(바로가기)가 생성됩니다. 이 폴더를 통해 스마트폰 내부 저장소에 접근할 수 있습니다.\n텍스트 에디터 (nano) # 간단한 스크립트나 설정 파일을 수정하려면 텍스트 에디터가 필요합니다. nano는 사용법이 직관적이라 초심자에게 적합합니다.\npkg install nano SSH 클라이언트 (openssh) # 원격 서버에 접속하여 작업하는 것은 개발자의 기본 업무 중 하나입니다. openssh를 설치하여 SSH 클라이언트를 사용할 수 있습니다.\npkg install openssh 아래 명령을 통해서 ssh key를 생성합니다.\nssh keygen ~/.ssh 폴더 내부에, id_ed25519 , id_ed25519.pub 파일이 정상적으로 생성완료 되면, ssh 접속을 사용할 수 있습니다.\n버전 관리 시스템 (git) # 소스 코드 관리를 위해 Git은 필수입니다.\npkg install git 프로그래밍 언어 (Python) # 다양한 자동화 스크립트 및 개발에 널리 사용되는 Python을 설치해 보겠습니다.\npkg install python 마치며 # 정확한 정보를 바탕으로 올바른 도구를 사용하는 것이 안전하고 효율적인 개발의 첫걸음입니다. F-Droid를 통해 최신 버전의 Termux를 설치하여, 안전하고 강력한 휴대용 개발 환경을 구축하시길 바랍니다.\n이제 여러분의 안드로이드 기기는 언제 어디서든 사용할 수 있는 훌륭한 보조 개발 머신이 되었습니다.\n참조\nTermux 공식 웹사이트: https://termux.dev/en/ Termux F-Droid 페이지: https://f-droid.org/packages/com.termux/ ","date":"19 June 2025","externalUrl":null,"permalink":"/posts/apps/termux/termux-setup-on-android/","section":"","summary":"","title":"안드로이드, 리눅스 머신으로 변신시키기: Termux 설치와 기본 설정 가이드 (2025년 최신판)","type":"posts"},{"content":"Hugo 블로그를 운영하면서 경험했던 내용을 모두 작성하고 있습니다.\nHugo 설치부터 배포까지 A to Z 20 June 2025\u0026middot;384 words\u0026middot;2 mins ","date":"15 June 2025","externalUrl":null,"permalink":"/posts/hosting/hugo/","section":"","summary":"","title":"Hugo 블로그 운영하기","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]